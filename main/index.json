{
  "index.html": {
    "href": "index.html",
    "title": "Page Redirection",
    "keywords": ""
  },
  "Sawmill.AutoRewriter-1.html": {
    "href": "Sawmill.AutoRewriter-1.html",
    "title": "Class AutoRewriter<T> | Sawmill",
    "keywords": "Class AutoRewriter<T> An experimental implementation of IRewriter<T> using reflection. AutoRewriter<T> looks for the subtype's constructor, and gets/sets the T -children in the order that they appear in the constructor. Inheritance System.Object AutoRewriter<T> Implements IRewriter <T> Declaration public class AutoRewriter<T> : Object, IRewriter<T> Type Parameters Name Description T The rewritable type. Constructors AutoRewriter() Create a new instance of AutoRewriter<T> . Declaration protected AutoRewriter() Properties Instance Gets the single global instance of AutoRewriter<T> . Declaration public static AutoRewriter<T> Instance { get; } Property Value Type Description AutoRewriter <T> The single global instance of AutoRewriter<T> . Methods CountChildren(T) See CountChildren(T) . Declaration public int CountChildren(T value) Parameters Type Name Description T value The rewritable tree. Returns Type Description System.Int32 The value 's number of immediate children. GetChildren(Span<T>, T) See GetChildren(Span<T>, T) . Declaration public void GetChildren(Span<T> childrenReceiver, T value) Parameters Type Name Description System.Span <T> childrenReceiver A System.Span<> to copy the current instance's immediate children into. The System.Span<> 's System.Span`1.Length should be equal to the number returned by CountChildren(T) . T value The rewritable tree. SetChildren(ReadOnlySpan<T>, T) See SetChildren(ReadOnlySpan<T>, T) . Declaration public T SetChildren(ReadOnlySpan<T> newChildren, T value) Parameters Type Name Description System.ReadOnlySpan <T> newChildren The new children. T value The rewritable tree. Returns Type Description T A copy of value with updated children. Implements IRewriter<T>"
  },
  "Sawmill.Cursor-1.html": {
    "href": "Sawmill.Cursor-1.html",
    "title": "Class Cursor<T> | Sawmill",
    "keywords": "Class Cursor<T> A Cursor<T> is a mutable view of a location in a T -structure, allowing efficient access to (and editing of) a node and its parent, siblings, and immediate children. You can think of a Cursor<T> as being focused on a particular node. After zooming in on a node, you can efficiently go up to the node's parent, down to the node's first child, or left or right to the node's immediate siblings. Cursor<T> is generally not as efficient or useful as the SelfAndDescendantsInContext<T>(IRewriter<T>, T) family for replacing single nodes, but it efficiently supports longer sequences of edits to a location and its neighbours. Inheritance System.Object Cursor<T> Declaration public sealed class Cursor<T> : Object Type Parameters Name Description T The rewritable tree type. Examples Here we traverse to, and replace, the right child of a binary node. Expr expr = new Add(new Lit(1), new Neg(new Lit(2))); var cursor = expr.Cursor(); cursor.Down(); cursor.Right(); Assert.Equal(new Neg(new Lit(2)), cursor.Focus); cursor.Focus = new Lit(10); cursor.Top(); Assert.Equal(new Add(new Lit(1), new Lit(10)), cursor.Focus); Properties Focus Gets or sets the current focus of the Cursor<T> . Declaration public T Focus { get; set; } Property Value Type Description T The current focus of the Cursor<T> . Methods Bottom() Move the current Focus to the bottom-left of the tree. Do nothing if the current Focus has no children. Declaration public void Bottom() Down() Focus the Cursor<T> on the current Focus 's first child. This operation \"opens a hole\" in the current node, descending to the children so you can replace them one at a time. Declaration public void Down() Exceptions Type Condition System.InvalidOperationException The current Focus 's has no children. Down(Int32) Go Down() count times. This operation \"opens a hole\" in the current node and its count first descendants. Declaration public void Down(int count) Parameters Type Name Description System.Int32 count The distance. Exceptions Type Condition System.InvalidOperationException The Cursor<T> reached a node with no children. The Cursor<T> is left in the last good state, that is, at the bottom of the tree. System.ArgumentOutOfRangeException count was negative. DownWhile(Func<T, Boolean>) Go Down() as long as predicate returns true for the current Focus . In other words, find the first leftmost descendant of Focus (including itself) which does not satisfy predicate . Declaration public void DownWhile(Func<T, bool> predicate) Parameters Type Name Description System.Func <T, System.Boolean > predicate The predicate to invoke on the current focus and its leftmost descendants. Exceptions Type Condition System.InvalidOperationException The Cursor<T> reached the root node. The Cursor<T> is left in the last good state, that is, at the bottom of the tree. Follow(IEnumerable<Direction>) Follow a path. Declaration public void Follow(IEnumerable<Direction> path) Parameters Type Name Description System.Collections.Generic.IEnumerable < Direction > path The path to follow. Exceptions Type Condition System.InvalidOperationException Thrown when path leads off the edge of the tree. The Cursor<T> is left in the last known good state. GetPath() Yields a sequence of Direction s describing how to get from the Top() of the tree to the current Focus . The resulting path can be Follow(IEnumerable<Direction>) ed by a Cursor<T> . This is useful if, for example, you need to compare the nodes at a given position in two different trees. Declaration public IEnumerable<Direction> GetPath() Returns Type Description System.Collections.Generic.IEnumerable < Direction > A sequence of Direction s. Left() Focus the Cursor<T> on the current Focus 's immediate predecessor sibling. Declaration public void Left() Exceptions Type Condition System.InvalidOperationException The Cursor<T> is already focused on the leftmost sibling. Left(Int32) Go Left() count times. Declaration public void Left(int count) Parameters Type Name Description System.Int32 count The distance. Exceptions Type Condition System.InvalidOperationException The Cursor<T> reached the leftmost sibling. The Cursor<T> is left in the last good state, that is, focused on the leftmost sibling. System.ArgumentOutOfRangeException count was negative. Leftmost() Focus the Cursor<T> on the current Focus 's leftmost sibling. Do nothing if the Cursor<T> is already focused on the leftmost sibling. Declaration public void Leftmost() LeftWhile(Func<T, Boolean>) Go Left() as long as predicate returns true for the current Focus . In other words, find the first left sibling of Focus (including itself) which does not satisfy predicate . Declaration public void LeftWhile(Func<T, bool> predicate) Parameters Type Name Description System.Func <T, System.Boolean > predicate The predicate to invoke on the current focus and its ancestors. Exceptions Type Condition System.InvalidOperationException The Cursor<T> reached the root node. The Cursor<T> is left in the last good state, that is, at the leftmost sibling. Move(Direction) Move in a given Direction . Declaration public void Move(Direction direction) Parameters Type Name Description Direction direction The Direction to move in. Exceptions Type Condition System.InvalidOperationException Thrown when the direction leads off the edge of the tree. The Cursor<T> is left in the last known good state. System.ArgumentOutOfRangeException Thrown when direction is not a valid Direction . ReleaseOldVersions() Release old versions of the tree for garbage collection. The Cursor<T> is left focused on the current node. Typically you won't need to call this method yourself - just call Top() at the end of your sequence of edits to get the new tree back. (This method is equivalent to calling Top() and then returning to where you were.) The worst-case scenario for Cursor<T> 's memory usage is code which traverses a large tree and alternates Down() calls with setting the Focus , without any calls to Up() in between. If this is a typical usage pattern for your application, and you find that Cursor<T> is causing high memory usage because it's holding on to old trees, some infrequent calls to this method (say, every 1000 edits) should improve the memory usage (at the cost of some speed). Declaration public void ReleaseOldVersions() Right() Focus the Cursor<T> on the current Focus 's immediate successor sibling. Declaration public void Right() Exceptions Type Condition System.InvalidOperationException The Cursor<T> is already focused on the rightmost sibling. Right(Int32) Go Right() count times. Declaration public void Right(int count) Parameters Type Name Description System.Int32 count The distance. Exceptions Type Condition System.InvalidOperationException The Cursor<T> reached the rightmost sibling. The Cursor<T> is left in the last good state, that is, focused on the rightmost sibling. System.ArgumentOutOfRangeException count was negative. Rightmost() Focus the Cursor<T> on the current Focus 's rightmost sibling. Do nothing if the Cursor<T> is already focused on the rightmost sibling. Declaration public void Rightmost() RightWhile(Func<T, Boolean>) Go Right() as long as predicate returns true for the current Focus . In other words, find the first Right sibling of Focus (including itself) which does not satisfy predicate . Declaration public void RightWhile(Func<T, bool> predicate) Parameters Type Name Description System.Func <T, System.Boolean > predicate The predicate to invoke on the current focus and its ancestors. Exceptions Type Condition System.InvalidOperationException The Cursor<T> reached the root node. The Cursor<T> is Right in the last good state, that is, at the Rightmost sibling. SearchDownAndRight(Func<T, Boolean>) Focus the current focus's first descendant or right sibling's descendant which satisfies predicate , searching descendants before siblings and ending at the current node's rightmost sibling. This function searches the bottom-left part of the tree first, so will typically end up focusing a node lower down than SearchRightAndDown(Func<T, Boolean>) . See SelfAndDescendants<T>(IRewriter<T>, T) . Declaration public bool SearchDownAndRight(Func<T, bool> predicate) Parameters Type Name Description System.Func <T, System.Boolean > predicate A predicate which returns true when the search should stop. Returns Type Description System.Boolean True if a matching focus was found, false if the search was exhaustive. SearchRightAndDown(Func<T, Boolean>) Focus the current focus's first descendant or right sibling's descendant which satisfies predicate , searching siblings before descendants and ending at the current node's lowest leftmost descendant. This function searches the top-right part of the tree first, so will typically end up focusing a node higher up than SearchDownAndRight(Func<T, Boolean>) . Declaration public bool SearchRightAndDown(Func<T, bool> predicate) Parameters Type Name Description System.Func <T, System.Boolean > predicate A predicate which returns true when the search should stop. Returns Type Description System.Boolean True if a matching focus was found, false if the search was exhaustive. Top() Move the Cursor<T> to the top of the tree. This operation \"plugs the hole\" in all of the current node's ancestors, replacing their children as necessary. Going to the Top() releases old versions of the tree so that they can be garbage collected. Declaration public void Top() TryDown() Try to focus the Cursor<T> on the current Focus 's first child. This operation \"opens a hole\" in the current node, descending to the children so you can replace them one at a time. Declaration public bool TryDown() Returns Type Description System.Boolean True if the operation was successful, false if the current Focus has no children. TryDown(Int32) Go Down() count times, stopping if you reach a node with no children. This operation \"opens a hole\" in the current node and its count first descendants. Declaration public bool TryDown(int count) Parameters Type Name Description System.Int32 count The distance. Returns Type Description System.Boolean True if the operation was successful, false if the cursor went Down() fewer than count times. Exceptions Type Condition System.ArgumentOutOfRangeException count was negative. TryDownWhile(Func<T, Boolean>) Go Down() as long as predicate returns true for the current Focus , stopping if you reach the bottom. In other words, find the first leftmost descendant of Focus (including itself) which does not satisfy predicate . Declaration public bool TryDownWhile(Func<T, bool> predicate) Parameters Type Name Description System.Func <T, System.Boolean > predicate The predicate to invoke on the current focus and its leftmost descendants. Returns Type Description System.Boolean True if a leftmost descendant not satisfying predicate was found, false if the Cursor<T> reached the bottom. TryFollow(IEnumerable<Direction>) Follow a path. Declaration public bool TryFollow(IEnumerable<Direction> path) Parameters Type Name Description System.Collections.Generic.IEnumerable < Direction > path The path to follow. Returns Type Description System.Boolean True if the path was successfully followed in full, false if the path led off the edge of the tree. TryLeft() Try to focus the Cursor<T> on the current Focus 's immediate predecessor sibling. Declaration public bool TryLeft() Returns Type Description System.Boolean True if the operation was successful, false if the Cursor<T> is already focused on the leftmost sibling. TryLeft(Int32) Go Left() count times, stopping if you reach the leftmost sibling. Declaration public bool TryLeft(int count) Parameters Type Name Description System.Int32 count The distance. Returns Type Description System.Boolean True if the operation was successful, false if the cursor went Left() fewer than count times. Exceptions Type Condition System.ArgumentOutOfRangeException count was negative. TryLeftWhile(Func<T, Boolean>) Go Left() as long as predicate returns true for the current Focus , stopping if you reach the leftmost sibling. In other words, find the left sibling of Focus (including itself) which does not satisfy predicate . Declaration public bool TryLeftWhile(Func<T, bool> predicate) Parameters Type Name Description System.Func <T, System.Boolean > predicate The predicate to invoke on the current focus and its ancestors. Returns Type Description System.Boolean True if an ancestor not satisfying predicate was found, false if the Cursor<T> reached the leftmost sibling. TryMove(Direction) Try to move in a given Direction . Declaration public bool TryMove(Direction direction) Parameters Type Name Description Direction direction The Direction to move in. Returns Type Description System.Boolean True if the operation was successful, false if the direction leads off the edge of the tree. Exceptions Type Condition System.ArgumentOutOfRangeException Thrown when direction is not a valid Direction . TryRight() Try to focus the Cursor<T> on the current Focus 's immediate successor sibling. Declaration public bool TryRight() Returns Type Description System.Boolean True if the operation was successful, false if the Cursor<T> is already focused on the rightmost sibling. TryRight(Int32) Go Right() count times, stopping if you reach the rightmost sibling. Declaration public bool TryRight(int count) Parameters Type Name Description System.Int32 count The distance. Returns Type Description System.Boolean True if the operation was successful, false if the cursor went Right() fewer than count times. Exceptions Type Condition System.ArgumentOutOfRangeException count was negative. TryRightWhile(Func<T, Boolean>) Go Right() as long as predicate returns true for the current Focus , stopping if you reach the Rightmost sibling. In other words, find the Right sibling of Focus (including itself) which does not satisfy predicate . Declaration public bool TryRightWhile(Func<T, bool> predicate) Parameters Type Name Description System.Func <T, System.Boolean > predicate The predicate to invoke on the current focus and its ancestors. Returns Type Description System.Boolean True if an ancestor not satisfying predicate was found, false if the Cursor<T> reached the Rightmost sibling. TryUp() Try to focus the Cursor<T> on the current Focus 's parent. This operation \"plugs the hole\" in the parent, replacing the parent's children as necessary. This releases old versions of the current Focus and its children, so that they can be garbage collected. Declaration public bool TryUp() Returns Type Description System.Boolean True if the operation was successful, false if the Cursor<T> is already focused on the root node. TryUp(Int32) Go Up() count times, stopping if you reach the top. This operation \"plugs the hole\" in the parent, replacing the parent's children as necessary. This releases old versions of the ancestors and their children, so that they can be garbage collected. Declaration public bool TryUp(int count) Parameters Type Name Description System.Int32 count The distance. Returns Type Description System.Boolean True if the operation was successful, false if the cursor went Up() fewer than count times. Exceptions Type Condition System.ArgumentOutOfRangeException count was negative. TryUpWhile(Func<T, Boolean>) Go Up() as long as predicate returns true for the current Focus , stopping if you reach the top. In other words, find the first ancestor of Focus (including itself) which does not satisfy predicate . This operation \"plugs the hole\" in the ancestors, replacing their children as necessary. This releases old versions of the ancestors and their children, so that they can be garbage collected. Declaration public bool TryUpWhile(Func<T, bool> predicate) Parameters Type Name Description System.Func <T, System.Boolean > predicate The predicate to invoke on the current focus and its ancestors. Returns Type Description System.Boolean True if an ancestor not satisfying predicate was found, false if the Cursor<T> reached the top. Up() Focus the Cursor<T> on the current Focus 's parent. Going Up() \"plugs the hole\" in the parent, replacing the parent's children as necessary. This releases old versions of the current Focus and its children so that they can be garbage collected. Declaration public void Up() Exceptions Type Condition System.InvalidOperationException The Cursor<T> is already focused on the root node. Up(Int32) Go Up() count times. Going Up(Int32) \"plugs the hole\" in the ancestors, replacing their children as necessary. This releases old versions of the ancestors and their children, so that they can be garbage collected. Declaration public void Up(int count) Parameters Type Name Description System.Int32 count The distance. Exceptions Type Condition System.InvalidOperationException The Cursor<T> reached the root node. The Cursor<T> is left in the last good state, that is, at the top of the tree. System.ArgumentOutOfRangeException count was negative. UpWhile(Func<T, Boolean>) Go Up() as long as predicate returns true for the current Focus . In other words, find the first ancestor of Focus (including itself) which does not satisfy predicate . This operation \"plugs the hole\" in the ancestors, replacing their children as necessary. This releases old versions of the ancestors and their children, so that they can be garbage collected. Declaration public void UpWhile(Func<T, bool> predicate) Parameters Type Name Description System.Func <T, System.Boolean > predicate The predicate to invoke on the current focus and its ancestors. Exceptions Type Condition System.InvalidOperationException The Cursor<T> reached the root node. The Cursor<T> is left in the last good state, that is, at the top of the tree."
  },
  "Sawmill.Direction.html": {
    "href": "Sawmill.Direction.html",
    "title": "Class Direction | Sawmill",
    "keywords": "Class Direction Represents a direction that a Cursor<T> can move in. Inheritance System.Object Direction Declaration public sealed class Direction : Enum Fields Down Move to the first child. Declaration public const Direction Down Field Value Type Description Direction Left Move to the previous sibling. Declaration public const Direction Left Field Value Type Description Direction Right Move to the next sibling. Declaration public const Direction Right Field Value Type Description Direction Up Move to the parent. Declaration public const Direction Up Field Value Type Description Direction value__ Declaration public int value__ Field Value Type Description System.Int32"
  },
  "Sawmill.Expressions.ExpressionExtensions.html": {
    "href": "Sawmill.Expressions.ExpressionExtensions.html",
    "title": "Class ExpressionExtensions | Sawmill",
    "keywords": "Class ExpressionExtensions Extension methods for System.Linq.Expressions.Expression s. Inheritance System.Object ExpressionExtensions Declaration public static class ExpressionExtensions : Object Methods ChildrenInContext(Expression) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See SelfAndDescendantsInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static (Expression, Func<Expression, Expression>)[] ChildrenInContext(this Expression value) Parameters Type Name Description System.Linq.Expressions.Expression value Returns Type Description System.ValueTuple < System.Linq.Expressions.Expression , System.Func < System.Linq.Expressions.Expression , System.Linq.Expressions.Expression >>[] An enumerable of contexts. CountChildren(Expression) Count the immediate children of the value. See CountChildren() . Declaration public static int CountChildren(this Expression value) Parameters Type Name Description System.Linq.Expressions.Expression value Returns Type Description System.Int32 value 's number of immediate children. Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren(T) counts the immediate children of the topmost (Add) node. Assert.Equal(2, rewriter.CountChildren(expr)); Cursor(Expression) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value . Declaration public static Cursor<Expression> Cursor(this Expression value) Parameters Type Name Description System.Linq.Expressions.Expression value Returns Type Description Cursor < System.Linq.Expressions.Expression > A Cursor<T>(IRewriter<T>, T) focused on the root node of value . DescendantAt(Expression, IEnumerable<Direction>) Returns the descendant at a particular location in value . Declaration public static Expression DescendantAt(this Expression value, IEnumerable<Direction> path) Parameters Type Name Description System.Linq.Expressions.Expression value System.Collections.Generic.IEnumerable < Direction > path Returns Type Description System.Linq.Expressions.Expression The descendant found by following the directions in path . Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelf(Expression) Yields all of the nodes in the tree represented by value , starting at the bottom. This is a depth-first post-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . Declaration public static IEnumerable<Expression> DescendantsAndSelf(this Expression value) Parameters Type Name Description System.Linq.Expressions.Expression value Returns Type Description System.Collections.Generic.IEnumerable < System.Linq.Expressions.Expression > An enumerable containing all of the nodes in the tree represented by value , starting at the bottom. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); DescendantsAndSelfInContext(Expression) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See DescendantsAndSelf<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See SelfAndDescendantsInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(Expression, Func<Expression, Expression>)> DescendantsAndSelfInContext(this Expression value) Parameters Type Name Description System.Linq.Expressions.Expression value Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple < System.Linq.Expressions.Expression , System.Func < System.Linq.Expressions.Expression , System.Linq.Expressions.Expression >>> An enumerable of contexts. Fold<T>(Expression, SpanFunc<T, Expression, T>) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static T Fold<T>(this Expression value, SpanFunc<T, Expression, T> func) Parameters Type Name Description System.Linq.Expressions.Expression value SpanFunc <T, System.Linq.Expressions.Expression , T> func Returns Type Description T The result of aggregating the tree represented by value . Type Parameters Name Description T Fold<T>(Expression, Func<Memory<T>, Expression, ValueTask<T>>) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<T> Fold<T>(this Expression value, Func<Memory<T>, Expression, ValueTask<T>> func) Parameters Type Name Description System.Linq.Expressions.Expression value System.Func < System.Memory <T>, System.Linq.Expressions.Expression , System.Threading.Tasks.ValueTask <T>> func Returns Type Description System.Threading.Tasks.ValueTask <T> The result of aggregating the tree represented by value . Type Parameters Name Description T Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . GetChildren(Expression) Get the immediate children of the value. See GetChildren(Span<T>) . Declaration public static Expression[] GetChildren(this Expression value) Parameters Type Name Description System.Linq.Expressions.Expression value Returns Type Description System.Linq.Expressions.Expression [] The immediate children of value . Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); GetChildren(Expression, Span<Expression>) Copy the immediate children of the value into childrenReceiver . See GetChildren(Span<T>) . Declaration public static void GetChildren(this Expression value, Span<Expression> childrenReceiver) Parameters Type Name Description System.Linq.Expressions.Expression value System.Span < System.Linq.Expressions.Expression > childrenReceiver Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>, T) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[rewriter.CountChildren(expr)]; rewriter.GetChildren(array, expr); Assert.Equal(expected, array); ReplaceDescendantAt<T>(Expression, IEnumerable<Direction>, Expression) Replaces the descendant at a particular location in value . Declaration public static Expression ReplaceDescendantAt<T>(this Expression value, IEnumerable<Direction> path, Expression newDescendant) Parameters Type Name Description System.Linq.Expressions.Expression value System.Collections.Generic.IEnumerable < Direction > path System.Linq.Expressions.Expression newDescendant Returns Type Description System.Linq.Expressions.Expression A copy of value with newDescendant placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. Rewrite(Expression, Func<Expression, Expression>) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static Expression Rewrite(this Expression value, Func<Expression, Expression> transformer) Parameters Type Name Description System.Linq.Expressions.Expression value System.Func < System.Linq.Expressions.Expression , System.Linq.Expressions.Expression > transformer Returns Type Description System.Linq.Expressions.Expression The result of applying transformer to every node in the tree represented by value . Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer , then replaces their parents with the result of calling transformer , and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); Rewrite(Expression, Func<Expression, ValueTask<Expression>>) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<Expression> Rewrite(this Expression value, Func<Expression, ValueTask<Expression>> transformer) Parameters Type Name Description System.Linq.Expressions.Expression value System.Func < System.Linq.Expressions.Expression , System.Threading.Tasks.ValueTask < System.Linq.Expressions.Expression >> transformer Returns Type Description System.Threading.Tasks.ValueTask < System.Linq.Expressions.Expression > The result of applying transformer to every node in the tree represented by value . Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer , then replaces their parents with the result of calling transformer , and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); RewriteChildren(Expression, Func<Expression, Expression>) Update the immediate children of the value by applying a transformation function to each one. Declaration public static Expression RewriteChildren(this Expression value, Func<Expression, Expression> transformer) Parameters Type Name Description System.Linq.Expressions.Expression value System.Func < System.Linq.Expressions.Expression , System.Linq.Expressions.Expression > transformer Returns Type Description System.Linq.Expressions.Expression A copy of value with updated children. RewriteChildren(Expression, Func<Expression, ValueTask<Expression>>) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<Expression> RewriteChildren(this Expression value, Func<Expression, ValueTask<Expression>> transformer) Parameters Type Name Description System.Linq.Expressions.Expression value System.Func < System.Linq.Expressions.Expression , System.Threading.Tasks.ValueTask < System.Linq.Expressions.Expression >> transformer Returns Type Description System.Threading.Tasks.ValueTask < System.Linq.Expressions.Expression > A copy of value with updated children. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . RewriteDescendantAt<T>(Expression, IEnumerable<Direction>, Func<Expression, Expression>) Apply a function at a particular location in value . Declaration public static Expression RewriteDescendantAt<T>(this Expression value, IEnumerable<Direction> path, Func<Expression, Expression> transformer) Parameters Type Name Description System.Linq.Expressions.Expression value System.Collections.Generic.IEnumerable < Direction > path System.Func < System.Linq.Expressions.Expression , System.Linq.Expressions.Expression > transformer Returns Type Description System.Linq.Expressions.Expression A copy of value with the result of transformer placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(Expression, IEnumerable<Direction>, Func<Expression, ValueTask<Expression>>) Apply an asynchronous function at a particular location in value . Declaration public static ValueTask<Expression> RewriteDescendantAt<T>(this Expression value, IEnumerable<Direction> path, Func<Expression, ValueTask<Expression>> transformer) Parameters Type Name Description System.Linq.Expressions.Expression value System.Collections.Generic.IEnumerable < Direction > path System.Func < System.Linq.Expressions.Expression , System.Threading.Tasks.ValueTask < System.Linq.Expressions.Expression >> transformer Returns Type Description System.Threading.Tasks.ValueTask < System.Linq.Expressions.Expression > A copy of value with the result of transformer placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter(Expression, Func<Expression, Expression>) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x) . This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static Expression RewriteIter(this Expression value, Func<Expression, Expression> transformer) Parameters Type Name Description System.Linq.Expressions.Expression value System.Func < System.Linq.Expressions.Expression , System.Linq.Expressions.Expression > transformer Returns Type Description System.Linq.Expressions.Expression The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. RewriteIter(Expression, Func<Expression, ValueTask<Expression>>) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x) . This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<Expression> RewriteIter(this Expression value, Func<Expression, ValueTask<Expression>> transformer) Parameters Type Name Description System.Linq.Expressions.Expression value System.Func < System.Linq.Expressions.Expression , System.Threading.Tasks.ValueTask < System.Linq.Expressions.Expression >> transformer Returns Type Description System.Threading.Tasks.ValueTask < System.Linq.Expressions.Expression > The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . SelfAndDescendants(Expression) Yields all of the nodes in the tree represented by value , starting at the top. This is a depth-first pre-order traversal. See DescendantsAndSelf<T>(IRewriter<T>, T) . Declaration public static IEnumerable<Expression> SelfAndDescendants(this Expression value) Parameters Type Name Description System.Linq.Expressions.Expression value Returns Type Description System.Collections.Generic.IEnumerable < System.Linq.Expressions.Expression > An enumerable containing all of the nodes in the tree represented by value , starting at the top. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); SelfAndDescendantsBreadthFirst(Expression) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<Expression> SelfAndDescendantsBreadthFirst(this Expression value) Parameters Type Name Description System.Linq.Expressions.Expression value Returns Type Description System.Collections.Generic.IEnumerable < System.Linq.Expressions.Expression > An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. SelfAndDescendantsInContext(Expression) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(Expression, Func<Expression, Expression>)> SelfAndDescendantsInContext(this Expression value) Parameters Type Name Description System.Linq.Expressions.Expression value Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple < System.Linq.Expressions.Expression , System.Func < System.Linq.Expressions.Expression , System.Linq.Expressions.Expression >>> An enumerable of contexts. SelfAndDescendantsInContextBreadthFirst(Expression) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(Expression, Func<Expression, Expression>)> SelfAndDescendantsInContextBreadthFirst(this Expression value) Parameters Type Name Description System.Linq.Expressions.Expression value Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple < System.Linq.Expressions.Expression , System.Func < System.Linq.Expressions.Expression , System.Linq.Expressions.Expression >>> An enumerable of contexts. SetChildren(Expression, ReadOnlySpan<Expression>) Set the immediate children of the value. Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>, T) . See SetChildren(ReadOnlySpan<T>) . Declaration public static Expression SetChildren(this Expression value, ReadOnlySpan<Expression> newChildren) Parameters Type Name Description System.Linq.Expressions.Expression value System.ReadOnlySpan < System.Linq.Expressions.Expression > newChildren Returns Type Description System.Linq.Expressions.Expression A copy of value with updated children. Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>, T) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, rewriter.SetChildren(Children.Two(new Lit(4), new Lit(5)), expr)); ZipFold<U>(Expression, Expression, Func<Expression, Expression, IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this Expression value1, Expression value2, Func<Expression, Expression, IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description System.Linq.Expressions.Expression value1 System.Linq.Expressions.Expression value2 System.Func < System.Linq.Expressions.Expression , System.Linq.Expressions.Expression , System.Collections.Generic.IAsyncEnumerable <U>, System.Threading.Tasks.ValueTask <U>> func Returns Type Description System.Threading.Tasks.ValueTask <U> The result of aggregating the two trees. Type Parameters Name Description U Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask and System.Collections.Generic.IAsyncEnumerable`1 . Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(Expression, Expression, Func<Expression, Expression, IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this Expression value1, Expression value2, Func<Expression, Expression, IEnumerable<U>, U> func) Parameters Type Name Description System.Linq.Expressions.Expression value1 System.Linq.Expressions.Expression value2 System.Func < System.Linq.Expressions.Expression , System.Linq.Expressions.Expression , System.Collections.Generic.IEnumerable <U>, U> func Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(Expression[], Func<Expression[], IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this Expression[] values, Func<Expression[], IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description System.Linq.Expressions.Expression [] values System.Func < System.Linq.Expressions.Expression [], System.Collections.Generic.IAsyncEnumerable <U>, System.Threading.Tasks.ValueTask <U>> func Returns Type Description System.Threading.Tasks.ValueTask <U> The result of aggregating the two trees. Type Parameters Name Description U Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask and System.Collections.Generic.IAsyncEnumerable`1 . Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(Expression[], Func<Expression[], IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this Expression[] values, Func<Expression[], IEnumerable<U>, U> func) Parameters Type Name Description System.Linq.Expressions.Expression [] values System.Func < System.Linq.Expressions.Expression [], System.Collections.Generic.IEnumerable <U>, U> func Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.Expressions.ExpressionRewriter.html": {
    "href": "Sawmill.Expressions.ExpressionRewriter.html",
    "title": "Class ExpressionRewriter | Sawmill",
    "keywords": "Class ExpressionRewriter An implementation of IRewriter<T> for System.Linq.Expressions.Expression s. Inheritance System.Object ExpressionRewriter Implements IRewriter < System.Linq.Expressions.Expression > Declaration public class ExpressionRewriter : Object, IRewriter<Expression> Constructors ExpressionRewriter() Create a new instance of ExpressionRewriter . Declaration protected ExpressionRewriter() Properties Instance Gets the single global instance of ExpressionRewriter . Declaration public static ExpressionRewriter Instance { get; } Property Value Type Description ExpressionRewriter The single global instance of ExpressionRewriter . Methods CountChildren(Expression) See CountChildren(T) . Declaration public int CountChildren(Expression value) Parameters Type Name Description System.Linq.Expressions.Expression value The value. Returns Type Description System.Int32 value 's number of immediate children. GetChildren(Span<Expression>, Expression) See GetChildren(Span<T>, T) . Declaration public void GetChildren(Span<Expression> childrenReceiver, Expression value) Parameters Type Name Description System.Span < System.Linq.Expressions.Expression > childrenReceiver A System.Span<> to copy value 's immediate children into. The System.Span<> 's System.Span`1.Length will be equal to the number returned by CountChildren(Expression) . System.Linq.Expressions.Expression value The value. SetChildren(ReadOnlySpan<Expression>, Expression) See SetChildren(ReadOnlySpan<T>, T) . Declaration public Expression SetChildren(ReadOnlySpan<Expression> newChildren, Expression value) Parameters Type Name Description System.ReadOnlySpan < System.Linq.Expressions.Expression > newChildren The new children. System.Linq.Expressions.Expression value The old value, whose immediate children should be replaced. Returns Type Description System.Linq.Expressions.Expression A copy of value with updated children. Implements IRewriter<T>"
  },
  "Sawmill.Expressions.html": {
    "href": "Sawmill.Expressions.html",
    "title": "Namespace Sawmill.Expressions | Sawmill",
    "keywords": "Namespace Sawmill.Expressions Classes ExpressionExtensions Extension methods for System.Linq.Expressions.Expression s. ExpressionRewriter An implementation of IRewriter<T> for System.Linq.Expressions.Expression s."
  },
  "Sawmill.html": {
    "href": "Sawmill.html",
    "title": "Namespace Sawmill | Sawmill",
    "keywords": "Namespace Sawmill Classes AutoRewriter<T> An experimental implementation of IRewriter<T> using reflection. AutoRewriter<T> looks for the subtype's constructor, and gets/sets the T -children in the order that they appear in the constructor. Cursor<T> A Cursor<T> is a mutable view of a location in a T -structure, allowing efficient access to (and editing of) a node and its parent, siblings, and immediate children. You can think of a Cursor<T> as being focused on a particular node. After zooming in on a node, you can efficiently go up to the node's parent, down to the node's first child, or left or right to the node's immediate siblings. Cursor<T> is generally not as efficient or useful as the SelfAndDescendantsInContext<T>(IRewriter<T>, T) family for replacing single nodes, but it efficiently supports longer sequences of edits to a location and its neighbours. Direction Represents a direction that a Cursor<T> can move in. Rewritable Extension methods for IRewritable<T> implementations. RewritableRewriter<T> An implementation of IRewriter<T> for T s which implement IRewritable<T> . Rewriter Extension methods for IRewriter<T> implementations. RewriterBuilder Tools for building rewriters. RewriterBuilder<T> Tools for building rewriters. RewriterBuilderCase Tools for building rewriters for a single subclass of a base type. RewriterBuilderCase<TArgs, TBase, TSub> Tools for building rewriters for a single subclass of a base type. SpanFunc<T, U, R> A System.Func<, , > whose first argument is a System.Span<> . Interfaces IRewritable<T> A object is rewriterable if it knows how to access its immediate children. Implementations should ensure that you always get the children you just set ( rewritable.SetChildren(children).GetChildren() == children ), and that successive sets overwrite the earlier operation ( rewritable.SetChildren(children1).SetChildren(children2) == rewritable.SetChildren(children2) ). See IRewriter<T> . IRewriter<T> A rewriter is an object which knows how to access the immediate children of a value of type T . Implementations should ensure that you always get the children you just set ( rewriter.GetChildren(rewriter.SetChildren(children, expr)) == children ), and that successive sets overwrite the earlier operation ( rewriter.SetChildren(children2, rewriter.SetChildren(children1, expr)) == rewriter.SetChildren(children2, expr) ). See IRewritable<T> ."
  },
  "Sawmill.IRewritable-1.html": {
    "href": "Sawmill.IRewritable-1.html",
    "title": "Interface IRewritable<T> | Sawmill",
    "keywords": "Interface IRewritable<T> A object is rewriterable if it knows how to access its immediate children. Implementations should ensure that you always get the children you just set ( rewritable.SetChildren(children).GetChildren() == children ), and that successive sets overwrite the earlier operation ( rewritable.SetChildren(children1).SetChildren(children2) == rewritable.SetChildren(children2) ). See IRewriter<T> . Declaration public interface IRewritable<T> where T : IRewritable<T> Type Parameters Name Description T The type of the object implementing the interface. Methods CountChildren() Count the immediate children of the value. See CountChildren(T) . Declaration int CountChildren() Returns Type Description System.Int32 The current instance's number of immediate children. Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren() counts the immediate children of the topmost (Add) node. Assert.Equal(2, expr.CountChildren()); GetChildren(Span<T>) Copy the immediate children of the value into childrenReceiver . See GetChildren(Span<T>, T) . Declaration void GetChildren(Span<T> childrenReceiver) Parameters Type Name Description System.Span <T> childrenReceiver A System.Span<> to copy the current instance's immediate children into. The System.Span<> 's System.Span`1.Length should be equal to the number returned by CountChildren() . Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[expr.CountChildren()]; expr.GetChildren(array); Assert.Equal(expected, array); SetChildren(ReadOnlySpan<T>) Set the immediate children of the currentInstance. Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>) . See SetChildren(ReadOnlySpan<T>, T) . Declaration T SetChildren(ReadOnlySpan<T> newChildren) Parameters Type Name Description System.ReadOnlySpan <T> newChildren The new children. Returns Type Description T A copy of the current instance with updated children. Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, expr.SetChildren(Children.Two(new Lit(4), new Lit(5))));"
  },
  "Sawmill.IRewriter-1.html": {
    "href": "Sawmill.IRewriter-1.html",
    "title": "Interface IRewriter<T> | Sawmill",
    "keywords": "Interface IRewriter<T> A rewriter is an object which knows how to access the immediate children of a value of type T . Implementations should ensure that you always get the children you just set ( rewriter.GetChildren(rewriter.SetChildren(children, expr)) == children ), and that successive sets overwrite the earlier operation ( rewriter.SetChildren(children2, rewriter.SetChildren(children1, expr)) == rewriter.SetChildren(children2, expr) ). See IRewritable<T> . Declaration public interface IRewriter<T> Type Parameters Name Description T The type for which the rewriter can get the immediate children. Methods CountChildren(T) Count the immediate children of the value. See CountChildren() . Declaration int CountChildren(T value) Parameters Type Name Description T value The value. Returns Type Description System.Int32 value 's number of immediate children. Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren(T) counts the immediate children of the topmost (Add) node. Assert.Equal(2, rewriter.CountChildren(expr)); GetChildren(Span<T>, T) Copy the immediate children of the value into childrenReceiver . See GetChildren(Span<T>) . Declaration void GetChildren(Span<T> childrenReceiver, T value) Parameters Type Name Description System.Span <T> childrenReceiver A System.Span<> to copy value 's immediate children into. The System.Span<> 's System.Span`1.Length will be equal to the number returned by CountChildren(T) . T value The value. Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>, T) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[rewriter.CountChildren(expr)]; rewriter.GetChildren(array, expr); Assert.Equal(expected, array); SetChildren(ReadOnlySpan<T>, T) Set the immediate children of the value. Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>, T) . See SetChildren(ReadOnlySpan<T>) . Declaration T SetChildren(ReadOnlySpan<T> newChildren, T value) Parameters Type Name Description System.ReadOnlySpan <T> newChildren The new children. T value The old value, whose immediate children should be replaced. Returns Type Description T A copy of value with updated children. Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>, T) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, rewriter.SetChildren(Children.Two(new Lit(4), new Lit(5)), expr)); Extension Methods Rewriter.ChildrenInContext<T>(IRewriter<T>, T) Rewriter.Cursor<T>(IRewriter<T>, T) Rewriter.DescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, T) Rewriter.ReplaceDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, T, T) Rewriter.RewriteDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, Func<T, T>, T) Rewriter.RewriteDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, Func<T, ValueTask<T>>, T) Rewriter.DescendantsAndSelf<T>(IRewriter<T>, T) Rewriter.DescendantsAndSelfInContext<T>(IRewriter<T>, T) Rewriter.Fold<T, U>(IRewriter<T>, SpanFunc<U, T, U>, T) Rewriter.Fold<T, U>(IRewriter<T>, Func<Memory<U>, T, ValueTask<U>>, T) Rewriter.GetChildren<T>(IRewriter<T>, T) Rewriter.Rewrite<T>(IRewriter<T>, Func<T, T>, T) Rewriter.Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rewriter.RewriteChildren<T>(IRewriter<T>, Func<T, T>, T) Rewriter.RewriteChildren<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rewriter.SelfAndDescendants<T>(IRewriter<T>, T) Rewriter.SelfAndDescendantsBreadthFirst<T>(IRewriter<T>, T) Rewriter.SelfAndDescendantsInContext<T>(IRewriter<T>, T) Rewriter.SelfAndDescendantsInContextBreadthFirst<T>(IRewriter<T>, T) Rewriter.ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, T[]) Rewriter.ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, T[])"
  },
  "Sawmill.Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNodeExtensions.html": {
    "href": "Sawmill.Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNodeExtensions.html",
    "title": "Class CSharpSyntaxNodeExtensions | Sawmill",
    "keywords": "Class CSharpSyntaxNodeExtensions Extension methods for Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode s. Inheritance System.Object CSharpSyntaxNodeExtensions Declaration public static class CSharpSyntaxNodeExtensions : Object Methods ChildrenInContext(CSharpSyntaxNode) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See SelfAndDescendantsInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static (CSharpSyntaxNode, Func<CSharpSyntaxNode, CSharpSyntaxNode>)[] ChildrenInContext(this CSharpSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value Returns Type Description System.ValueTuple < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , System.Func < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode >>[] An enumerable of contexts. CountChildren(CSharpSyntaxNode) Count the immediate children of the value. See CountChildren() . Declaration public static int CountChildren(this CSharpSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value Returns Type Description System.Int32 value 's number of immediate children. Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren(T) counts the immediate children of the topmost (Add) node. Assert.Equal(2, rewriter.CountChildren(expr)); Cursor(CSharpSyntaxNode) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value . Declaration public static Cursor<CSharpSyntaxNode> Cursor(this CSharpSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value Returns Type Description Cursor < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode > A Cursor<T>(IRewriter<T>, T) focused on the root node of value . DescendantAt(CSharpSyntaxNode, IEnumerable<Direction>) Returns the descendant at a particular location in value . Declaration public static CSharpSyntaxNode DescendantAt(this CSharpSyntaxNode value, IEnumerable<Direction> path) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value System.Collections.Generic.IEnumerable < Direction > path Returns Type Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode The descendant found by following the directions in path . Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelf(CSharpSyntaxNode) Yields all of the nodes in the tree represented by value , starting at the bottom. This is a depth-first post-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . Declaration public static IEnumerable<CSharpSyntaxNode> DescendantsAndSelf(this CSharpSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value Returns Type Description System.Collections.Generic.IEnumerable < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode > An enumerable containing all of the nodes in the tree represented by value , starting at the bottom. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); DescendantsAndSelfInContext(CSharpSyntaxNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See DescendantsAndSelf<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See SelfAndDescendantsInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(CSharpSyntaxNode, Func<CSharpSyntaxNode, CSharpSyntaxNode>)> DescendantsAndSelfInContext(this CSharpSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , System.Func < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode >>> An enumerable of contexts. Fold<T>(CSharpSyntaxNode, SpanFunc<T, CSharpSyntaxNode, T>) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static T Fold<T>(this CSharpSyntaxNode value, SpanFunc<T, CSharpSyntaxNode, T> func) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value SpanFunc <T, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , T> func Returns Type Description T The result of aggregating the tree represented by value . Type Parameters Name Description T Fold<T>(CSharpSyntaxNode, Func<Memory<T>, CSharpSyntaxNode, ValueTask<T>>) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<T> Fold<T>(this CSharpSyntaxNode value, Func<Memory<T>, CSharpSyntaxNode, ValueTask<T>> func) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value System.Func < System.Memory <T>, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , System.Threading.Tasks.ValueTask <T>> func Returns Type Description System.Threading.Tasks.ValueTask <T> The result of aggregating the tree represented by value . Type Parameters Name Description T Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . GetChildren(CSharpSyntaxNode) Get the immediate children of the value. See GetChildren(Span<T>) . Declaration public static CSharpSyntaxNode[] GetChildren(this CSharpSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value Returns Type Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode [] The immediate children of value . Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); GetChildren(CSharpSyntaxNode, Span<CSharpSyntaxNode>) Copy the immediate children of the value into childrenReceiver . See GetChildren(Span<T>) . Declaration public static void GetChildren(this CSharpSyntaxNode value, Span<CSharpSyntaxNode> childrenReceiver) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value System.Span < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode > childrenReceiver Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>, T) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[rewriter.CountChildren(expr)]; rewriter.GetChildren(array, expr); Assert.Equal(expected, array); ReplaceDescendantAt<T>(CSharpSyntaxNode, IEnumerable<Direction>, CSharpSyntaxNode) Replaces the descendant at a particular location in value . Declaration public static CSharpSyntaxNode ReplaceDescendantAt<T>(this CSharpSyntaxNode value, IEnumerable<Direction> path, CSharpSyntaxNode newDescendant) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value System.Collections.Generic.IEnumerable < Direction > path Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode newDescendant Returns Type Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode A copy of value with newDescendant placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. Rewrite(CSharpSyntaxNode, Func<CSharpSyntaxNode, CSharpSyntaxNode>) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static CSharpSyntaxNode Rewrite(this CSharpSyntaxNode value, Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value System.Func < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode > transformer Returns Type Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode The result of applying transformer to every node in the tree represented by value . Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer , then replaces their parents with the result of calling transformer , and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); Rewrite(CSharpSyntaxNode, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>>) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<CSharpSyntaxNode> Rewrite(this CSharpSyntaxNode value, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value System.Func < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , System.Threading.Tasks.ValueTask < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode >> transformer Returns Type Description System.Threading.Tasks.ValueTask < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode > The result of applying transformer to every node in the tree represented by value . Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer , then replaces their parents with the result of calling transformer , and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); RewriteChildren(CSharpSyntaxNode, Func<CSharpSyntaxNode, CSharpSyntaxNode>) Update the immediate children of the value by applying a transformation function to each one. Declaration public static CSharpSyntaxNode RewriteChildren(this CSharpSyntaxNode value, Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value System.Func < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode > transformer Returns Type Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode A copy of value with updated children. RewriteChildren(CSharpSyntaxNode, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>>) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<CSharpSyntaxNode> RewriteChildren(this CSharpSyntaxNode value, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value System.Func < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , System.Threading.Tasks.ValueTask < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode >> transformer Returns Type Description System.Threading.Tasks.ValueTask < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode > A copy of value with updated children. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . RewriteDescendantAt<T>(CSharpSyntaxNode, IEnumerable<Direction>, Func<CSharpSyntaxNode, CSharpSyntaxNode>) Apply a function at a particular location in value . Declaration public static CSharpSyntaxNode RewriteDescendantAt<T>(this CSharpSyntaxNode value, IEnumerable<Direction> path, Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value System.Collections.Generic.IEnumerable < Direction > path System.Func < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode > transformer Returns Type Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode A copy of value with the result of transformer placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(CSharpSyntaxNode, IEnumerable<Direction>, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>>) Apply an asynchronous function at a particular location in value . Declaration public static ValueTask<CSharpSyntaxNode> RewriteDescendantAt<T>(this CSharpSyntaxNode value, IEnumerable<Direction> path, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value System.Collections.Generic.IEnumerable < Direction > path System.Func < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , System.Threading.Tasks.ValueTask < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode >> transformer Returns Type Description System.Threading.Tasks.ValueTask < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode > A copy of value with the result of transformer placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter(CSharpSyntaxNode, Func<CSharpSyntaxNode, CSharpSyntaxNode>) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x) . This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static CSharpSyntaxNode RewriteIter(this CSharpSyntaxNode value, Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value System.Func < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode > transformer Returns Type Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. RewriteIter(CSharpSyntaxNode, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>>) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x) . This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<CSharpSyntaxNode> RewriteIter(this CSharpSyntaxNode value, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value System.Func < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , System.Threading.Tasks.ValueTask < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode >> transformer Returns Type Description System.Threading.Tasks.ValueTask < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode > The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . SelfAndDescendants(CSharpSyntaxNode) Yields all of the nodes in the tree represented by value , starting at the top. This is a depth-first pre-order traversal. See DescendantsAndSelf<T>(IRewriter<T>, T) . Declaration public static IEnumerable<CSharpSyntaxNode> SelfAndDescendants(this CSharpSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value Returns Type Description System.Collections.Generic.IEnumerable < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode > An enumerable containing all of the nodes in the tree represented by value , starting at the top. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); SelfAndDescendantsBreadthFirst(CSharpSyntaxNode) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<CSharpSyntaxNode> SelfAndDescendantsBreadthFirst(this CSharpSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value Returns Type Description System.Collections.Generic.IEnumerable < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode > An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. SelfAndDescendantsInContext(CSharpSyntaxNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(CSharpSyntaxNode, Func<CSharpSyntaxNode, CSharpSyntaxNode>)> SelfAndDescendantsInContext(this CSharpSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , System.Func < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode >>> An enumerable of contexts. SelfAndDescendantsInContextBreadthFirst(CSharpSyntaxNode) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(CSharpSyntaxNode, Func<CSharpSyntaxNode, CSharpSyntaxNode>)> SelfAndDescendantsInContextBreadthFirst(this CSharpSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , System.Func < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode >>> An enumerable of contexts. SetChildren(CSharpSyntaxNode, ReadOnlySpan<CSharpSyntaxNode>) Set the immediate children of the value. Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>, T) . See SetChildren(ReadOnlySpan<T>) . Declaration public static CSharpSyntaxNode SetChildren(this CSharpSyntaxNode value, ReadOnlySpan<CSharpSyntaxNode> newChildren) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value System.ReadOnlySpan < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode > newChildren Returns Type Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode A copy of value with updated children. Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>, T) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, rewriter.SetChildren(Children.Two(new Lit(4), new Lit(5)), expr)); ZipFold<U>(CSharpSyntaxNode, CSharpSyntaxNode, Func<CSharpSyntaxNode, CSharpSyntaxNode, IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this CSharpSyntaxNode value1, CSharpSyntaxNode value2, Func<CSharpSyntaxNode, CSharpSyntaxNode, IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value1 Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value2 System.Func < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , System.Collections.Generic.IAsyncEnumerable <U>, System.Threading.Tasks.ValueTask <U>> func Returns Type Description System.Threading.Tasks.ValueTask <U> The result of aggregating the two trees. Type Parameters Name Description U Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask and System.Collections.Generic.IAsyncEnumerable`1 . Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(CSharpSyntaxNode, CSharpSyntaxNode, Func<CSharpSyntaxNode, CSharpSyntaxNode, IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this CSharpSyntaxNode value1, CSharpSyntaxNode value2, Func<CSharpSyntaxNode, CSharpSyntaxNode, IEnumerable<U>, U> func) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value1 Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode value2 System.Func < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode , System.Collections.Generic.IEnumerable <U>, U> func Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(CSharpSyntaxNode[], Func<CSharpSyntaxNode[], IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this CSharpSyntaxNode[] values, Func<CSharpSyntaxNode[], IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode [] values System.Func < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode [], System.Collections.Generic.IAsyncEnumerable <U>, System.Threading.Tasks.ValueTask <U>> func Returns Type Description System.Threading.Tasks.ValueTask <U> The result of aggregating the two trees. Type Parameters Name Description U Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask and System.Collections.Generic.IAsyncEnumerable`1 . Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(CSharpSyntaxNode[], Func<CSharpSyntaxNode[], IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this CSharpSyntaxNode[] values, Func<CSharpSyntaxNode[], IEnumerable<U>, U> func) Parameters Type Name Description Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode [] values System.Func < Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode [], System.Collections.Generic.IEnumerable <U>, U> func Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.Microsoft.CodeAnalysis.CSharp.html": {
    "href": "Sawmill.Microsoft.CodeAnalysis.CSharp.html",
    "title": "Namespace Sawmill.Microsoft.CodeAnalysis.CSharp | Sawmill",
    "keywords": "Namespace Sawmill.Microsoft.CodeAnalysis.CSharp Classes CSharpSyntaxNodeExtensions Extension methods for Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode s."
  },
  "Sawmill.Microsoft.CodeAnalysis.html": {
    "href": "Sawmill.Microsoft.CodeAnalysis.html",
    "title": "Namespace Sawmill.Microsoft.CodeAnalysis | Sawmill",
    "keywords": "Namespace Sawmill.Microsoft.CodeAnalysis Classes SyntaxNodeRewriter<T> An implementation of IRewriter<T> for subclasses of Microsoft.CodeAnalysis.SyntaxNode ."
  },
  "Sawmill.Microsoft.CodeAnalysis.SyntaxNodeRewriter-1.html": {
    "href": "Sawmill.Microsoft.CodeAnalysis.SyntaxNodeRewriter-1.html",
    "title": "Class SyntaxNodeRewriter<T> | Sawmill",
    "keywords": "Class SyntaxNodeRewriter<T> An implementation of IRewriter<T> for subclasses of Microsoft.CodeAnalysis.SyntaxNode . Inheritance System.Object SyntaxNodeRewriter<T> Implements IRewriter <T> Declaration public class SyntaxNodeRewriter<T> : Object, IRewriter<T> where T : SyntaxNode Type Parameters Name Description T The type of syntax node. Constructors SyntaxNodeRewriter() create a new instance of SyntaxNodeRewriter<T> . Declaration protected SyntaxNodeRewriter() Properties Instance Gets the single global instance of SyntaxNodeRewriter<T> . Declaration public static SyntaxNodeRewriter<T> Instance { get; } Property Value Type Description SyntaxNodeRewriter <T> The single global instance of SyntaxNodeRewriter<T> . Methods CountChildren(T) See CountChildren(T) . Declaration public int CountChildren(T value) Parameters Type Name Description T value The value. Returns Type Description System.Int32 value 's number of immediate children. GetChildren(Span<T>, T) See GetChildren(Span<T>, T) . Declaration public void GetChildren(Span<T> childrenReceiver, T value) Parameters Type Name Description System.Span <T> childrenReceiver A System.Span<> to copy value 's immediate children into. The System.Span<> 's System.Span`1.Length will be equal to the number returned by CountChildren(T) . T value The value. SetChildren(ReadOnlySpan<T>, T) See SetChildren(ReadOnlySpan<T>, T) . Declaration public T SetChildren(ReadOnlySpan<T> newChildren, T value) Parameters Type Name Description System.ReadOnlySpan <T> newChildren The new children. T value The old value, whose immediate children should be replaced. Returns Type Description T A copy of value with updated children. Implements IRewriter<T>"
  },
  "Sawmill.Microsoft.CodeAnalysis.VisualBasic.html": {
    "href": "Sawmill.Microsoft.CodeAnalysis.VisualBasic.html",
    "title": "Namespace Sawmill.Microsoft.CodeAnalysis.VisualBasic | Sawmill",
    "keywords": "Namespace Sawmill.Microsoft.CodeAnalysis.VisualBasic Classes VisualBasicSyntaxNodeExtensions Extension methods for Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode s."
  },
  "Sawmill.Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNodeExtensions.html": {
    "href": "Sawmill.Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNodeExtensions.html",
    "title": "Class VisualBasicSyntaxNodeExtensions | Sawmill",
    "keywords": "Class VisualBasicSyntaxNodeExtensions Extension methods for Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode s. Inheritance System.Object VisualBasicSyntaxNodeExtensions Declaration public static class VisualBasicSyntaxNodeExtensions : Object Methods ChildrenInContext(VisualBasicSyntaxNode) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See SelfAndDescendantsInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static (VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode>)[] ChildrenInContext(this VisualBasicSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value Returns Type Description System.ValueTuple < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , System.Func < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode >>[] An enumerable of contexts. CountChildren(VisualBasicSyntaxNode) Count the immediate children of the value. See CountChildren() . Declaration public static int CountChildren(this VisualBasicSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value Returns Type Description System.Int32 value 's number of immediate children. Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren(T) counts the immediate children of the topmost (Add) node. Assert.Equal(2, rewriter.CountChildren(expr)); Cursor(VisualBasicSyntaxNode) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value . Declaration public static Cursor<VisualBasicSyntaxNode> Cursor(this VisualBasicSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value Returns Type Description Cursor < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode > A Cursor<T>(IRewriter<T>, T) focused on the root node of value . DescendantAt(VisualBasicSyntaxNode, IEnumerable<Direction>) Returns the descendant at a particular location in value . Declaration public static VisualBasicSyntaxNode DescendantAt(this VisualBasicSyntaxNode value, IEnumerable<Direction> path) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value System.Collections.Generic.IEnumerable < Direction > path Returns Type Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode The descendant found by following the directions in path . Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelf(VisualBasicSyntaxNode) Yields all of the nodes in the tree represented by value , starting at the bottom. This is a depth-first post-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . Declaration public static IEnumerable<VisualBasicSyntaxNode> DescendantsAndSelf(this VisualBasicSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value Returns Type Description System.Collections.Generic.IEnumerable < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode > An enumerable containing all of the nodes in the tree represented by value , starting at the bottom. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); DescendantsAndSelfInContext(VisualBasicSyntaxNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See DescendantsAndSelf<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See SelfAndDescendantsInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode>)> DescendantsAndSelfInContext(this VisualBasicSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , System.Func < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode >>> An enumerable of contexts. Fold<T>(VisualBasicSyntaxNode, SpanFunc<T, VisualBasicSyntaxNode, T>) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static T Fold<T>(this VisualBasicSyntaxNode value, SpanFunc<T, VisualBasicSyntaxNode, T> func) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value SpanFunc <T, Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , T> func Returns Type Description T The result of aggregating the tree represented by value . Type Parameters Name Description T Fold<T>(VisualBasicSyntaxNode, Func<Memory<T>, VisualBasicSyntaxNode, ValueTask<T>>) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<T> Fold<T>(this VisualBasicSyntaxNode value, Func<Memory<T>, VisualBasicSyntaxNode, ValueTask<T>> func) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value System.Func < System.Memory <T>, Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , System.Threading.Tasks.ValueTask <T>> func Returns Type Description System.Threading.Tasks.ValueTask <T> The result of aggregating the tree represented by value . Type Parameters Name Description T Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . GetChildren(VisualBasicSyntaxNode) Get the immediate children of the value. See GetChildren(Span<T>) . Declaration public static VisualBasicSyntaxNode[] GetChildren(this VisualBasicSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value Returns Type Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode [] The immediate children of value . Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); GetChildren(VisualBasicSyntaxNode, Span<VisualBasicSyntaxNode>) Copy the immediate children of the value into childrenReceiver . See GetChildren(Span<T>) . Declaration public static void GetChildren(this VisualBasicSyntaxNode value, Span<VisualBasicSyntaxNode> childrenReceiver) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value System.Span < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode > childrenReceiver Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>, T) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[rewriter.CountChildren(expr)]; rewriter.GetChildren(array, expr); Assert.Equal(expected, array); ReplaceDescendantAt<T>(VisualBasicSyntaxNode, IEnumerable<Direction>, VisualBasicSyntaxNode) Replaces the descendant at a particular location in value . Declaration public static VisualBasicSyntaxNode ReplaceDescendantAt<T>(this VisualBasicSyntaxNode value, IEnumerable<Direction> path, VisualBasicSyntaxNode newDescendant) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value System.Collections.Generic.IEnumerable < Direction > path Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode newDescendant Returns Type Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode A copy of value with newDescendant placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. Rewrite(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode>) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static VisualBasicSyntaxNode Rewrite(this VisualBasicSyntaxNode value, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value System.Func < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode > transformer Returns Type Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode The result of applying transformer to every node in the tree represented by value . Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer , then replaces their parents with the result of calling transformer , and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); Rewrite(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>>) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<VisualBasicSyntaxNode> Rewrite(this VisualBasicSyntaxNode value, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value System.Func < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , System.Threading.Tasks.ValueTask < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode >> transformer Returns Type Description System.Threading.Tasks.ValueTask < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode > The result of applying transformer to every node in the tree represented by value . Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer , then replaces their parents with the result of calling transformer , and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); RewriteChildren(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode>) Update the immediate children of the value by applying a transformation function to each one. Declaration public static VisualBasicSyntaxNode RewriteChildren(this VisualBasicSyntaxNode value, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value System.Func < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode > transformer Returns Type Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode A copy of value with updated children. RewriteChildren(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>>) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<VisualBasicSyntaxNode> RewriteChildren(this VisualBasicSyntaxNode value, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value System.Func < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , System.Threading.Tasks.ValueTask < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode >> transformer Returns Type Description System.Threading.Tasks.ValueTask < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode > A copy of value with updated children. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . RewriteDescendantAt<T>(VisualBasicSyntaxNode, IEnumerable<Direction>, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode>) Apply a function at a particular location in value . Declaration public static VisualBasicSyntaxNode RewriteDescendantAt<T>(this VisualBasicSyntaxNode value, IEnumerable<Direction> path, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value System.Collections.Generic.IEnumerable < Direction > path System.Func < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode > transformer Returns Type Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode A copy of value with the result of transformer placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(VisualBasicSyntaxNode, IEnumerable<Direction>, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>>) Apply an asynchronous function at a particular location in value . Declaration public static ValueTask<VisualBasicSyntaxNode> RewriteDescendantAt<T>(this VisualBasicSyntaxNode value, IEnumerable<Direction> path, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value System.Collections.Generic.IEnumerable < Direction > path System.Func < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , System.Threading.Tasks.ValueTask < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode >> transformer Returns Type Description System.Threading.Tasks.ValueTask < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode > A copy of value with the result of transformer placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode>) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x) . This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static VisualBasicSyntaxNode RewriteIter(this VisualBasicSyntaxNode value, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value System.Func < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode > transformer Returns Type Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. RewriteIter(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>>) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x) . This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<VisualBasicSyntaxNode> RewriteIter(this VisualBasicSyntaxNode value, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value System.Func < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , System.Threading.Tasks.ValueTask < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode >> transformer Returns Type Description System.Threading.Tasks.ValueTask < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode > The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . SelfAndDescendants(VisualBasicSyntaxNode) Yields all of the nodes in the tree represented by value , starting at the top. This is a depth-first pre-order traversal. See DescendantsAndSelf<T>(IRewriter<T>, T) . Declaration public static IEnumerable<VisualBasicSyntaxNode> SelfAndDescendants(this VisualBasicSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value Returns Type Description System.Collections.Generic.IEnumerable < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode > An enumerable containing all of the nodes in the tree represented by value , starting at the top. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); SelfAndDescendantsBreadthFirst(VisualBasicSyntaxNode) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<VisualBasicSyntaxNode> SelfAndDescendantsBreadthFirst(this VisualBasicSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value Returns Type Description System.Collections.Generic.IEnumerable < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode > An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. SelfAndDescendantsInContext(VisualBasicSyntaxNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode>)> SelfAndDescendantsInContext(this VisualBasicSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , System.Func < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode >>> An enumerable of contexts. SelfAndDescendantsInContextBreadthFirst(VisualBasicSyntaxNode) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode>)> SelfAndDescendantsInContextBreadthFirst(this VisualBasicSyntaxNode value) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , System.Func < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode >>> An enumerable of contexts. SetChildren(VisualBasicSyntaxNode, ReadOnlySpan<VisualBasicSyntaxNode>) Set the immediate children of the value. Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>, T) . See SetChildren(ReadOnlySpan<T>) . Declaration public static VisualBasicSyntaxNode SetChildren(this VisualBasicSyntaxNode value, ReadOnlySpan<VisualBasicSyntaxNode> newChildren) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value System.ReadOnlySpan < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode > newChildren Returns Type Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode A copy of value with updated children. Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>, T) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, rewriter.SetChildren(Children.Two(new Lit(4), new Lit(5)), expr)); ZipFold<U>(VisualBasicSyntaxNode, VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode, IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this VisualBasicSyntaxNode value1, VisualBasicSyntaxNode value2, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode, IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value1 Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value2 System.Func < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , System.Collections.Generic.IAsyncEnumerable <U>, System.Threading.Tasks.ValueTask <U>> func Returns Type Description System.Threading.Tasks.ValueTask <U> The result of aggregating the two trees. Type Parameters Name Description U Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask and System.Collections.Generic.IAsyncEnumerable`1 . Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(VisualBasicSyntaxNode, VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode, IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this VisualBasicSyntaxNode value1, VisualBasicSyntaxNode value2, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode, IEnumerable<U>, U> func) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value1 Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode value2 System.Func < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode , System.Collections.Generic.IEnumerable <U>, U> func Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(VisualBasicSyntaxNode[], Func<VisualBasicSyntaxNode[], IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this VisualBasicSyntaxNode[] values, Func<VisualBasicSyntaxNode[], IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode [] values System.Func < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode [], System.Collections.Generic.IAsyncEnumerable <U>, System.Threading.Tasks.ValueTask <U>> func Returns Type Description System.Threading.Tasks.ValueTask <U> The result of aggregating the two trees. Type Parameters Name Description U Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask and System.Collections.Generic.IAsyncEnumerable`1 . Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(VisualBasicSyntaxNode[], Func<VisualBasicSyntaxNode[], IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this VisualBasicSyntaxNode[] values, Func<VisualBasicSyntaxNode[], IEnumerable<U>, U> func) Parameters Type Name Description Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode [] values System.Func < Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode [], System.Collections.Generic.IEnumerable <U>, U> func Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.Rewritable.html": {
    "href": "Sawmill.Rewritable.html",
    "title": "Class Rewritable | Sawmill",
    "keywords": "Class Rewritable Extension methods for IRewritable<T> implementations. Inheritance System.Object Rewritable Declaration public static class Rewritable : Object Methods ChildrenInContext<T>(T) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See SelfAndDescendantsInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static (T, Func<T, T>)[] ChildrenInContext<T>(this T value) where T : IRewritable<T> Parameters Type Name Description T value Returns Type Description System.ValueTuple <T, System.Func <T, T>>[] An enumerable of contexts. Type Parameters Name Description T The rewritable tree type. Cursor<T>(T) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value . Declaration public static Cursor<T> Cursor<T>(this T value) where T : IRewritable<T> Parameters Type Name Description T value Returns Type Description Cursor <T> A Cursor<T>(IRewriter<T>, T) focused on the root node of value . Type Parameters Name Description T The rewritable tree type. DescendantAt<T>(T, IEnumerable<Direction>) Returns the descendant at a particular location in value . Declaration public static T DescendantAt<T>(this T value, IEnumerable<Direction> path) where T : IRewritable<T> Parameters Type Name Description T value System.Collections.Generic.IEnumerable < Direction > path Returns Type Description T The descendant found by following the directions in path . Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelf<T>(T) Yields all of the nodes in the tree represented by value , starting at the bottom. This is a depth-first post-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . Declaration public static IEnumerable<T> DescendantsAndSelf<T>(this T value) where T : IRewritable<T> Parameters Type Name Description T value Returns Type Description System.Collections.Generic.IEnumerable <T> An enumerable containing all of the nodes in the tree represented by value , starting at the bottom. Type Parameters Name Description T The rewritable tree type. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); DescendantsAndSelfInContext<T>(T) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See DescendantsAndSelf<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See SelfAndDescendantsInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(T, Func<T, T>)> DescendantsAndSelfInContext<T>(this T value) where T : IRewritable<T> Parameters Type Name Description T value Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple <T, System.Func <T, T>>> An enumerable of contexts. Type Parameters Name Description T The rewritable tree type. Fold<T, U>(T, SpanFunc<U, T, U>) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static U Fold<T, U>(this T value, SpanFunc<U, T, U> func) where T : IRewritable<T> Parameters Type Name Description T value SpanFunc <U, T, U> func Returns Type Description U The result of aggregating the tree represented by value . Type Parameters Name Description T The rewritable tree type. U The type of the result of aggregation. Fold<T, U>(T, Func<Memory<U>, T, ValueTask<U>>) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<U> Fold<T, U>(this T value, Func<Memory<U>, T, ValueTask<U>> func) where T : IRewritable<T> Parameters Type Name Description T value System.Func < System.Memory <U>, T, System.Threading.Tasks.ValueTask <U>> func Returns Type Description System.Threading.Tasks.ValueTask <U> The result of aggregating the tree represented by value . Type Parameters Name Description T The rewritable tree type. U The type of the result of aggregation. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . GetChildren<T>(T) Get the immediate children of the value. See GetChildren(Span<T>) . Declaration public static T[] GetChildren<T>(this T value) where T : IRewritable<T> Parameters Type Name Description T value Returns Type Description T[] The immediate children of value . Type Parameters Name Description T The rewritable tree type. Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); ReplaceDescendantAt<T>(T, IEnumerable<Direction>, T) Replaces the descendant at a particular location in value . Declaration public static T ReplaceDescendantAt<T>(this T value, IEnumerable<Direction> path, T newDescendant) where T : IRewritable<T> Parameters Type Name Description T value System.Collections.Generic.IEnumerable < Direction > path T newDescendant Returns Type Description T A copy of value with newDescendant placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. Rewrite<T>(T, Func<T, T>) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static T Rewrite<T>(this T value, Func<T, T> transformer) where T : IRewritable<T> Parameters Type Name Description T value System.Func <T, T> transformer Returns Type Description T The result of applying transformer to every node in the tree represented by value . Type Parameters Name Description T The rewritable tree type. Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer , then replaces their parents with the result of calling transformer , and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); Rewrite<T>(T, Func<T, ValueTask<T>>) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<T> Rewrite<T>(this T value, Func<T, ValueTask<T>> transformer) where T : IRewritable<T> Parameters Type Name Description T value System.Func <T, System.Threading.Tasks.ValueTask <T>> transformer Returns Type Description System.Threading.Tasks.ValueTask <T> The result of applying transformer to every node in the tree represented by value . Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer , then replaces their parents with the result of calling transformer , and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); RewriteChildren<T>(T, Func<T, T>) Update the immediate children of the value by applying a transformation function to each one. Declaration public static T RewriteChildren<T>(this T value, Func<T, T> transformer) where T : IRewritable<T> Parameters Type Name Description T value System.Func <T, T> transformer Returns Type Description T A copy of value with updated children. Type Parameters Name Description T The rewritable tree type. RewriteChildren<T>(T, Func<T, ValueTask<T>>) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<T> RewriteChildren<T>(this T value, Func<T, ValueTask<T>> transformer) where T : IRewritable<T> Parameters Type Name Description T value System.Func <T, System.Threading.Tasks.ValueTask <T>> transformer Returns Type Description System.Threading.Tasks.ValueTask <T> A copy of value with updated children. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . RewriteDescendantAt<T>(T, IEnumerable<Direction>, Func<T, T>) Apply a function at a particular location in value . Declaration public static T RewriteDescendantAt<T>(this T value, IEnumerable<Direction> path, Func<T, T> transformer) where T : IRewritable<T> Parameters Type Name Description T value System.Collections.Generic.IEnumerable < Direction > path System.Func <T, T> transformer Returns Type Description T A copy of value with the result of transformer placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(T, IEnumerable<Direction>, Func<T, ValueTask<T>>) Apply an asynchronous function at a particular location in value . Declaration public static ValueTask<T> RewriteDescendantAt<T>(this T value, IEnumerable<Direction> path, Func<T, ValueTask<T>> transformer) where T : IRewritable<T> Parameters Type Name Description T value System.Collections.Generic.IEnumerable < Direction > path System.Func <T, System.Threading.Tasks.ValueTask <T>> transformer Returns Type Description System.Threading.Tasks.ValueTask <T> A copy of value with the result of transformer placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter<T>(T, Func<T, T>) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x) . This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static T RewriteIter<T>(this T value, Func<T, T> transformer) where T : class, IRewritable<T> Parameters Type Name Description T value System.Func <T, T> transformer Returns Type Description T The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Type Parameters Name Description T The rewritable tree type. RewriteIter<T>(T, Func<T, ValueTask<T>>) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x) . This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<T> RewriteIter<T>(this T value, Func<T, ValueTask<T>> transformer) where T : class, IRewritable<T> Parameters Type Name Description T value System.Func <T, System.Threading.Tasks.ValueTask <T>> transformer Returns Type Description System.Threading.Tasks.ValueTask <T> The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . SelfAndDescendants<T>(T) Yields all of the nodes in the tree represented by value , starting at the top. This is a depth-first pre-order traversal. See DescendantsAndSelf<T>(IRewriter<T>, T) . Declaration public static IEnumerable<T> SelfAndDescendants<T>(this T value) where T : IRewritable<T> Parameters Type Name Description T value Returns Type Description System.Collections.Generic.IEnumerable <T> An enumerable containing all of the nodes in the tree represented by value , starting at the top. Type Parameters Name Description T The rewritable tree type. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); SelfAndDescendantsBreadthFirst<T>(T) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<T> SelfAndDescendantsBreadthFirst<T>(this T value) where T : IRewritable<T> Parameters Type Name Description T value Returns Type Description System.Collections.Generic.IEnumerable <T> An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. Type Parameters Name Description T The rewritable tree type. SelfAndDescendantsInContext<T>(T) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(T, Func<T, T>)> SelfAndDescendantsInContext<T>(this T value) where T : IRewritable<T> Parameters Type Name Description T value Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple <T, System.Func <T, T>>> An enumerable of contexts. Type Parameters Name Description T The rewritable tree type. SelfAndDescendantsInContextBreadthFirst<T>(T) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(T, Func<T, T>)> SelfAndDescendantsInContextBreadthFirst<T>(this T value) where T : IRewritable<T> Parameters Type Name Description T value Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple <T, System.Func <T, T>>> An enumerable of contexts. Type Parameters Name Description T The rewritable tree type. ZipFold<T, U>(T, T, Func<T, T, IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<T, U>(this T value1, T value2, Func<T, T, IAsyncEnumerable<U>, ValueTask<U>> func) where T : IRewritable<T> Parameters Type Name Description T value1 T value2 System.Func <T, T, System.Collections.Generic.IAsyncEnumerable <U>, System.Threading.Tasks.ValueTask <U>> func Returns Type Description System.Threading.Tasks.ValueTask <U> The result of aggregating the two trees. Type Parameters Name Description T The rewritable tree type. U The return type of the aggregation. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask and System.Collections.Generic.IAsyncEnumerable`1 . Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<T, U>(T, T, Func<T, T, IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<T, U>(this T value1, T value2, Func<T, T, IEnumerable<U>, U> func) where T : IRewritable<T> Parameters Type Name Description T value1 T value2 System.Func <T, T, System.Collections.Generic.IEnumerable <U>, U> func Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description T The rewritable tree type. U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<T, U>(T[], Func<T[], IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<T, U>(this T[] values, Func<T[], IAsyncEnumerable<U>, ValueTask<U>> func) where T : IRewritable<T> Parameters Type Name Description T[] values System.Func <T[], System.Collections.Generic.IAsyncEnumerable <U>, System.Threading.Tasks.ValueTask <U>> func Returns Type Description System.Threading.Tasks.ValueTask <U> The result of aggregating the two trees. Type Parameters Name Description T The rewritable tree type. U The return type of the aggregation. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask and System.Collections.Generic.IAsyncEnumerable`1 . Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<T, U>(T[], Func<T[], IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<T, U>(this T[] values, Func<T[], IEnumerable<U>, U> func) where T : IRewritable<T> Parameters Type Name Description T[] values System.Func <T[], System.Collections.Generic.IEnumerable <U>, U> func Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description T The rewritable tree type. U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.RewritableRewriter-1.html": {
    "href": "Sawmill.RewritableRewriter-1.html",
    "title": "Class RewritableRewriter<T> | Sawmill",
    "keywords": "Class RewritableRewriter<T> An implementation of IRewriter<T> for T s which implement IRewritable<T> . Inheritance System.Object RewritableRewriter<T> Implements IRewriter <T> Declaration public class RewritableRewriter<T> : Object, IRewriter<T> where T : IRewritable<T> Type Parameters Name Description T The rewritable tree type. Constructors RewritableRewriter() Create an instance of RewritableRewriter<T> . Declaration protected RewritableRewriter() Properties Instance Gets the single global instance of RewritableRewriter<T> . Declaration public static RewritableRewriter<T> Instance { get; } Property Value Type Description RewritableRewriter <T> Methods CountChildren(T) See CountChildren(T) . Declaration public int CountChildren(T value) Parameters Type Name Description T value The rewritable tree. Returns Type Description System.Int32 The value 's number of immediate children. GetChildren(Span<T>, T) See GetChildren(Span<T>, T) . Declaration public void GetChildren(Span<T> childrenReceiver, T value) Parameters Type Name Description System.Span <T> childrenReceiver A System.Span<> to copy the current instance's immediate children into. The System.Span<> 's System.Span`1.Length should be equal to the number returned by CountChildren(T) . T value The rewritable tree. SetChildren(ReadOnlySpan<T>, T) See SetChildren(ReadOnlySpan<T>, T) . Declaration public T SetChildren(ReadOnlySpan<T> newChildren, T value) Parameters Type Name Description System.ReadOnlySpan <T> newChildren The new children. T value The rewritable tree. Returns Type Description T A copy of value with updated children. Implements IRewriter<T>"
  },
  "Sawmill.Rewriter.html": {
    "href": "Sawmill.Rewriter.html",
    "title": "Class Rewriter | Sawmill",
    "keywords": "Class Rewriter Extension methods for IRewriter<T> implementations. Inheritance System.Object Rewriter Declaration public static class Rewriter : Object Methods ChildrenInContext<T>(IRewriter<T>, T) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See SelfAndDescendantsInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static (T, Func<T, T>)[] ChildrenInContext<T>(this IRewriter<T> rewriter, T value) Parameters Type Name Description IRewriter <T> rewriter The rewriter. T value The value to get the contexts for the immediate children. Returns Type Description System.ValueTuple <T, System.Func <T, T>>[] An enumerable of contexts. Type Parameters Name Description T The rewritable tree type. Cursor<T>(IRewriter<T>, T) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value . Declaration public static Cursor<T> Cursor<T>(this IRewriter<T> rewriter, T value) Parameters Type Name Description IRewriter <T> rewriter The rewriter. T value The root node on which the newly created Cursor<T>(IRewriter<T>, T) should be focused. Returns Type Description Cursor <T> A Cursor<T>(IRewriter<T>, T) focused on the root node of value . Type Parameters Name Description T The rewritable tree type. DescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, T) Returns the descendant at a particular location in value . Declaration public static T DescendantAt<T>(this IRewriter<T> rewriter, IEnumerable<Direction> path, T value) Parameters Type Name Description IRewriter <T> rewriter The rewriter. System.Collections.Generic.IEnumerable < Direction > path The route to take to find the descendant. T value The rewritable tree. Returns Type Description T The descendant found by following the directions in path . Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelf<T>(IRewriter<T>, T) Yields all of the nodes in the tree represented by value , starting at the bottom. This is a depth-first post-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . Declaration public static IEnumerable<T> DescendantsAndSelf<T>(this IRewriter<T> rewriter, T value) Parameters Type Name Description IRewriter <T> rewriter The rewriter. T value The value to traverse. Returns Type Description System.Collections.Generic.IEnumerable <T> An enumerable containing all of the nodes in the tree represented by value , starting at the bottom. Type Parameters Name Description T The rewritable tree type. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); DescendantsAndSelfInContext<T>(IRewriter<T>, T) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See DescendantsAndSelf<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See SelfAndDescendantsInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(T, Func<T, T>)> DescendantsAndSelfInContext<T>(this IRewriter<T> rewriter, T value) Parameters Type Name Description IRewriter <T> rewriter The rewriter. T value The value to get the contexts for the descendants. Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple <T, System.Func <T, T>>> An enumerable of contexts. Type Parameters Name Description T The rewritable tree type. Fold<T, U>(IRewriter<T>, SpanFunc<U, T, U>, T) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static U Fold<T, U>(this IRewriter<T> rewriter, SpanFunc<U, T, U> func, T value) Parameters Type Name Description IRewriter <T> rewriter The rewriter. SpanFunc <U, T, U> func The aggregation function. T value The value to fold. Returns Type Description U The result of aggregating the tree represented by value . Type Parameters Name Description T The rewritable tree type. U The type of the result of aggregation. Fold<T, U>(IRewriter<T>, Func<Memory<U>, T, ValueTask<U>>, T) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<U> Fold<T, U>(this IRewriter<T> rewriter, Func<Memory<U>, T, ValueTask<U>> func, T value) Parameters Type Name Description IRewriter <T> rewriter The rewriter. System.Func < System.Memory <U>, T, System.Threading.Tasks.ValueTask <U>> func The asynchronous aggregation function. T value The value to fold. Returns Type Description System.Threading.Tasks.ValueTask <U> The result of aggregating the tree represented by value . Type Parameters Name Description T The rewritable tree type. U The type of the result of aggregation. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . GetChildren<T>(IRewriter<T>, T) Get the immediate children of the value. See GetChildren(Span<T>) . Declaration public static T[] GetChildren<T>(this IRewriter<T> rewriter, T value) Parameters Type Name Description IRewriter <T> rewriter The rewriter. T value The value. Returns Type Description T[] The immediate children of value . Type Parameters Name Description T The rewritable tree type. Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); ReplaceDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, T, T) Replaces the descendant at a particular location in value . Declaration public static T ReplaceDescendantAt<T>(this IRewriter<T> rewriter, IEnumerable<Direction> path, T newDescendant, T value) Parameters Type Name Description IRewriter <T> rewriter The rewriter. System.Collections.Generic.IEnumerable < Direction > path The route to take to find the descendant. T newDescendant The replacement descendant. T value The rewritable tree. Returns Type Description T A copy of value with newDescendant placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. Rewrite<T>(IRewriter<T>, Func<T, T>, T) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static T Rewrite<T>(this IRewriter<T> rewriter, Func<T, T> transformer, T value) Parameters Type Name Description IRewriter <T> rewriter The rewriter. System.Func <T, T> transformer The transformation function to apply to every node in the tree. T value The value to rewrite. Returns Type Description T The result of applying transformer to every node in the tree represented by value . Type Parameters Name Description T The rewritable tree type. Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer , then replaces their parents with the result of calling transformer , and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<T> Rewrite<T>(this IRewriter<T> rewriter, Func<T, ValueTask<T>> transformer, T value) Parameters Type Name Description IRewriter <T> rewriter The rewriter. System.Func <T, System.Threading.Tasks.ValueTask <T>> transformer The asynchronous transformation function to apply to every node in the tree. T value The value to rewrite. Returns Type Description System.Threading.Tasks.ValueTask <T> The result of applying transformer to every node in the tree represented by value . Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer , then replaces their parents with the result of calling transformer , and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); RewriteChildren<T>(IRewriter<T>, Func<T, T>, T) Update the immediate children of the value by applying a transformation function to each one. Declaration public static T RewriteChildren<T>(this IRewriter<T> rewriter, Func<T, T> transformer, T value) Parameters Type Name Description IRewriter <T> rewriter The rewriter. System.Func <T, T> transformer A transformation function to apply to each of value 's immediate children. T value The old value, whose immediate children should be transformed by transformer . Returns Type Description T A copy of value with updated children. Type Parameters Name Description T The rewritable tree type. RewriteChildren<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<T> RewriteChildren<T>(this IRewriter<T> rewriter, Func<T, ValueTask<T>> transformer, T value) Parameters Type Name Description IRewriter <T> rewriter The rewriter. System.Func <T, System.Threading.Tasks.ValueTask <T>> transformer An asynchronous transformation function to apply to each of value 's immediate children. T value The old value, whose immediate children should be transformed by transformer . Returns Type Description System.Threading.Tasks.ValueTask <T> A copy of value with updated children. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . RewriteDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, Func<T, T>, T) Apply a function at a particular location in value . Declaration public static T RewriteDescendantAt<T>(this IRewriter<T> rewriter, IEnumerable<Direction> path, Func<T, T> transformer, T value) Parameters Type Name Description IRewriter <T> rewriter The rewriter. System.Collections.Generic.IEnumerable < Direction > path The route to take to find the descendant. System.Func <T, T> transformer A function to calculate a replacement for the descendant. T value The rewritable tree. Returns Type Description T A copy of value with the result of transformer placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, Func<T, ValueTask<T>>, T) Apply an asynchronous function at a particular location in value . Declaration public static ValueTask<T> RewriteDescendantAt<T>(this IRewriter<T> rewriter, IEnumerable<Direction> path, Func<T, ValueTask<T>> transformer, T value) Parameters Type Name Description IRewriter <T> rewriter The rewriter. System.Collections.Generic.IEnumerable < Direction > path The route to take to find the descendant. System.Func <T, System.Threading.Tasks.ValueTask <T>> transformer An asynchronous function to calculate a replacement for the descendant. T value The rewritable tree. Returns Type Description System.Threading.Tasks.ValueTask <T> A copy of value with the result of transformer placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter<T>(IRewriter<T>, Func<T, T>, T) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x) . This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static T RewriteIter<T>(this IRewriter<T> rewriter, Func<T, T> transformer, T value) where T : class Parameters Type Name Description IRewriter <T> rewriter The rewriter. System.Func <T, T> transformer A transformation function to apply to every node in value repeatedly. T value The value to rewrite. Returns Type Description T The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Type Parameters Name Description T The rewritable tree type. RewriteIter<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x) . This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<T> RewriteIter<T>(this IRewriter<T> rewriter, Func<T, ValueTask<T>> transformer, T value) where T : class Parameters Type Name Description IRewriter <T> rewriter The rewriter. System.Func <T, System.Threading.Tasks.ValueTask <T>> transformer An asynchronous transformation function to apply to every node in value repeatedly. T value The value to rewrite. Returns Type Description System.Threading.Tasks.ValueTask <T> The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . SelfAndDescendants<T>(IRewriter<T>, T) Yields all of the nodes in the tree represented by value , starting at the top. This is a depth-first pre-order traversal. See DescendantsAndSelf<T>(IRewriter<T>, T) . Declaration public static IEnumerable<T> SelfAndDescendants<T>(this IRewriter<T> rewriter, T value) Parameters Type Name Description IRewriter <T> rewriter The rewriter. T value The value to traverse. Returns Type Description System.Collections.Generic.IEnumerable <T> An enumerable containing all of the nodes in the tree represented by value , starting at the top. Type Parameters Name Description T The rewritable tree type. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); SelfAndDescendantsBreadthFirst<T>(IRewriter<T>, T) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<T> SelfAndDescendantsBreadthFirst<T>(this IRewriter<T> rewriter, T value) Parameters Type Name Description IRewriter <T> rewriter The rewriter. T value The value to traverse. Returns Type Description System.Collections.Generic.IEnumerable <T> An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. Type Parameters Name Description T The rewritable tree type. SelfAndDescendantsInContext<T>(IRewriter<T>, T) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(T, Func<T, T>)> SelfAndDescendantsInContext<T>(this IRewriter<T> rewriter, T value) Parameters Type Name Description IRewriter <T> rewriter The rewriter. T value The value to get the contexts for the descendants. Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple <T, System.Func <T, T>>> An enumerable of contexts. Type Parameters Name Description T The rewritable tree type. SelfAndDescendantsInContextBreadthFirst<T>(IRewriter<T>, T) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(T, Func<T, T>)> SelfAndDescendantsInContextBreadthFirst<T>(this IRewriter<T> rewriter, T value) Parameters Type Name Description IRewriter <T> rewriter The rewriter. T value The value to get the contexts for the descendants. Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple <T, System.Func <T, T>>> An enumerable of contexts. Type Parameters Name Description T The rewritable tree type. ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, T[]) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<T, U>(this IRewriter<T> rewriter, Func<T[], IAsyncEnumerable<U>, ValueTask<U>> func, params T[] values) Parameters Type Name Description IRewriter <T> rewriter The rewriter. System.Func <T[], System.Collections.Generic.IAsyncEnumerable <U>, System.Threading.Tasks.ValueTask <U>> func The aggregation function. T[] values The trees to fold. Returns Type Description System.Threading.Tasks.ValueTask <U> The result of aggregating the two trees. Type Parameters Name Description T The rewritable tree type. U The return type of the aggregation. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask and System.Collections.Generic.IAsyncEnumerable`1 . Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, T[]) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<T, U>(this IRewriter<T> rewriter, Func<T[], IEnumerable<U>, U> func, params T[] values) Parameters Type Name Description IRewriter <T> rewriter The rewriter. System.Func <T[], System.Collections.Generic.IEnumerable <U>, U> func The aggregation function. T[] values The trees to fold. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description T The rewritable tree type. U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.RewriterBuilder.html": {
    "href": "Sawmill.RewriterBuilder.html",
    "title": "Class RewriterBuilder | Sawmill",
    "keywords": "Class RewriterBuilder Tools for building rewriters. Inheritance System.Object RewriterBuilder Declaration public static class RewriterBuilder : Object Methods For<T>() Create a new RewriterBuilder<T> . Declaration public static RewriterBuilder<T> For<T>() Returns Type Description RewriterBuilder <T> A RewriterBuilder<T> . Type Parameters Name Description T The rewritable tree type."
  },
  "Sawmill.RewriterBuilder-1.html": {
    "href": "Sawmill.RewriterBuilder-1.html",
    "title": "Class RewriterBuilder<T> | Sawmill",
    "keywords": "Class RewriterBuilder<T> Tools for building rewriters. Inheritance System.Object RewriterBuilder<T> Declaration public class RewriterBuilder<T> : Object Type Parameters Name Description T The rewritable tree type. Methods Build() Build a rewriter. Declaration public IRewriter<T> Build() Returns Type Description IRewriter <T> A rewriter. Case<TSub>(Func<RewriterBuilderCase<Object, T, TSub>, IRewriter<T>>) Handle a single subclass of T . Declaration public RewriterBuilder<T> Case<TSub>(Func<RewriterBuilderCase<object, T, TSub>, IRewriter<T>> builderAction) where TSub : T Parameters Type Name Description System.Func < RewriterBuilderCase < System.Object , T, TSub>, IRewriter <T>> builderAction The action defining the builder for this subclass. Returns Type Description RewriterBuilder <T> A RewriterBuilder<T> . Type Parameters Name Description TSub The concrete subclass type."
  },
  "Sawmill.RewriterBuilderCase.html": {
    "href": "Sawmill.RewriterBuilderCase.html",
    "title": "Class RewriterBuilderCase | Sawmill",
    "keywords": "Class RewriterBuilderCase Tools for building rewriters for a single subclass of a base type. Inheritance System.Object RewriterBuilderCase Declaration public static class RewriterBuilderCase : Object Methods ConstructWith<U1, U2, U3, U4, U5, U6, U7, U8, TBase, TSub>(RewriterBuilderCase<((((((((Object, U1), U2), U3), U4), U5), U6), U7), U8), TBase, TSub>, Func<U1, U2, U3, U4, U5, U6, U7, U8, TSub>) Rebuild the subtype with the supplied function, after flattening the tuple. Declaration public static IRewriter<TBase> ConstructWith<U1, U2, U3, U4, U5, U6, U7, U8, TBase, TSub>(this RewriterBuilderCase<((((((((object, U1), U2), U3), U4), U5), U6), U7), U8), TBase, TSub> builder, Func<U1, U2, U3, U4, U5, U6, U7, U8, TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.Object , U1>, U2>, U3>, U4>, U5>, U6>, U7>, U8>, TBase, TSub> builder The builder. System.Func <U1, U2, U3, U4, U5, U6, U7, U8, TSub> constructor The constructor function. Returns Type Description IRewriter <TBase> A rewriter. Type Parameters Name Description U1 Constructor argument 1. U2 Constructor argument 2. U3 Constructor argument 3. U4 Constructor argument 4. U5 Constructor argument 5. U6 Constructor argument 6. U7 Constructor argument 7. U8 Constructor argument 8. TBase The rewritable tree type. TSub The subtype. ConstructWith<TBase, TSub>(RewriterBuilderCase<Object, TBase, TSub>, Func<TSub>) Rebuild the subtype with the supplied function. Declaration public static IRewriter<TBase> ConstructWith<TBase, TSub>(this RewriterBuilderCase<object, TBase, TSub> builder, Func<TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase < System.Object , TBase, TSub> builder The builder. System.Func <TSub> constructor The constructor function. Returns Type Description IRewriter <TBase> A rewriter. Type Parameters Name Description TBase The rewritable tree type. TSub The subtype. ConstructWith<T, TBase, TSub>(RewriterBuilderCase<T, TBase, TSub>, Func<T, TSub>) Rebuild the subtype with the supplied function. Declaration public static IRewriter<TBase> ConstructWith<T, TBase, TSub>(this RewriterBuilderCase<T, TBase, TSub> builder, Func<T, TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase <T, TBase, TSub> builder The builder. System.Func <T, TSub> constructor The constructor function. Returns Type Description IRewriter <TBase> A rewriter. Type Parameters Name Description T The arguments of the builder. TBase The rewritable tree type. TSub The subtype. ConstructWith<U1, TBase, TSub>(RewriterBuilderCase<(Object, U1), TBase, TSub>, Func<U1, TSub>) Rebuild the subtype with the supplied function, after flattening the tuple. Declaration public static IRewriter<TBase> ConstructWith<U1, TBase, TSub>(this RewriterBuilderCase<(object, U1), TBase, TSub> builder, Func<U1, TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase < System.ValueTuple < System.Object , U1>, TBase, TSub> builder The builder. System.Func <U1, TSub> constructor The constructor function. Returns Type Description IRewriter <TBase> A rewriter. Type Parameters Name Description U1 Constructor argument 1. TBase The rewritable tree type. TSub The subtype. ConstructWith<U1, U2, TBase, TSub>(RewriterBuilderCase<((Object, U1), U2), TBase, TSub>, Func<U1, U2, TSub>) Rebuild the subtype with the supplied function, after flattening the tuple. Declaration public static IRewriter<TBase> ConstructWith<U1, U2, TBase, TSub>(this RewriterBuilderCase<((object, U1), U2), TBase, TSub> builder, Func<U1, U2, TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase < System.ValueTuple < System.ValueTuple < System.Object , U1>, U2>, TBase, TSub> builder The builder. System.Func <U1, U2, TSub> constructor The constructor function. Returns Type Description IRewriter <TBase> A rewriter. Type Parameters Name Description U1 Constructor argument 1. U2 Constructor argument 2. TBase The rewritable tree type. TSub The subtype. ConstructWith<U1, U2, U3, TBase, TSub>(RewriterBuilderCase<(((Object, U1), U2), U3), TBase, TSub>, Func<U1, U2, U3, TSub>) Rebuild the subtype with the supplied function, after flattening the tuple. Declaration public static IRewriter<TBase> ConstructWith<U1, U2, U3, TBase, TSub>(this RewriterBuilderCase<(((object, U1), U2), U3), TBase, TSub> builder, Func<U1, U2, U3, TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.Object , U1>, U2>, U3>, TBase, TSub> builder The builder. System.Func <U1, U2, U3, TSub> constructor The constructor function. Returns Type Description IRewriter <TBase> A rewriter. Type Parameters Name Description U1 Constructor argument 1. U2 Constructor argument 2. U3 Constructor argument 3. TBase The rewritable tree type. TSub The subtype. ConstructWith<U1, U2, U3, U4, TBase, TSub>(RewriterBuilderCase<((((Object, U1), U2), U3), U4), TBase, TSub>, Func<U1, U2, U3, U4, TSub>) Rebuild the subtype with the supplied function, after flattening the tuple. Declaration public static IRewriter<TBase> ConstructWith<U1, U2, U3, U4, TBase, TSub>(this RewriterBuilderCase<((((object, U1), U2), U3), U4), TBase, TSub> builder, Func<U1, U2, U3, U4, TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.Object , U1>, U2>, U3>, U4>, TBase, TSub> builder The builder. System.Func <U1, U2, U3, U4, TSub> constructor The constructor function. Returns Type Description IRewriter <TBase> A rewriter. Type Parameters Name Description U1 Constructor argument 1. U2 Constructor argument 2. U3 Constructor argument 3. U4 Constructor argument 4. TBase The rewritable tree type. TSub The subtype. ConstructWith<U1, U2, U3, U4, U5, TBase, TSub>(RewriterBuilderCase<(((((Object, U1), U2), U3), U4), U5), TBase, TSub>, Func<U1, U2, U3, U4, U5, TSub>) Rebuild the subtype with the supplied function, after flattening the tuple. Declaration public static IRewriter<TBase> ConstructWith<U1, U2, U3, U4, U5, TBase, TSub>(this RewriterBuilderCase<(((((object, U1), U2), U3), U4), U5), TBase, TSub> builder, Func<U1, U2, U3, U4, U5, TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.Object , U1>, U2>, U3>, U4>, U5>, TBase, TSub> builder The builder. System.Func <U1, U2, U3, U4, U5, TSub> constructor The constructor function. Returns Type Description IRewriter <TBase> A rewriter. Type Parameters Name Description U1 Constructor argument 1. U2 Constructor argument 2. U3 Constructor argument 3. U4 Constructor argument 4. U5 Constructor argument 5. TBase The rewritable tree type. TSub The subtype. ConstructWith<U1, U2, U3, U4, U5, U6, TBase, TSub>(RewriterBuilderCase<((((((Object, U1), U2), U3), U4), U5), U6), TBase, TSub>, Func<U1, U2, U3, U4, U5, U6, TSub>) Rebuild the subtype with the supplied function, after flattening the tuple. Declaration public static IRewriter<TBase> ConstructWith<U1, U2, U3, U4, U5, U6, TBase, TSub>(this RewriterBuilderCase<((((((object, U1), U2), U3), U4), U5), U6), TBase, TSub> builder, Func<U1, U2, U3, U4, U5, U6, TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.Object , U1>, U2>, U3>, U4>, U5>, U6>, TBase, TSub> builder The builder. System.Func <U1, U2, U3, U4, U5, U6, TSub> constructor The constructor function. Returns Type Description IRewriter <TBase> A rewriter. Type Parameters Name Description U1 Constructor argument 1. U2 Constructor argument 2. U3 Constructor argument 3. U4 Constructor argument 4. U5 Constructor argument 5. U6 Constructor argument 6. TBase The rewritable tree type. TSub The subtype. ConstructWith<U1, U2, U3, U4, U5, U6, U7, TBase, TSub>(RewriterBuilderCase<(((((((Object, U1), U2), U3), U4), U5), U6), U7), TBase, TSub>, Func<U1, U2, U3, U4, U5, U6, U7, TSub>) Rebuild the subtype with the supplied function, after flattening the tuple. Declaration public static IRewriter<TBase> ConstructWith<U1, U2, U3, U4, U5, U6, U7, TBase, TSub>(this RewriterBuilderCase<(((((((object, U1), U2), U3), U4), U5), U6), U7), TBase, TSub> builder, Func<U1, U2, U3, U4, U5, U6, U7, TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.ValueTuple < System.Object , U1>, U2>, U3>, U4>, U5>, U6>, U7>, TBase, TSub> builder The builder. System.Func <U1, U2, U3, U4, U5, U6, U7, TSub> constructor The constructor function. Returns Type Description IRewriter <TBase> A rewriter. Type Parameters Name Description U1 Constructor argument 1. U2 Constructor argument 2. U3 Constructor argument 3. U4 Constructor argument 4. U5 Constructor argument 5. U6 Constructor argument 6. U7 Constructor argument 7. TBase The rewritable tree type. TSub The subtype."
  },
  "Sawmill.RewriterBuilderCase-3.html": {
    "href": "Sawmill.RewriterBuilderCase-3.html",
    "title": "Class RewriterBuilderCase<TArgs, TBase, TSub> | Sawmill",
    "keywords": "Class RewriterBuilderCase<TArgs, TBase, TSub> Tools for building rewriters for a single subclass of a base type. Inheritance System.Object RewriterBuilderCase<TArgs, TBase, TSub> Declaration public sealed class RewriterBuilderCase<TArgs, TBase, TSub> : Object Type Parameters Name Description TArgs The constructor arguments. TBase The rewritable tree type. TSub The sublcass which this case handles. Methods Child(Func<TSub, TBase>) Select an immediate child. Declaration public RewriterBuilderCase<(TArgs, TBase), TBase, TSub> Child(Func<TSub, TBase> child) Parameters Type Name Description System.Func <TSub, TBase> child The child selector. Returns Type Description RewriterBuilderCase < System.ValueTuple <TArgs, TBase>, TBase, TSub> A copy of this RewriterBuilderCase with an additional constructor argument. Children(Func<TSub, ImmutableList<TBase>>) Select a list of children. Declaration public RewriterBuilderCase<(TArgs, ImmutableList<TBase>), TBase, TSub> Children(Func<TSub, ImmutableList<TBase>> children) Parameters Type Name Description System.Func <TSub, System.Collections.Immutable.ImmutableList <TBase>> children The children selector. Returns Type Description RewriterBuilderCase < System.ValueTuple <TArgs, System.Collections.Immutable.ImmutableList <TBase>>, TBase, TSub> A copy of this RewriterBuilderCase with an additional constructor argument. Field<U>(Func<TSub, U>) Select a field from the subclass. Declaration public RewriterBuilderCase<(TArgs, U), TBase, TSub> Field<U>(Func<TSub, U> field) Parameters Type Name Description System.Func <TSub, U> field The field selector. Returns Type Description RewriterBuilderCase < System.ValueTuple <TArgs, U>, TBase, TSub> A copy of this RewriterBuilderCase with an additional constructor argument. Type Parameters Name Description U The field type."
  },
  "Sawmill.SpanFunc-3.html": {
    "href": "Sawmill.SpanFunc-3.html",
    "title": "Class SpanFunc<T, U, R> | Sawmill",
    "keywords": "Class SpanFunc<T, U, R> A System.Func<, , > whose first argument is a System.Span<> . Inheritance System.Object SpanFunc<T, U, R> Declaration public sealed class SpanFunc<T, in U, out R> : MulticastDelegate Type Parameters Name Description T The type of elements in the span. U The type of the additional argument. R The return type. Constructors SpanFunc(Object, IntPtr) Declaration public SpanFunc(object object, IntPtr method) Parameters Type Name Description System.Object object System.IntPtr method Methods BeginInvoke(Span<T>, U, AsyncCallback, Object) Declaration public virtual IAsyncResult BeginInvoke(Span<T> span, U arg, AsyncCallback callback, object object) Parameters Type Name Description System.Span <T> span U arg System.AsyncCallback callback System.Object object Returns Type Description System.IAsyncResult EndInvoke(IAsyncResult) Declaration public virtual R EndInvoke(IAsyncResult result) Parameters Type Name Description System.IAsyncResult result Returns Type Description R Invoke(Span<T>, U) Declaration public virtual R Invoke(Span<T> span, U arg) Parameters Type Name Description System.Span <T> span U arg Returns Type Description R"
  },
  "Sawmill.Xml.html": {
    "href": "Sawmill.Xml.html",
    "title": "Namespace Sawmill.Xml | Sawmill",
    "keywords": "Namespace Sawmill.Xml Classes XElementExtensions Extension methods for System.Xml.Linq.XElement s. XElementRewriter An implementation of IRewriter<T> for System.Xml.Linq.XElement s. XmlNodeExtensions Extension methods for System.Xml.XmlNode s. XmlNodeRewriter An implementation of IRewriter<T> for System.Xml.XmlNode s."
  },
  "Sawmill.Xml.XElementExtensions.html": {
    "href": "Sawmill.Xml.XElementExtensions.html",
    "title": "Class XElementExtensions | Sawmill",
    "keywords": "Class XElementExtensions Extension methods for System.Xml.Linq.XElement s. Inheritance System.Object XElementExtensions Declaration public static class XElementExtensions : Object Methods ChildrenInContext(XElement) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See SelfAndDescendantsInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static (XElement, Func<XElement, XElement>)[] ChildrenInContext(this XElement value) Parameters Type Name Description System.Xml.Linq.XElement value Returns Type Description System.ValueTuple < System.Xml.Linq.XElement , System.Func < System.Xml.Linq.XElement , System.Xml.Linq.XElement >>[] An enumerable of contexts. CountChildren(XElement) Count the immediate children of the value. See CountChildren() . Declaration public static int CountChildren(this XElement value) Parameters Type Name Description System.Xml.Linq.XElement value Returns Type Description System.Int32 value 's number of immediate children. Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren(T) counts the immediate children of the topmost (Add) node. Assert.Equal(2, rewriter.CountChildren(expr)); Cursor(XElement) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value . Declaration public static Cursor<XElement> Cursor(this XElement value) Parameters Type Name Description System.Xml.Linq.XElement value Returns Type Description Cursor < System.Xml.Linq.XElement > A Cursor<T>(IRewriter<T>, T) focused on the root node of value . DescendantAt(XElement, IEnumerable<Direction>) Returns the descendant at a particular location in value . Declaration public static XElement DescendantAt(this XElement value, IEnumerable<Direction> path) Parameters Type Name Description System.Xml.Linq.XElement value System.Collections.Generic.IEnumerable < Direction > path Returns Type Description System.Xml.Linq.XElement The descendant found by following the directions in path . Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelf(XElement) Yields all of the nodes in the tree represented by value , starting at the bottom. This is a depth-first post-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . Declaration public static IEnumerable<XElement> DescendantsAndSelf(this XElement value) Parameters Type Name Description System.Xml.Linq.XElement value Returns Type Description System.Collections.Generic.IEnumerable < System.Xml.Linq.XElement > An enumerable containing all of the nodes in the tree represented by value , starting at the bottom. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); DescendantsAndSelfInContext(XElement) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See DescendantsAndSelf<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See SelfAndDescendantsInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(XElement, Func<XElement, XElement>)> DescendantsAndSelfInContext(this XElement value) Parameters Type Name Description System.Xml.Linq.XElement value Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple < System.Xml.Linq.XElement , System.Func < System.Xml.Linq.XElement , System.Xml.Linq.XElement >>> An enumerable of contexts. Fold<T>(XElement, SpanFunc<T, XElement, T>) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static T Fold<T>(this XElement value, SpanFunc<T, XElement, T> func) Parameters Type Name Description System.Xml.Linq.XElement value SpanFunc <T, System.Xml.Linq.XElement , T> func Returns Type Description T The result of aggregating the tree represented by value . Type Parameters Name Description T Fold<T>(XElement, Func<Memory<T>, XElement, ValueTask<T>>) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<T> Fold<T>(this XElement value, Func<Memory<T>, XElement, ValueTask<T>> func) Parameters Type Name Description System.Xml.Linq.XElement value System.Func < System.Memory <T>, System.Xml.Linq.XElement , System.Threading.Tasks.ValueTask <T>> func Returns Type Description System.Threading.Tasks.ValueTask <T> The result of aggregating the tree represented by value . Type Parameters Name Description T Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . GetChildren(XElement) Get the immediate children of the value. See GetChildren(Span<T>) . Declaration public static XElement[] GetChildren(this XElement value) Parameters Type Name Description System.Xml.Linq.XElement value Returns Type Description System.Xml.Linq.XElement [] The immediate children of value . Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); GetChildren(XElement, Span<XElement>) Copy the immediate children of the value into childrenReceiver . See GetChildren(Span<T>) . Declaration public static void GetChildren(this XElement value, Span<XElement> childrenReceiver) Parameters Type Name Description System.Xml.Linq.XElement value System.Span < System.Xml.Linq.XElement > childrenReceiver Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>, T) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[rewriter.CountChildren(expr)]; rewriter.GetChildren(array, expr); Assert.Equal(expected, array); ReplaceDescendantAt<T>(XElement, IEnumerable<Direction>, XElement) Replaces the descendant at a particular location in value . Declaration public static XElement ReplaceDescendantAt<T>(this XElement value, IEnumerable<Direction> path, XElement newDescendant) Parameters Type Name Description System.Xml.Linq.XElement value System.Collections.Generic.IEnumerable < Direction > path System.Xml.Linq.XElement newDescendant Returns Type Description System.Xml.Linq.XElement A copy of value with newDescendant placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. Rewrite(XElement, Func<XElement, ValueTask<XElement>>) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<XElement> Rewrite(this XElement value, Func<XElement, ValueTask<XElement>> transformer) Parameters Type Name Description System.Xml.Linq.XElement value System.Func < System.Xml.Linq.XElement , System.Threading.Tasks.ValueTask < System.Xml.Linq.XElement >> transformer Returns Type Description System.Threading.Tasks.ValueTask < System.Xml.Linq.XElement > The result of applying transformer to every node in the tree represented by value . Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer , then replaces their parents with the result of calling transformer , and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); Rewrite(XElement, Func<XElement, XElement>) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static XElement Rewrite(this XElement value, Func<XElement, XElement> transformer) Parameters Type Name Description System.Xml.Linq.XElement value System.Func < System.Xml.Linq.XElement , System.Xml.Linq.XElement > transformer Returns Type Description System.Xml.Linq.XElement The result of applying transformer to every node in the tree represented by value . Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer , then replaces their parents with the result of calling transformer , and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); RewriteChildren(XElement, Func<XElement, ValueTask<XElement>>) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<XElement> RewriteChildren(this XElement value, Func<XElement, ValueTask<XElement>> transformer) Parameters Type Name Description System.Xml.Linq.XElement value System.Func < System.Xml.Linq.XElement , System.Threading.Tasks.ValueTask < System.Xml.Linq.XElement >> transformer Returns Type Description System.Threading.Tasks.ValueTask < System.Xml.Linq.XElement > A copy of value with updated children. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . RewriteChildren(XElement, Func<XElement, XElement>) Update the immediate children of the value by applying a transformation function to each one. Declaration public static XElement RewriteChildren(this XElement value, Func<XElement, XElement> transformer) Parameters Type Name Description System.Xml.Linq.XElement value System.Func < System.Xml.Linq.XElement , System.Xml.Linq.XElement > transformer Returns Type Description System.Xml.Linq.XElement A copy of value with updated children. RewriteDescendantAt<T>(XElement, IEnumerable<Direction>, Func<XElement, ValueTask<XElement>>) Apply an asynchronous function at a particular location in value . Declaration public static ValueTask<XElement> RewriteDescendantAt<T>(this XElement value, IEnumerable<Direction> path, Func<XElement, ValueTask<XElement>> transformer) Parameters Type Name Description System.Xml.Linq.XElement value System.Collections.Generic.IEnumerable < Direction > path System.Func < System.Xml.Linq.XElement , System.Threading.Tasks.ValueTask < System.Xml.Linq.XElement >> transformer Returns Type Description System.Threading.Tasks.ValueTask < System.Xml.Linq.XElement > A copy of value with the result of transformer placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(XElement, IEnumerable<Direction>, Func<XElement, XElement>) Apply a function at a particular location in value . Declaration public static XElement RewriteDescendantAt<T>(this XElement value, IEnumerable<Direction> path, Func<XElement, XElement> transformer) Parameters Type Name Description System.Xml.Linq.XElement value System.Collections.Generic.IEnumerable < Direction > path System.Func < System.Xml.Linq.XElement , System.Xml.Linq.XElement > transformer Returns Type Description System.Xml.Linq.XElement A copy of value with the result of transformer placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter(XElement, Func<XElement, ValueTask<XElement>>) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x) . This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<XElement> RewriteIter(this XElement value, Func<XElement, ValueTask<XElement>> transformer) Parameters Type Name Description System.Xml.Linq.XElement value System.Func < System.Xml.Linq.XElement , System.Threading.Tasks.ValueTask < System.Xml.Linq.XElement >> transformer Returns Type Description System.Threading.Tasks.ValueTask < System.Xml.Linq.XElement > The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . RewriteIter(XElement, Func<XElement, XElement>) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x) . This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static XElement RewriteIter(this XElement value, Func<XElement, XElement> transformer) Parameters Type Name Description System.Xml.Linq.XElement value System.Func < System.Xml.Linq.XElement , System.Xml.Linq.XElement > transformer Returns Type Description System.Xml.Linq.XElement The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. SelfAndDescendants(XElement) Yields all of the nodes in the tree represented by value , starting at the top. This is a depth-first pre-order traversal. See DescendantsAndSelf<T>(IRewriter<T>, T) . Declaration public static IEnumerable<XElement> SelfAndDescendants(this XElement value) Parameters Type Name Description System.Xml.Linq.XElement value Returns Type Description System.Collections.Generic.IEnumerable < System.Xml.Linq.XElement > An enumerable containing all of the nodes in the tree represented by value , starting at the top. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); SelfAndDescendantsBreadthFirst(XElement) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<XElement> SelfAndDescendantsBreadthFirst(this XElement value) Parameters Type Name Description System.Xml.Linq.XElement value Returns Type Description System.Collections.Generic.IEnumerable < System.Xml.Linq.XElement > An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. SelfAndDescendantsInContext(XElement) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(XElement, Func<XElement, XElement>)> SelfAndDescendantsInContext(this XElement value) Parameters Type Name Description System.Xml.Linq.XElement value Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple < System.Xml.Linq.XElement , System.Func < System.Xml.Linq.XElement , System.Xml.Linq.XElement >>> An enumerable of contexts. SelfAndDescendantsInContextBreadthFirst(XElement) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(XElement, Func<XElement, XElement>)> SelfAndDescendantsInContextBreadthFirst(this XElement value) Parameters Type Name Description System.Xml.Linq.XElement value Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple < System.Xml.Linq.XElement , System.Func < System.Xml.Linq.XElement , System.Xml.Linq.XElement >>> An enumerable of contexts. SetChildren(XElement, ReadOnlySpan<XElement>) Set the immediate children of the value. Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>, T) . See SetChildren(ReadOnlySpan<T>) . Declaration public static XElement SetChildren(this XElement value, ReadOnlySpan<XElement> newChildren) Parameters Type Name Description System.Xml.Linq.XElement value System.ReadOnlySpan < System.Xml.Linq.XElement > newChildren Returns Type Description System.Xml.Linq.XElement A copy of value with updated children. Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>, T) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, rewriter.SetChildren(Children.Two(new Lit(4), new Lit(5)), expr)); ZipFold<U>(XElement, XElement, Func<XElement, XElement, IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this XElement value1, XElement value2, Func<XElement, XElement, IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description System.Xml.Linq.XElement value1 System.Xml.Linq.XElement value2 System.Func < System.Xml.Linq.XElement , System.Xml.Linq.XElement , System.Collections.Generic.IAsyncEnumerable <U>, System.Threading.Tasks.ValueTask <U>> func Returns Type Description System.Threading.Tasks.ValueTask <U> The result of aggregating the two trees. Type Parameters Name Description U Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask and System.Collections.Generic.IAsyncEnumerable`1 . Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(XElement, XElement, Func<XElement, XElement, IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this XElement value1, XElement value2, Func<XElement, XElement, IEnumerable<U>, U> func) Parameters Type Name Description System.Xml.Linq.XElement value1 System.Xml.Linq.XElement value2 System.Func < System.Xml.Linq.XElement , System.Xml.Linq.XElement , System.Collections.Generic.IEnumerable <U>, U> func Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(XElement[], Func<XElement[], IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this XElement[] values, Func<XElement[], IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description System.Xml.Linq.XElement [] values System.Func < System.Xml.Linq.XElement [], System.Collections.Generic.IAsyncEnumerable <U>, System.Threading.Tasks.ValueTask <U>> func Returns Type Description System.Threading.Tasks.ValueTask <U> The result of aggregating the two trees. Type Parameters Name Description U Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask and System.Collections.Generic.IAsyncEnumerable`1 . Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(XElement[], Func<XElement[], IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this XElement[] values, Func<XElement[], IEnumerable<U>, U> func) Parameters Type Name Description System.Xml.Linq.XElement [] values System.Func < System.Xml.Linq.XElement [], System.Collections.Generic.IEnumerable <U>, U> func Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.Xml.XElementRewriter.html": {
    "href": "Sawmill.Xml.XElementRewriter.html",
    "title": "Class XElementRewriter | Sawmill",
    "keywords": "Class XElementRewriter An implementation of IRewriter<T> for System.Xml.Linq.XElement s. Inheritance System.Object XElementRewriter Implements IRewriter < System.Xml.Linq.XElement > Declaration public class XElementRewriter : Object, IRewriter<XElement> Constructors XElementRewriter() Create a new instance of XElementRewriter . Declaration protected XElementRewriter() Properties Instance Gets the single global instance of XElementRewriter . Declaration public static XElementRewriter Instance { get; } Property Value Type Description XElementRewriter The single global instance of XElementRewriter . Methods CountChildren(XElement) See CountChildren(T) . Declaration public int CountChildren(XElement value) Parameters Type Name Description System.Xml.Linq.XElement value The value. Returns Type Description System.Int32 value 's number of immediate children. GetChildren(Span<XElement>, XElement) See GetChildren(Span<T>, T) . Declaration public void GetChildren(Span<XElement> childrenReceiver, XElement value) Parameters Type Name Description System.Span < System.Xml.Linq.XElement > childrenReceiver A System.Span<> to copy value 's immediate children into. The System.Span<> 's System.Span`1.Length will be equal to the number returned by CountChildren(XElement) . System.Xml.Linq.XElement value The value. SetChildren(ReadOnlySpan<XElement>, XElement) See SetChildren(ReadOnlySpan<T>, T) . Declaration public XElement SetChildren(ReadOnlySpan<XElement> newChildren, XElement value) Parameters Type Name Description System.ReadOnlySpan < System.Xml.Linq.XElement > newChildren The new children. System.Xml.Linq.XElement value The old value, whose immediate children should be replaced. Returns Type Description System.Xml.Linq.XElement A copy of value with updated children. Implements IRewriter<T>"
  },
  "Sawmill.Xml.XmlNodeExtensions.html": {
    "href": "Sawmill.Xml.XmlNodeExtensions.html",
    "title": "Class XmlNodeExtensions | Sawmill",
    "keywords": "Class XmlNodeExtensions Extension methods for System.Xml.XmlNode s. Inheritance System.Object XmlNodeExtensions Declaration public static class XmlNodeExtensions : Object Methods ChildrenInContext(XmlNode) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See SelfAndDescendantsInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static (XmlNode, Func<XmlNode, XmlNode>)[] ChildrenInContext(this XmlNode value) Parameters Type Name Description System.Xml.XmlNode value Returns Type Description System.ValueTuple < System.Xml.XmlNode , System.Func < System.Xml.XmlNode , System.Xml.XmlNode >>[] An enumerable of contexts. CountChildren(XmlNode) Count the immediate children of the value. See CountChildren() . Declaration public static int CountChildren(this XmlNode value) Parameters Type Name Description System.Xml.XmlNode value Returns Type Description System.Int32 value 's number of immediate children. Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren(T) counts the immediate children of the topmost (Add) node. Assert.Equal(2, rewriter.CountChildren(expr)); Cursor(XmlNode) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value . Declaration public static Cursor<XmlNode> Cursor(this XmlNode value) Parameters Type Name Description System.Xml.XmlNode value Returns Type Description Cursor < System.Xml.XmlNode > A Cursor<T>(IRewriter<T>, T) focused on the root node of value . DescendantAt(XmlNode, IEnumerable<Direction>) Returns the descendant at a particular location in value . Declaration public static XmlNode DescendantAt(this XmlNode value, IEnumerable<Direction> path) Parameters Type Name Description System.Xml.XmlNode value System.Collections.Generic.IEnumerable < Direction > path Returns Type Description System.Xml.XmlNode The descendant found by following the directions in path . Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelf(XmlNode) Yields all of the nodes in the tree represented by value , starting at the bottom. This is a depth-first post-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . Declaration public static IEnumerable<XmlNode> DescendantsAndSelf(this XmlNode value) Parameters Type Name Description System.Xml.XmlNode value Returns Type Description System.Collections.Generic.IEnumerable < System.Xml.XmlNode > An enumerable containing all of the nodes in the tree represented by value , starting at the bottom. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); DescendantsAndSelfInContext(XmlNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See DescendantsAndSelf<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See SelfAndDescendantsInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(XmlNode, Func<XmlNode, XmlNode>)> DescendantsAndSelfInContext(this XmlNode value) Parameters Type Name Description System.Xml.XmlNode value Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple < System.Xml.XmlNode , System.Func < System.Xml.XmlNode , System.Xml.XmlNode >>> An enumerable of contexts. Fold<T>(XmlNode, SpanFunc<T, XmlNode, T>) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static T Fold<T>(this XmlNode value, SpanFunc<T, XmlNode, T> func) Parameters Type Name Description System.Xml.XmlNode value SpanFunc <T, System.Xml.XmlNode , T> func Returns Type Description T The result of aggregating the tree represented by value . Type Parameters Name Description T Fold<T>(XmlNode, Func<Memory<T>, XmlNode, ValueTask<T>>) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<T> Fold<T>(this XmlNode value, Func<Memory<T>, XmlNode, ValueTask<T>> func) Parameters Type Name Description System.Xml.XmlNode value System.Func < System.Memory <T>, System.Xml.XmlNode , System.Threading.Tasks.ValueTask <T>> func Returns Type Description System.Threading.Tasks.ValueTask <T> The result of aggregating the tree represented by value . Type Parameters Name Description T Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . GetChildren(XmlNode) Get the immediate children of the value. See GetChildren(Span<T>) . Declaration public static XmlNode[] GetChildren(this XmlNode value) Parameters Type Name Description System.Xml.XmlNode value Returns Type Description System.Xml.XmlNode [] The immediate children of value . Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); GetChildren(XmlNode, Span<XmlNode>) Copy the immediate children of the value into childrenReceiver . See GetChildren(Span<T>) . Declaration public static void GetChildren(this XmlNode value, Span<XmlNode> childrenReceiver) Parameters Type Name Description System.Xml.XmlNode value System.Span < System.Xml.XmlNode > childrenReceiver Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>, T) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[rewriter.CountChildren(expr)]; rewriter.GetChildren(array, expr); Assert.Equal(expected, array); ReplaceDescendantAt<T>(XmlNode, IEnumerable<Direction>, XmlNode) Replaces the descendant at a particular location in value . Declaration public static XmlNode ReplaceDescendantAt<T>(this XmlNode value, IEnumerable<Direction> path, XmlNode newDescendant) Parameters Type Name Description System.Xml.XmlNode value System.Collections.Generic.IEnumerable < Direction > path System.Xml.XmlNode newDescendant Returns Type Description System.Xml.XmlNode A copy of value with newDescendant placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. Rewrite(XmlNode, Func<XmlNode, ValueTask<XmlNode>>) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<XmlNode> Rewrite(this XmlNode value, Func<XmlNode, ValueTask<XmlNode>> transformer) Parameters Type Name Description System.Xml.XmlNode value System.Func < System.Xml.XmlNode , System.Threading.Tasks.ValueTask < System.Xml.XmlNode >> transformer Returns Type Description System.Threading.Tasks.ValueTask < System.Xml.XmlNode > The result of applying transformer to every node in the tree represented by value . Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer , then replaces their parents with the result of calling transformer , and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); Rewrite(XmlNode, Func<XmlNode, XmlNode>) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static XmlNode Rewrite(this XmlNode value, Func<XmlNode, XmlNode> transformer) Parameters Type Name Description System.Xml.XmlNode value System.Func < System.Xml.XmlNode , System.Xml.XmlNode > transformer Returns Type Description System.Xml.XmlNode The result of applying transformer to every node in the tree represented by value . Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer , then replaces their parents with the result of calling transformer , and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); RewriteChildren(XmlNode, Func<XmlNode, ValueTask<XmlNode>>) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<XmlNode> RewriteChildren(this XmlNode value, Func<XmlNode, ValueTask<XmlNode>> transformer) Parameters Type Name Description System.Xml.XmlNode value System.Func < System.Xml.XmlNode , System.Threading.Tasks.ValueTask < System.Xml.XmlNode >> transformer Returns Type Description System.Threading.Tasks.ValueTask < System.Xml.XmlNode > A copy of value with updated children. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . RewriteChildren(XmlNode, Func<XmlNode, XmlNode>) Update the immediate children of the value by applying a transformation function to each one. Declaration public static XmlNode RewriteChildren(this XmlNode value, Func<XmlNode, XmlNode> transformer) Parameters Type Name Description System.Xml.XmlNode value System.Func < System.Xml.XmlNode , System.Xml.XmlNode > transformer Returns Type Description System.Xml.XmlNode A copy of value with updated children. RewriteDescendantAt<T>(XmlNode, IEnumerable<Direction>, Func<XmlNode, ValueTask<XmlNode>>) Apply an asynchronous function at a particular location in value . Declaration public static ValueTask<XmlNode> RewriteDescendantAt<T>(this XmlNode value, IEnumerable<Direction> path, Func<XmlNode, ValueTask<XmlNode>> transformer) Parameters Type Name Description System.Xml.XmlNode value System.Collections.Generic.IEnumerable < Direction > path System.Func < System.Xml.XmlNode , System.Threading.Tasks.ValueTask < System.Xml.XmlNode >> transformer Returns Type Description System.Threading.Tasks.ValueTask < System.Xml.XmlNode > A copy of value with the result of transformer placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(XmlNode, IEnumerable<Direction>, Func<XmlNode, XmlNode>) Apply a function at a particular location in value . Declaration public static XmlNode RewriteDescendantAt<T>(this XmlNode value, IEnumerable<Direction> path, Func<XmlNode, XmlNode> transformer) Parameters Type Name Description System.Xml.XmlNode value System.Collections.Generic.IEnumerable < Direction > path System.Func < System.Xml.XmlNode , System.Xml.XmlNode > transformer Returns Type Description System.Xml.XmlNode A copy of value with the result of transformer placed at the location indicated by path . Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition System.InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter(XmlNode, Func<XmlNode, ValueTask<XmlNode>>) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x) . This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<XmlNode> RewriteIter(this XmlNode value, Func<XmlNode, ValueTask<XmlNode>> transformer) Parameters Type Name Description System.Xml.XmlNode value System.Func < System.Xml.XmlNode , System.Threading.Tasks.ValueTask < System.Xml.XmlNode >> transformer Returns Type Description System.Threading.Tasks.ValueTask < System.Xml.XmlNode > The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask . RewriteIter(XmlNode, Func<XmlNode, XmlNode>) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x) . This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static XmlNode RewriteIter(this XmlNode value, Func<XmlNode, XmlNode> transformer) Parameters Type Name Description System.Xml.XmlNode value System.Func < System.Xml.XmlNode , System.Xml.XmlNode > transformer Returns Type Description System.Xml.XmlNode The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. SelfAndDescendants(XmlNode) Yields all of the nodes in the tree represented by value , starting at the top. This is a depth-first pre-order traversal. See DescendantsAndSelf<T>(IRewriter<T>, T) . Declaration public static IEnumerable<XmlNode> SelfAndDescendants(this XmlNode value) Parameters Type Name Description System.Xml.XmlNode value Returns Type Description System.Collections.Generic.IEnumerable < System.Xml.XmlNode > An enumerable containing all of the nodes in the tree represented by value , starting at the top. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); SelfAndDescendantsBreadthFirst(XmlNode) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<XmlNode> SelfAndDescendantsBreadthFirst(this XmlNode value) Parameters Type Name Description System.Xml.XmlNode value Returns Type Description System.Collections.Generic.IEnumerable < System.Xml.XmlNode > An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. SelfAndDescendantsInContext(XmlNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(XmlNode, Func<XmlNode, XmlNode>)> SelfAndDescendantsInContext(this XmlNode value) Parameters Type Name Description System.Xml.XmlNode value Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple < System.Xml.XmlNode , System.Func < System.Xml.XmlNode , System.Xml.XmlNode >>> An enumerable of contexts. SelfAndDescendantsInContextBreadthFirst(XmlNode) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See SelfAndDescendants<T>(IRewriter<T>, T) . See ChildrenInContext<T>(IRewriter<T>, T) . See DescendantsAndSelfInContext<T>(IRewriter<T>, T) . Declaration public static IEnumerable<(XmlNode, Func<XmlNode, XmlNode>)> SelfAndDescendantsInContextBreadthFirst(this XmlNode value) Parameters Type Name Description System.Xml.XmlNode value Returns Type Description System.Collections.Generic.IEnumerable < System.ValueTuple < System.Xml.XmlNode , System.Func < System.Xml.XmlNode , System.Xml.XmlNode >>> An enumerable of contexts. SetChildren(XmlNode, ReadOnlySpan<XmlNode>) Set the immediate children of the value. Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>, T) . See SetChildren(ReadOnlySpan<T>) . Declaration public static XmlNode SetChildren(this XmlNode value, ReadOnlySpan<XmlNode> newChildren) Parameters Type Name Description System.Xml.XmlNode value System.ReadOnlySpan < System.Xml.XmlNode > newChildren Returns Type Description System.Xml.XmlNode A copy of value with updated children. Examples Given a representation of the expression (1+2)+3 . Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>, T) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, rewriter.SetChildren(Children.Two(new Lit(4), new Lit(5)), expr)); ZipFold<U>(XmlNode, XmlNode, Func<XmlNode, XmlNode, IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this XmlNode value1, XmlNode value2, Func<XmlNode, XmlNode, IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description System.Xml.XmlNode value1 System.Xml.XmlNode value2 System.Func < System.Xml.XmlNode , System.Xml.XmlNode , System.Collections.Generic.IAsyncEnumerable <U>, System.Threading.Tasks.ValueTask <U>> func Returns Type Description System.Threading.Tasks.ValueTask <U> The result of aggregating the two trees. Type Parameters Name Description U Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask and System.Collections.Generic.IAsyncEnumerable`1 . Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(XmlNode, XmlNode, Func<XmlNode, XmlNode, IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this XmlNode value1, XmlNode value2, Func<XmlNode, XmlNode, IEnumerable<U>, U> func) Parameters Type Name Description System.Xml.XmlNode value1 System.Xml.XmlNode value2 System.Func < System.Xml.XmlNode , System.Xml.XmlNode , System.Collections.Generic.IEnumerable <U>, U> func Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(XmlNode[], Func<XmlNode[], IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this XmlNode[] values, Func<XmlNode[], IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description System.Xml.XmlNode [] values System.Func < System.Xml.XmlNode [], System.Collections.Generic.IAsyncEnumerable <U>, System.Threading.Tasks.ValueTask <U>> func Returns Type Description System.Threading.Tasks.ValueTask <U> The result of aggregating the two trees. Type Parameters Name Description U Remarks This method is not available on platforms which do not support System.Threading.Tasks.ValueTask and System.Collections.Generic.IAsyncEnumerable`1 . Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(XmlNode[], Func<XmlNode[], IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2}) . When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this XmlNode[] values, Func<XmlNode[], IEnumerable<U>, U> func) Parameters Type Name Description System.Xml.XmlNode [] values System.Func < System.Xml.XmlNode [], System.Collections.Generic.IEnumerable <U>, U> func Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.Xml.XmlNodeRewriter.html": {
    "href": "Sawmill.Xml.XmlNodeRewriter.html",
    "title": "Class XmlNodeRewriter | Sawmill",
    "keywords": "Class XmlNodeRewriter An implementation of IRewriter<T> for System.Xml.XmlNode s. Inheritance System.Object XmlNodeRewriter Implements IRewriter < System.Xml.XmlNode > Declaration public class XmlNodeRewriter : Object, IRewriter<XmlNode> Constructors XmlNodeRewriter() Create a new instance of XmlNodeRewriter . Declaration protected XmlNodeRewriter() Properties Instance Gets the single global instance of XElementRewriter . Declaration public static XmlNodeRewriter Instance { get; } Property Value Type Description XmlNodeRewriter The single global instance of XElementRewriter . Methods CountChildren(XmlNode) See CountChildren(T) . Declaration public int CountChildren(XmlNode value) Parameters Type Name Description System.Xml.XmlNode value The value. Returns Type Description System.Int32 value 's number of immediate children. GetChildren(Span<XmlNode>, XmlNode) See GetChildren(Span<T>, T) . Declaration public void GetChildren(Span<XmlNode> childrenReceiver, XmlNode value) Parameters Type Name Description System.Span < System.Xml.XmlNode > childrenReceiver A System.Span<> to copy value 's immediate children into. The System.Span<> 's System.Span`1.Length will be equal to the number returned by CountChildren(XmlNode) . System.Xml.XmlNode value The value. SetChildren(ReadOnlySpan<XmlNode>, XmlNode) See SetChildren(ReadOnlySpan<T>, T) . Declaration public XmlNode SetChildren(ReadOnlySpan<XmlNode> newChildren, XmlNode value) Parameters Type Name Description System.ReadOnlySpan < System.Xml.XmlNode > newChildren The new children. System.Xml.XmlNode value The old value, whose immediate children should be replaced. Returns Type Description System.Xml.XmlNode A copy of value with updated children. Implements IRewriter<T>"
  }
}