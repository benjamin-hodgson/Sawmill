{
  "Sawmill.AutoRewriter-1.html": {
    "href": "Sawmill.AutoRewriter-1.html",
    "title": "Class AutoRewriter<T> | Benjamin.Pizza.DocTest",
    "keywords": "Class AutoRewriter<T> An experimental implementation of IRewriter<T> using reflection. AutoRewriter<T> looks for the subtype's constructor, and gets/sets the T-children in the order that they appear in the constructor. Inheritance object AutoRewriter<T> Implements IRewriter<T> Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public class AutoRewriter<T> : IRewriter<T> Type Parameters Name Description T The rewritable type. Constructors AutoRewriter() Create a new instance of AutoRewriter<T>. Declaration protected AutoRewriter() Properties Instance Gets the single global instance of AutoRewriter<T>. Declaration public static AutoRewriter<T> Instance { get; } Property Value Type Description AutoRewriter<T> The single global instance of AutoRewriter<T>. Methods CountChildren(T) See CountChildren(T). Declaration public int CountChildren(T value) Parameters Type Name Description T value The rewritable tree. Returns Type Description int The value's number of immediate children. GetChildren(Span<T>, T) See GetChildren(Span<T>, T). Declaration public void GetChildren(Span<T> childrenReceiver, T value) Parameters Type Name Description Span<T> childrenReceiver A Span<T> to copy the current instance's immediate children into. The Span<T>'s Length should be equal to the number returned by CountChildren(T). T value The rewritable tree. SetChildren(ReadOnlySpan<T>, T) See SetChildren(ReadOnlySpan<T>, T). Declaration public T SetChildren(ReadOnlySpan<T> newChildren, T value) Parameters Type Name Description ReadOnlySpan<T> newChildren The new children. T value The rewritable tree. Returns Type Description T A copy of value with updated children. Implements IRewriter<T> Extension Methods Rewriter.ChildrenInContext<T>(IRewriter<T>, T) Rewriter.Cursor<T>(IRewriter<T>, T) Rewriter.DescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, T) Rewriter.DescendantsAndSelfInContext<T>(IRewriter<T>, T) Rewriter.DescendantsAndSelf<T>(IRewriter<T>, T) Rewriter.Fold<T, U>(IRewriter<T>, SpanFunc<U, T, U>, T) Rewriter.Fold<T, U>(IRewriter<T>, Func<Memory<U>, T, ValueTask<U>>, T) Rewriter.GetChildren<T>(IRewriter<T>, T) Rewriter.ReplaceDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, T, T) Rewriter.RewriteChildren<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rewriter.RewriteChildren<T>(IRewriter<T>, Func<T, T>, T) Rewriter.RewriteDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, Func<T, ValueTask<T>>, T) Rewriter.RewriteDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, Func<T, T>, T) Rewriter.Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rewriter.Rewrite<T>(IRewriter<T>, Func<T, T>, T) Rewriter.SelfAndDescendantsBreadthFirst<T>(IRewriter<T>, T) Rewriter.SelfAndDescendantsInContextBreadthFirst<T>(IRewriter<T>, T) Rewriter.SelfAndDescendantsInContext<T>(IRewriter<T>, T) Rewriter.SelfAndDescendants<T>(IRewriter<T>, T) Rewriter.ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) Rewriter.ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[])"
  },
  "Sawmill.Cursor-1.html": {
    "href": "Sawmill.Cursor-1.html",
    "title": "Class Cursor<T> | Benjamin.Pizza.DocTest",
    "keywords": "Class Cursor<T> A Cursor<T> is a mutable view of a location in a T-structure, allowing efficient access to (and editing of) a node and its parent, siblings, and immediate children. You can think of a Cursor<T> as being focused on a particular node. After zooming in on a node, you can efficiently go up to the node's parent, down to the node's first child, or left or right to the node's immediate siblings. Cursor<T> is generally not as efficient or useful as the SelfAndDescendantsInContext<T>(IRewriter<T>, T) family for replacing single nodes, but it efficiently supports longer sequences of edits to a location and its neighbours. Inheritance object Cursor<T> Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public sealed class Cursor<T> Type Parameters Name Description T The rewritable tree type. Examples Here we traverse to, and replace, the right child of a binary node. Expr expr = new Add(new Lit(1), new Neg(new Lit(2))); var cursor = expr.Cursor(); cursor.Down(); cursor.Right(); Assert.Equal(new Neg(new Lit(2)), cursor.Focus); cursor.Focus = new Lit(10); cursor.Top(); Assert.Equal(new Add(new Lit(1), new Lit(10)), cursor.Focus); Properties Focus Gets or sets the current focus of the Cursor<T>. Declaration public T Focus { get; set; } Property Value Type Description T The current focus of the Cursor<T>. Methods Bottom() Move the current Focus to the bottom-left of the tree. Do nothing if the current Focus has no children. Declaration public void Bottom() Down() Focus the Cursor<T> on the current Focus's first child. This operation \"opens a hole\" in the current node, descending to the children so you can replace them one at a time. Declaration public void Down() Exceptions Type Condition InvalidOperationException The current Focus's has no children. Down(int) Go Down() count times. This operation \"opens a hole\" in the current node and its count first descendants. Declaration public void Down(int count) Parameters Type Name Description int count The distance. Exceptions Type Condition InvalidOperationException The Cursor<T> reached a node with no children. The Cursor<T> is left in the last good state, that is, at the bottom of the tree. ArgumentOutOfRangeException count was negative. DownWhile(Func<T, bool>) Go Down() as long as predicate returns true for the current Focus. In other words, find the first leftmost descendant of Focus (including itself) which does not satisfy predicate. Declaration public void DownWhile(Func<T, bool> predicate) Parameters Type Name Description Func<T, bool> predicate The predicate to invoke on the current focus and its leftmost descendants. Exceptions Type Condition InvalidOperationException The Cursor<T> reached the root node. The Cursor<T> is left in the last good state, that is, at the bottom of the tree. Follow(IEnumerable<Direction>) Follow a path. Declaration public void Follow(IEnumerable<Direction> path) Parameters Type Name Description IEnumerable<Direction> path The path to follow. Exceptions Type Condition InvalidOperationException Thrown when path leads off the edge of the tree. The Cursor<T> is left in the last known good state. GetPath() Yields a sequence of Directions describing how to get from the Top() of the tree to the current Focus. The resulting path can be Follow(IEnumerable<Direction>)ed by a Cursor<T>. This is useful if, for example, you need to compare the nodes at a given position in two different trees. Declaration public IEnumerable<Direction> GetPath() Returns Type Description IEnumerable<Direction> A sequence of Directions. Left() Focus the Cursor<T> on the current Focus's immediate predecessor sibling. Declaration public void Left() Exceptions Type Condition InvalidOperationException The Cursor<T> is already focused on the leftmost sibling. Left(int) Go Left() count times. Declaration public void Left(int count) Parameters Type Name Description int count The distance. Exceptions Type Condition InvalidOperationException The Cursor<T> reached the leftmost sibling. The Cursor<T> is left in the last good state, that is, focused on the leftmost sibling. ArgumentOutOfRangeException count was negative. LeftWhile(Func<T, bool>) Go Left() as long as predicate returns true for the current Focus. In other words, find the first left sibling of Focus (including itself) which does not satisfy predicate. Declaration public void LeftWhile(Func<T, bool> predicate) Parameters Type Name Description Func<T, bool> predicate The predicate to invoke on the current focus and its ancestors. Exceptions Type Condition InvalidOperationException The Cursor<T> reached the root node. The Cursor<T> is left in the last good state, that is, at the leftmost sibling. Leftmost() Focus the Cursor<T> on the current Focus's leftmost sibling. Do nothing if the Cursor<T> is already focused on the leftmost sibling. Declaration public void Leftmost() Move(Direction) Move in a given Direction. Declaration public void Move(Direction direction) Parameters Type Name Description Direction direction The Direction to move in. Exceptions Type Condition InvalidOperationException Thrown when the direction leads off the edge of the tree. The Cursor<T> is left in the last known good state. ArgumentOutOfRangeException Thrown when direction is not a valid Direction. ReleaseOldVersions() Release old versions of the tree for garbage collection. The Cursor<T> is left focused on the current node. Typically you won't need to call this method yourself - just call Top() at the end of your sequence of edits to get the new tree back. (This method is equivalent to calling Top() and then returning to where you were.) The worst-case scenario for Cursor<T>'s memory usage is code which traverses a large tree and alternates Down() calls with setting the Focus, without any calls to Up() in between. If this is a typical usage pattern for your application, and you find that Cursor<T> is causing high memory usage because it's holding on to old trees, some infrequent calls to this method (say, every 1000 edits) should improve the memory usage (at the cost of some speed). Declaration public void ReleaseOldVersions() Right() Focus the Cursor<T> on the current Focus's immediate successor sibling. Declaration public void Right() Exceptions Type Condition InvalidOperationException The Cursor<T> is already focused on the rightmost sibling. Right(int) Go Right() count times. Declaration public void Right(int count) Parameters Type Name Description int count The distance. Exceptions Type Condition InvalidOperationException The Cursor<T> reached the rightmost sibling. The Cursor<T> is left in the last good state, that is, focused on the rightmost sibling. ArgumentOutOfRangeException count was negative. RightWhile(Func<T, bool>) Go Right() as long as predicate returns true for the current Focus. In other words, find the first Right sibling of Focus (including itself) which does not satisfy predicate. Declaration public void RightWhile(Func<T, bool> predicate) Parameters Type Name Description Func<T, bool> predicate The predicate to invoke on the current focus and its ancestors. Exceptions Type Condition InvalidOperationException The Cursor<T> reached the root node. The Cursor<T> is Right in the last good state, that is, at the Rightmost sibling. Rightmost() Focus the Cursor<T> on the current Focus's rightmost sibling. Do nothing if the Cursor<T> is already focused on the rightmost sibling. Declaration public void Rightmost() SearchDownAndRight(Func<T, bool>) Focus the current focus's first descendant or right sibling's descendant which satisfies predicate, searching descendants before siblings and ending at the current node's rightmost sibling. Declaration public bool SearchDownAndRight(Func<T, bool> predicate) Parameters Type Name Description Func<T, bool> predicate A predicate which returns true when the search should stop. Returns Type Description bool True if a matching focus was found, false if the search was exhaustive. Remarks This function searches the bottom-left part of the tree first, so will typically end up focusing a node lower down than SearchRightAndDown(Func<T, bool>). See Also SelfAndDescendants<T>(IRewriter<T>, T) SearchRightAndDown(Func<T, bool>) Focus the current focus's first descendant or right sibling's descendant which satisfies predicate, searching siblings before descendants and ending at the current node's lowest leftmost descendant. This function searches the top-right part of the tree first, so will typically end up focusing a node higher up than SearchDownAndRight(Func<T, bool>). Declaration public bool SearchRightAndDown(Func<T, bool> predicate) Parameters Type Name Description Func<T, bool> predicate A predicate which returns true when the search should stop. Returns Type Description bool True if a matching focus was found, false if the search was exhaustive. Top() Move the Cursor<T> to the top of the tree. This operation \"plugs the hole\" in all of the current node's ancestors, replacing their children as necessary. Going to the Top() releases old versions of the tree so that they can be garbage collected. Declaration public void Top() TryDown() Try to focus the Cursor<T> on the current Focus's first child. This operation \"opens a hole\" in the current node, descending to the children so you can replace them one at a time. Declaration public bool TryDown() Returns Type Description bool True if the operation was successful, false if the current Focus has no children. TryDown(int) Go Down() count times, stopping if you reach a node with no children. This operation \"opens a hole\" in the current node and its count first descendants. Declaration public bool TryDown(int count) Parameters Type Name Description int count The distance. Returns Type Description bool True if the operation was successful, false if the cursor went Down() fewer than count times. Exceptions Type Condition ArgumentOutOfRangeException count was negative. TryDownWhile(Func<T, bool>) Go Down() as long as predicate returns true for the current Focus, stopping if you reach the bottom. In other words, find the first leftmost descendant of Focus (including itself) which does not satisfy predicate. Declaration public bool TryDownWhile(Func<T, bool> predicate) Parameters Type Name Description Func<T, bool> predicate The predicate to invoke on the current focus and its leftmost descendants. Returns Type Description bool True if a leftmost descendant not satisfying predicate was found, false if the Cursor<T> reached the bottom. TryFollow(IEnumerable<Direction>) Follow a path. Declaration public bool TryFollow(IEnumerable<Direction> path) Parameters Type Name Description IEnumerable<Direction> path The path to follow. Returns Type Description bool True if the path was successfully followed in full, false if the path led off the edge of the tree. TryLeft() Try to focus the Cursor<T> on the current Focus's immediate predecessor sibling. Declaration public bool TryLeft() Returns Type Description bool True if the operation was successful, false if the Cursor<T> is already focused on the leftmost sibling. TryLeft(int) Go Left() count times, stopping if you reach the leftmost sibling. Declaration public bool TryLeft(int count) Parameters Type Name Description int count The distance. Returns Type Description bool True if the operation was successful, false if the cursor went Left() fewer than count times. Exceptions Type Condition ArgumentOutOfRangeException count was negative. TryLeftWhile(Func<T, bool>) Go Left() as long as predicate returns true for the current Focus, stopping if you reach the leftmost sibling. In other words, find the left sibling of Focus (including itself) which does not satisfy predicate. Declaration public bool TryLeftWhile(Func<T, bool> predicate) Parameters Type Name Description Func<T, bool> predicate The predicate to invoke on the current focus and its ancestors. Returns Type Description bool True if an ancestor not satisfying predicate was found, false if the Cursor<T> reached the leftmost sibling. TryMove(Direction) Try to move in a given Direction. Declaration public bool TryMove(Direction direction) Parameters Type Name Description Direction direction The Direction to move in. Returns Type Description bool True if the operation was successful, false if the direction leads off the edge of the tree. Exceptions Type Condition ArgumentOutOfRangeException Thrown when direction is not a valid Direction. TryRight() Try to focus the Cursor<T> on the current Focus's immediate successor sibling. Declaration public bool TryRight() Returns Type Description bool True if the operation was successful, false if the Cursor<T> is already focused on the rightmost sibling. TryRight(int) Go Right() count times, stopping if you reach the rightmost sibling. Declaration public bool TryRight(int count) Parameters Type Name Description int count The distance. Returns Type Description bool True if the operation was successful, false if the cursor went Right() fewer than count times. Exceptions Type Condition ArgumentOutOfRangeException count was negative. TryRightWhile(Func<T, bool>) Go Right() as long as predicate returns true for the current Focus, stopping if you reach the Rightmost sibling. In other words, find the Right sibling of Focus (including itself) which does not satisfy predicate. Declaration public bool TryRightWhile(Func<T, bool> predicate) Parameters Type Name Description Func<T, bool> predicate The predicate to invoke on the current focus and its ancestors. Returns Type Description bool True if an ancestor not satisfying predicate was found, false if the Cursor<T> reached the Rightmost sibling. TryUp() Try to focus the Cursor<T> on the current Focus's parent. This operation \"plugs the hole\" in the parent, replacing the parent's children as necessary. This releases old versions of the current Focus and its children, so that they can be garbage collected. Declaration public bool TryUp() Returns Type Description bool True if the operation was successful, false if the Cursor<T> is already focused on the root node. TryUp(int) Go Up() count times, stopping if you reach the top. This operation \"plugs the hole\" in the parent, replacing the parent's children as necessary. This releases old versions of the ancestors and their children, so that they can be garbage collected. Declaration public bool TryUp(int count) Parameters Type Name Description int count The distance. Returns Type Description bool True if the operation was successful, false if the cursor went Up() fewer than count times. Exceptions Type Condition ArgumentOutOfRangeException count was negative. TryUpWhile(Func<T, bool>) Go Up() as long as predicate returns true for the current Focus, stopping if you reach the top. In other words, find the first ancestor of Focus (including itself) which does not satisfy predicate. This operation \"plugs the hole\" in the ancestors, replacing their children as necessary. This releases old versions of the ancestors and their children, so that they can be garbage collected. Declaration public bool TryUpWhile(Func<T, bool> predicate) Parameters Type Name Description Func<T, bool> predicate The predicate to invoke on the current focus and its ancestors. Returns Type Description bool True if an ancestor not satisfying predicate was found, false if the Cursor<T> reached the top. Up() Focus the Cursor<T> on the current Focus's parent. Going Up() \"plugs the hole\" in the parent, replacing the parent's children as necessary. This releases old versions of the current Focus and its children so that they can be garbage collected. Declaration public void Up() Exceptions Type Condition InvalidOperationException The Cursor<T> is already focused on the root node. Up(int) Go Up() count times. Going Up(int) \"plugs the hole\" in the ancestors, replacing their children as necessary. This releases old versions of the ancestors and their children, so that they can be garbage collected. Declaration public void Up(int count) Parameters Type Name Description int count The distance. Exceptions Type Condition InvalidOperationException The Cursor<T> reached the root node. The Cursor<T> is left in the last good state, that is, at the top of the tree. ArgumentOutOfRangeException count was negative. UpWhile(Func<T, bool>) Go Up() as long as predicate returns true for the current Focus. In other words, find the first ancestor of Focus (including itself) which does not satisfy predicate. This operation \"plugs the hole\" in the ancestors, replacing their children as necessary. This releases old versions of the ancestors and their children, so that they can be garbage collected. Declaration public void UpWhile(Func<T, bool> predicate) Parameters Type Name Description Func<T, bool> predicate The predicate to invoke on the current focus and its ancestors. Exceptions Type Condition InvalidOperationException The Cursor<T> reached the root node. The Cursor<T> is left in the last good state, that is, at the top of the tree."
  },
  "Sawmill.Direction.html": {
    "href": "Sawmill.Direction.html",
    "title": "Enum Direction | Benjamin.Pizza.DocTest",
    "keywords": "Enum Direction Represents a direction that a Cursor<T> can move in. Declaration public enum Direction Fields Name Description Down Move to the first child. Left Move to the previous sibling. Right Move to the next sibling. Up Move to the parent."
  },
  "Sawmill.Expressions.ExpressionExtensions.html": {
    "href": "Sawmill.Expressions.ExpressionExtensions.html",
    "title": "Class ExpressionExtensions | Benjamin.Pizza.DocTest",
    "keywords": "Class ExpressionExtensions Extension methods for Expressions. Inheritance object ExpressionExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public static class ExpressionExtensions Methods ChildrenInContext(Expression) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. Declaration public static (Expression item, Func<Expression, Expression> replace)[] ChildrenInContext(this Expression value) Parameters Type Name Description Expression value The value to get the contexts for the immediate children. Returns Type Description (Expression item, Func<Expression, Expression> replace)[] An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See Also SelfAndDescendantsInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) CountChildren(Expression) Count the immediate children of the value. Declaration public static int CountChildren(this Expression value) Parameters Type Name Description Expression value The value. Returns Type Description int value's number of immediate children. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren(T) counts the immediate children of the topmost (Add) node. Assert.Equal(2, rewriter.CountChildren(expr)); See Also CountChildren() Cursor(Expression) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value. Declaration public static Cursor<Expression> Cursor(this Expression value) Parameters Type Name Description Expression value The root node on which the newly created Cursor<T>(IRewriter<T>, T) should be focused. Returns Type Description Cursor<Expression> A Cursor<T>(IRewriter<T>, T) focused on the root node of value. DescendantAt(Expression, IEnumerable<Direction>) Returns the descendant at a particular location in value. Declaration public static Expression DescendantAt(this Expression value, IEnumerable<Direction> path) Parameters Type Name Description Expression value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Returns Type Description Expression The descendant found by following the directions in path. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelf(Expression) Yields all of the nodes in the tree represented by value, starting at the bottom. Declaration public static IEnumerable<Expression> DescendantsAndSelf(this Expression value) Parameters Type Name Description Expression value The value to traverse. Returns Type Description IEnumerable<Expression> An enumerable containing all of the nodes in the tree represented by value, starting at the bottom. Remarks This is a depth-first post-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); See Also SelfAndDescendants<T>(IRewriter<T>, T) DescendantsAndSelfInContext(Expression) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(Expression item, Func<Expression, Expression> replace)> DescendantsAndSelfInContext(this Expression value) Parameters Type Name Description Expression value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(Expression item, Func<Expression, Expression> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See Also DescendantsAndSelf<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContext<T>(IRewriter<T>, T) Fold<T>(Expression, SpanFunc<T, Expression, T>) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static T Fold<T>(this Expression value, SpanFunc<T, Expression, T> func) Parameters Type Name Description Expression value The value to fold. SpanFunc<T, Expression, T> func The aggregation function. Returns Type Description T The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Fold<T>(Expression, Func<Memory<T>, Expression, ValueTask<T>>) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<T> Fold<T>(this Expression value, Func<Memory<T>, Expression, ValueTask<T>> func) Parameters Type Name Description Expression value The value to fold. Func<Memory<T>, Expression, ValueTask<T>> func The asynchronous aggregation function. Returns Type Description ValueTask<T> The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. GetChildren(Expression) Get the immediate children of the value. Declaration public static Expression[] GetChildren(this Expression value) Parameters Type Name Description Expression value The value. Returns Type Description Expression[] The immediate children of value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); See Also GetChildren(Span<T>) GetChildren(Expression, Span<Expression>) Copy the immediate children of the value into childrenReceiver. Declaration public static void GetChildren(this Expression value, Span<Expression> childrenReceiver) Parameters Type Name Description Expression value The value. Span<Expression> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>, T) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[rewriter.CountChildren(expr)]; rewriter.GetChildren(array, expr); Assert.Equal(expected, array); See Also GetChildren(Span<T>) ReplaceDescendantAt<T>(Expression, IEnumerable<Direction>, Expression) Replaces the descendant at a particular location in value. Declaration public static Expression ReplaceDescendantAt<T>(this Expression value, IEnumerable<Direction> path, Expression newDescendant) Parameters Type Name Description Expression value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Expression newDescendant The replacement descendant. Returns Type Description Expression A copy of value with newDescendant placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. Rewrite(Expression, Func<Expression, Expression>) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static Expression Rewrite(this Expression value, Func<Expression, Expression> transformer) Parameters Type Name Description Expression value The value to rewrite. Func<Expression, Expression> transformer The transformation function to apply to every node in the tree. Returns Type Description Expression The result of applying transformer to every node in the tree represented by value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); Rewrite(Expression, Func<Expression, ValueTask<Expression>>) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<Expression> Rewrite(this Expression value, Func<Expression, ValueTask<Expression>> transformer) Parameters Type Name Description Expression value The value to rewrite. Func<Expression, ValueTask<Expression>> transformer The asynchronous transformation function to apply to every node in the tree. Returns Type Description ValueTask<Expression> The result of applying transformer to every node in the tree represented by value. Remarks This method is not available on platforms which do not support ValueTask. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); RewriteChildren(Expression, Func<Expression, Expression>) Update the immediate children of the value by applying a transformation function to each one. Declaration public static Expression RewriteChildren(this Expression value, Func<Expression, Expression> transformer) Parameters Type Name Description Expression value The old value, whose immediate children should be transformed by transformer. Func<Expression, Expression> transformer A transformation function to apply to each of value's immediate children. Returns Type Description Expression A copy of value with updated children. RewriteChildren(Expression, Func<Expression, ValueTask<Expression>>) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<Expression> RewriteChildren(this Expression value, Func<Expression, ValueTask<Expression>> transformer) Parameters Type Name Description Expression value The old value, whose immediate children should be transformed by transformer. Func<Expression, ValueTask<Expression>> transformer An asynchronous transformation function to apply to each of value's immediate children. Returns Type Description ValueTask<Expression> A copy of value with updated children. Remarks This method is not available on platforms which do not support ValueTask. RewriteDescendantAt<T>(Expression, IEnumerable<Direction>, Func<Expression, Expression>) Apply a function at a particular location in value. Declaration public static Expression RewriteDescendantAt<T>(this Expression value, IEnumerable<Direction> path, Func<Expression, Expression> transformer) Parameters Type Name Description Expression value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<Expression, Expression> transformer A function to calculate a replacement for the descendant. Returns Type Description Expression A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(Expression, IEnumerable<Direction>, Func<Expression, ValueTask<Expression>>) Apply an asynchronous function at a particular location in value. Declaration public static ValueTask<Expression> RewriteDescendantAt<T>(this Expression value, IEnumerable<Direction> path, Func<Expression, ValueTask<Expression>> transformer) Parameters Type Name Description Expression value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<Expression, ValueTask<Expression>> transformer An asynchronous function to calculate a replacement for the descendant. Returns Type Description ValueTask<Expression> A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter(Expression, Func<Expression, Expression>) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static Expression RewriteIter(this Expression value, Func<Expression, Expression> transformer) Parameters Type Name Description Expression value The value to rewrite. Func<Expression, Expression> transformer A transformation function to apply to every node in value repeatedly. Returns Type Description Expression The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. RewriteIter(Expression, Func<Expression, ValueTask<Expression>>) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<Expression> RewriteIter(this Expression value, Func<Expression, ValueTask<Expression>> transformer) Parameters Type Name Description Expression value The value to rewrite. Func<Expression, ValueTask<Expression>> transformer An asynchronous transformation function to apply to every node in value repeatedly. Returns Type Description ValueTask<Expression> The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Remarks This method is not available on platforms which do not support ValueTask. SelfAndDescendants(Expression) Yields all of the nodes in the tree represented by value, starting at the top. Declaration public static IEnumerable<Expression> SelfAndDescendants(this Expression value) Parameters Type Name Description Expression value The value to traverse. Returns Type Description IEnumerable<Expression> An enumerable containing all of the nodes in the tree represented by value, starting at the top. Remarks This is a depth-first pre-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); See Also DescendantsAndSelf<T>(IRewriter<T>, T) SelfAndDescendantsBreadthFirst(Expression) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<Expression> SelfAndDescendantsBreadthFirst(this Expression value) Parameters Type Name Description Expression value The value to traverse. Returns Type Description IEnumerable<Expression> An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. SelfAndDescendantsInContext(Expression) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(Expression item, Func<Expression, Expression> replace)> SelfAndDescendantsInContext(this Expression value) Parameters Type Name Description Expression value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(Expression item, Func<Expression, Expression> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContextBreadthFirst(Expression) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(Expression item, Func<Expression, Expression> replace)> SelfAndDescendantsInContextBreadthFirst(this Expression value) Parameters Type Name Description Expression value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(Expression item, Func<Expression, Expression> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SetChildren(Expression, ReadOnlySpan<Expression>) Set the immediate children of the value. Declaration public static Expression SetChildren(this Expression value, ReadOnlySpan<Expression> newChildren) Parameters Type Name Description Expression value The old value, whose immediate children should be replaced. ReadOnlySpan<Expression> newChildren The new children. Returns Type Description Expression A copy of value with updated children. Remarks Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>, T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>, T) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, rewriter.SetChildren(Children.Two(new Lit(4), new Lit(5)), expr)); See Also SetChildren(ReadOnlySpan<T>) ZipFold<U>(Expression, Expression, Func<Expression, Expression, IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this Expression value1, Expression value2, Func<Expression, Expression, IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description Expression value1 Expression value2 Func<Expression, Expression, IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(Expression, Expression, Func<Expression, Expression, IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this Expression value1, Expression value2, Func<Expression, Expression, IEnumerable<U>, U> func) Parameters Type Name Description Expression value1 Expression value2 Func<Expression, Expression, IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(Expression[], Func<Expression[], IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this Expression[] values, Func<Expression[], IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description Expression[] values The trees to fold. Func<Expression[], IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(Expression[], Func<Expression[], IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this Expression[] values, Func<Expression[], IEnumerable<U>, U> func) Parameters Type Name Description Expression[] values The trees to fold. Func<Expression[], IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.Expressions.ExpressionRewriter.html": {
    "href": "Sawmill.Expressions.ExpressionRewriter.html",
    "title": "Class ExpressionRewriter | Benjamin.Pizza.DocTest",
    "keywords": "Class ExpressionRewriter An implementation of IRewriter<T> for Expressions. Inheritance object ExpressionRewriter Implements IRewriter<Expression> Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public class ExpressionRewriter : IRewriter<Expression> Constructors ExpressionRewriter() Create a new instance of ExpressionRewriter. Declaration protected ExpressionRewriter() Properties Instance Gets the single global instance of ExpressionRewriter. Declaration public static ExpressionRewriter Instance { get; } Property Value Type Description ExpressionRewriter The single global instance of ExpressionRewriter. Methods CountChildren(Expression) See CountChildren(T). Declaration public int CountChildren(Expression value) Parameters Type Name Description Expression value The value. Returns Type Description int value's number of immediate children. GetChildren(Span<Expression>, Expression) See GetChildren(Span<T>, T). Declaration public void GetChildren(Span<Expression> childrenReceiver, Expression value) Parameters Type Name Description Span<Expression> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(Expression). Expression value The value. SetChildren(ReadOnlySpan<Expression>, Expression) See SetChildren(ReadOnlySpan<T>, T). Declaration public Expression SetChildren(ReadOnlySpan<Expression> newChildren, Expression value) Parameters Type Name Description ReadOnlySpan<Expression> newChildren The new children. Expression value The old value, whose immediate children should be replaced. Returns Type Description Expression A copy of value with updated children. Implements IRewriter<T> Extension Methods Rewriter.ChildrenInContext<T>(IRewriter<T>, T) Rewriter.Cursor<T>(IRewriter<T>, T) Rewriter.DescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, T) Rewriter.DescendantsAndSelfInContext<T>(IRewriter<T>, T) Rewriter.DescendantsAndSelf<T>(IRewriter<T>, T) Rewriter.Fold<T, U>(IRewriter<T>, SpanFunc<U, T, U>, T) Rewriter.Fold<T, U>(IRewriter<T>, Func<Memory<U>, T, ValueTask<U>>, T) Rewriter.GetChildren<T>(IRewriter<T>, T) Rewriter.ReplaceDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, T, T) Rewriter.RewriteChildren<T>(IRewriter<T>, Func<T, T>, T) Rewriter.RewriteChildren<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rewriter.RewriteDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, Func<T, T>, T) Rewriter.RewriteDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, Func<T, ValueTask<T>>, T) Rewriter.RewriteIter<T>(IRewriter<T>, Func<T, T>, T) Rewriter.RewriteIter<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rewriter.Rewrite<T>(IRewriter<T>, Func<T, T>, T) Rewriter.Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rewriter.SelfAndDescendantsBreadthFirst<T>(IRewriter<T>, T) Rewriter.SelfAndDescendantsInContextBreadthFirst<T>(IRewriter<T>, T) Rewriter.SelfAndDescendantsInContext<T>(IRewriter<T>, T) Rewriter.SelfAndDescendants<T>(IRewriter<T>, T) Rewriter.ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) Rewriter.ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[])"
  },
  "Sawmill.Expressions.html": {
    "href": "Sawmill.Expressions.html",
    "title": "Namespace Sawmill.Expressions | Benjamin.Pizza.DocTest",
    "keywords": "Namespace Sawmill.Expressions Classes ExpressionExtensions Extension methods for Expressions. ExpressionRewriter An implementation of IRewriter<T> for Expressions."
  },
  "Sawmill.HtmlAgilityPack.HtmlNodeExtensions.html": {
    "href": "Sawmill.HtmlAgilityPack.HtmlNodeExtensions.html",
    "title": "Class HtmlNodeExtensions | Benjamin.Pizza.DocTest",
    "keywords": "Class HtmlNodeExtensions Extension methods for HtmlAgilityPack.HtmlNodes. Inheritance object HtmlNodeExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public static class HtmlNodeExtensions Methods ChildrenInContext(HtmlNode) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. Declaration public static (HtmlNode item, Func<HtmlNode, HtmlNode> replace)[] ChildrenInContext(this HtmlNode value) Parameters Type Name Description HtmlNode value The value to get the contexts for the immediate children. Returns Type Description (HtmlNode item, Func<HtmlNode, HtmlNode> replace)[] An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See Also SelfAndDescendantsInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) CountChildren(HtmlNode) Count the immediate children of the value. Declaration public static int CountChildren(this HtmlNode value) Parameters Type Name Description HtmlNode value The value. Returns Type Description int value's number of immediate children. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren(T) counts the immediate children of the topmost (Add) node. Assert.Equal(2, rewriter.CountChildren(expr)); See Also CountChildren() Cursor(HtmlNode) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value. Declaration public static Cursor<HtmlNode> Cursor(this HtmlNode value) Parameters Type Name Description HtmlNode value The root node on which the newly created Cursor<T>(IRewriter<T>, T) should be focused. Returns Type Description Cursor<HtmlNode> A Cursor<T>(IRewriter<T>, T) focused on the root node of value. DescendantAt(HtmlNode, IEnumerable<Direction>) Returns the descendant at a particular location in value. Declaration public static HtmlNode DescendantAt(this HtmlNode value, IEnumerable<Direction> path) Parameters Type Name Description HtmlNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Returns Type Description HtmlNode The descendant found by following the directions in path. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelf(HtmlNode) Yields all of the nodes in the tree represented by value, starting at the bottom. Declaration public static IEnumerable<HtmlNode> DescendantsAndSelf(this HtmlNode value) Parameters Type Name Description HtmlNode value The value to traverse. Returns Type Description IEnumerable<HtmlNode> An enumerable containing all of the nodes in the tree represented by value, starting at the bottom. Remarks This is a depth-first post-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); See Also SelfAndDescendants<T>(IRewriter<T>, T) DescendantsAndSelfInContext(HtmlNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(HtmlNode item, Func<HtmlNode, HtmlNode> replace)> DescendantsAndSelfInContext(this HtmlNode value) Parameters Type Name Description HtmlNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(HtmlNode item, Func<HtmlNode, HtmlNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See Also DescendantsAndSelf<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContext<T>(IRewriter<T>, T) Fold<T>(HtmlNode, SpanFunc<T, HtmlNode, T>) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static T Fold<T>(this HtmlNode value, SpanFunc<T, HtmlNode, T> func) Parameters Type Name Description HtmlNode value The value to fold. SpanFunc<T, HtmlNode, T> func The aggregation function. Returns Type Description T The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Fold<T>(HtmlNode, Func<Memory<T>, HtmlNode, ValueTask<T>>) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<T> Fold<T>(this HtmlNode value, Func<Memory<T>, HtmlNode, ValueTask<T>> func) Parameters Type Name Description HtmlNode value The value to fold. Func<Memory<T>, HtmlNode, ValueTask<T>> func The asynchronous aggregation function. Returns Type Description ValueTask<T> The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. GetChildren(HtmlNode) Get the immediate children of the value. Declaration public static HtmlNode[] GetChildren(this HtmlNode value) Parameters Type Name Description HtmlNode value The value. Returns Type Description HtmlNode[] The immediate children of value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); See Also GetChildren(Span<T>) GetChildren(HtmlNode, Span<HtmlNode>) Copy the immediate children of the value into childrenReceiver. Declaration public static void GetChildren(this HtmlNode value, Span<HtmlNode> childrenReceiver) Parameters Type Name Description HtmlNode value The value. Span<HtmlNode> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>, T) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[rewriter.CountChildren(expr)]; rewriter.GetChildren(array, expr); Assert.Equal(expected, array); See Also GetChildren(Span<T>) ReplaceDescendantAt<T>(HtmlNode, IEnumerable<Direction>, HtmlNode) Replaces the descendant at a particular location in value. Declaration public static HtmlNode ReplaceDescendantAt<T>(this HtmlNode value, IEnumerable<Direction> path, HtmlNode newDescendant) Parameters Type Name Description HtmlNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. HtmlNode newDescendant The replacement descendant. Returns Type Description HtmlNode A copy of value with newDescendant placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. Rewrite(HtmlNode, Func<HtmlNode, HtmlNode>) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static HtmlNode Rewrite(this HtmlNode value, Func<HtmlNode, HtmlNode> transformer) Parameters Type Name Description HtmlNode value The value to rewrite. Func<HtmlNode, HtmlNode> transformer The transformation function to apply to every node in the tree. Returns Type Description HtmlNode The result of applying transformer to every node in the tree represented by value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); Rewrite(HtmlNode, Func<HtmlNode, ValueTask<HtmlNode>>) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<HtmlNode> Rewrite(this HtmlNode value, Func<HtmlNode, ValueTask<HtmlNode>> transformer) Parameters Type Name Description HtmlNode value The value to rewrite. Func<HtmlNode, ValueTask<HtmlNode>> transformer The asynchronous transformation function to apply to every node in the tree. Returns Type Description ValueTask<HtmlNode> The result of applying transformer to every node in the tree represented by value. Remarks This method is not available on platforms which do not support ValueTask. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); RewriteChildren(HtmlNode, Func<HtmlNode, HtmlNode>) Update the immediate children of the value by applying a transformation function to each one. Declaration public static HtmlNode RewriteChildren(this HtmlNode value, Func<HtmlNode, HtmlNode> transformer) Parameters Type Name Description HtmlNode value The old value, whose immediate children should be transformed by transformer. Func<HtmlNode, HtmlNode> transformer A transformation function to apply to each of value's immediate children. Returns Type Description HtmlNode A copy of value with updated children. RewriteChildren(HtmlNode, Func<HtmlNode, ValueTask<HtmlNode>>) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<HtmlNode> RewriteChildren(this HtmlNode value, Func<HtmlNode, ValueTask<HtmlNode>> transformer) Parameters Type Name Description HtmlNode value The old value, whose immediate children should be transformed by transformer. Func<HtmlNode, ValueTask<HtmlNode>> transformer An asynchronous transformation function to apply to each of value's immediate children. Returns Type Description ValueTask<HtmlNode> A copy of value with updated children. Remarks This method is not available on platforms which do not support ValueTask. RewriteDescendantAt<T>(HtmlNode, IEnumerable<Direction>, Func<HtmlNode, HtmlNode>) Apply a function at a particular location in value. Declaration public static HtmlNode RewriteDescendantAt<T>(this HtmlNode value, IEnumerable<Direction> path, Func<HtmlNode, HtmlNode> transformer) Parameters Type Name Description HtmlNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<HtmlNode, HtmlNode> transformer A function to calculate a replacement for the descendant. Returns Type Description HtmlNode A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(HtmlNode, IEnumerable<Direction>, Func<HtmlNode, ValueTask<HtmlNode>>) Apply an asynchronous function at a particular location in value. Declaration public static ValueTask<HtmlNode> RewriteDescendantAt<T>(this HtmlNode value, IEnumerable<Direction> path, Func<HtmlNode, ValueTask<HtmlNode>> transformer) Parameters Type Name Description HtmlNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<HtmlNode, ValueTask<HtmlNode>> transformer An asynchronous function to calculate a replacement for the descendant. Returns Type Description ValueTask<HtmlNode> A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter(HtmlNode, Func<HtmlNode, HtmlNode>) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static HtmlNode RewriteIter(this HtmlNode value, Func<HtmlNode, HtmlNode> transformer) Parameters Type Name Description HtmlNode value The value to rewrite. Func<HtmlNode, HtmlNode> transformer A transformation function to apply to every node in value repeatedly. Returns Type Description HtmlNode The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. RewriteIter(HtmlNode, Func<HtmlNode, ValueTask<HtmlNode>>) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<HtmlNode> RewriteIter(this HtmlNode value, Func<HtmlNode, ValueTask<HtmlNode>> transformer) Parameters Type Name Description HtmlNode value The value to rewrite. Func<HtmlNode, ValueTask<HtmlNode>> transformer An asynchronous transformation function to apply to every node in value repeatedly. Returns Type Description ValueTask<HtmlNode> The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Remarks This method is not available on platforms which do not support ValueTask. SelfAndDescendants(HtmlNode) Yields all of the nodes in the tree represented by value, starting at the top. Declaration public static IEnumerable<HtmlNode> SelfAndDescendants(this HtmlNode value) Parameters Type Name Description HtmlNode value The value to traverse. Returns Type Description IEnumerable<HtmlNode> An enumerable containing all of the nodes in the tree represented by value, starting at the top. Remarks This is a depth-first pre-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); See Also DescendantsAndSelf<T>(IRewriter<T>, T) SelfAndDescendantsBreadthFirst(HtmlNode) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<HtmlNode> SelfAndDescendantsBreadthFirst(this HtmlNode value) Parameters Type Name Description HtmlNode value The value to traverse. Returns Type Description IEnumerable<HtmlNode> An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. SelfAndDescendantsInContext(HtmlNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(HtmlNode item, Func<HtmlNode, HtmlNode> replace)> SelfAndDescendantsInContext(this HtmlNode value) Parameters Type Name Description HtmlNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(HtmlNode item, Func<HtmlNode, HtmlNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContextBreadthFirst(HtmlNode) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(HtmlNode item, Func<HtmlNode, HtmlNode> replace)> SelfAndDescendantsInContextBreadthFirst(this HtmlNode value) Parameters Type Name Description HtmlNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(HtmlNode item, Func<HtmlNode, HtmlNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SetChildren(HtmlNode, ReadOnlySpan<HtmlNode>) Set the immediate children of the value. Declaration public static HtmlNode SetChildren(this HtmlNode value, ReadOnlySpan<HtmlNode> newChildren) Parameters Type Name Description HtmlNode value The old value, whose immediate children should be replaced. ReadOnlySpan<HtmlNode> newChildren The new children. Returns Type Description HtmlNode A copy of value with updated children. Remarks Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>, T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>, T) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, rewriter.SetChildren(Children.Two(new Lit(4), new Lit(5)), expr)); See Also SetChildren(ReadOnlySpan<T>) ZipFold<U>(HtmlNode, HtmlNode, Func<HtmlNode, HtmlNode, IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this HtmlNode value1, HtmlNode value2, Func<HtmlNode, HtmlNode, IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description HtmlNode value1 HtmlNode value2 Func<HtmlNode, HtmlNode, IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(HtmlNode, HtmlNode, Func<HtmlNode, HtmlNode, IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this HtmlNode value1, HtmlNode value2, Func<HtmlNode, HtmlNode, IEnumerable<U>, U> func) Parameters Type Name Description HtmlNode value1 HtmlNode value2 Func<HtmlNode, HtmlNode, IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(HtmlNode[], Func<HtmlNode[], IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this HtmlNode[] values, Func<HtmlNode[], IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description HtmlNode[] values The trees to fold. Func<HtmlNode[], IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(HtmlNode[], Func<HtmlNode[], IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this HtmlNode[] values, Func<HtmlNode[], IEnumerable<U>, U> func) Parameters Type Name Description HtmlNode[] values The trees to fold. Func<HtmlNode[], IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.HtmlAgilityPack.HtmlNodeRewriter.html": {
    "href": "Sawmill.HtmlAgilityPack.HtmlNodeRewriter.html",
    "title": "Class HtmlNodeRewriter | Benjamin.Pizza.DocTest",
    "keywords": "Class HtmlNodeRewriter An implementation of IRewriter<T> for HtmlAgilityPack.HtmlNodes. Inheritance object HtmlNodeRewriter Implements IRewriter<HtmlNode> Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public class HtmlNodeRewriter : IRewriter<HtmlNode> Constructors HtmlNodeRewriter() Create a new instance of HtmlNodeRewriter. Declaration protected HtmlNodeRewriter() Properties Instance Gets the single global instance of HtmlNodeRewriter. Declaration public static IRewriter<HtmlNode> Instance { get; } Property Value Type Description IRewriter<HtmlNode> The single global instance of HtmlNodeRewriter. Methods CountChildren(HtmlNode) See CountChildren(T). Declaration public int CountChildren(HtmlNode value) Parameters Type Name Description HtmlNode value The value. Returns Type Description int value's number of immediate children. GetChildren(Span<HtmlNode>, HtmlNode) See GetChildren(Span<T>, T). Declaration public void GetChildren(Span<HtmlNode> childrenReceiver, HtmlNode value) Parameters Type Name Description Span<HtmlNode> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(HtmlNode). HtmlNode value The value. SetChildren(ReadOnlySpan<HtmlNode>, HtmlNode) See SetChildren(ReadOnlySpan<T>, T). Declaration public HtmlNode SetChildren(ReadOnlySpan<HtmlNode> newChildren, HtmlNode value) Parameters Type Name Description ReadOnlySpan<HtmlNode> newChildren The new children. HtmlNode value The old value, whose immediate children should be replaced. Returns Type Description HtmlNode A copy of value with updated children. Implements IRewriter<T>"
  },
  "Sawmill.HtmlAgilityPack.html": {
    "href": "Sawmill.HtmlAgilityPack.html",
    "title": "Namespace Sawmill.HtmlAgilityPack | Benjamin.Pizza.DocTest",
    "keywords": "Namespace Sawmill.HtmlAgilityPack Classes HtmlNodeExtensions Extension methods for HtmlAgilityPack.HtmlNodes. HtmlNodeRewriter An implementation of IRewriter<T> for HtmlAgilityPack.HtmlNodes."
  },
  "Sawmill.IRewritable-1.html": {
    "href": "Sawmill.IRewritable-1.html",
    "title": "Interface IRewritable<T> | Benjamin.Pizza.DocTest",
    "keywords": "Interface IRewritable<T> A object is rewritable if it knows how to access its immediate children. Declaration public interface IRewritable<T> where T : IRewritable<T> Type Parameters Name Description T The type of the object implementing the interface. Remarks Implementations should ensure that you always get the children you just set (rewritable.SetChildren(children).GetChildren() == children), and that successive sets overwrite the earlier operation (rewritable.SetChildren(children1).SetChildren(children2) == rewritable.SetChildren(children2)). Methods CountChildren() Count the immediate children of the current instance. Declaration int CountChildren() Returns Type Description int The current instance's number of immediate children. Remarks Implementations should ensure that you always get the children you just set (rewritable.SetChildren(children).GetChildren() == children), and that successive sets overwrite the earlier operation (rewritable.SetChildren(children1).SetChildren(children2) == rewritable.SetChildren(children2)). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren() counts the immediate children of the topmost (Add) node. Assert.Equal(2, expr.CountChildren()); See Also CountChildren(T) GetChildren(Span<T>) Copy the immediate children of the current instance into childrenReceiver. Declaration void GetChildren(Span<T> childrenReceiver) Parameters Type Name Description Span<T> childrenReceiver A Span<T> to copy the current instance's immediate children into. The Span<T>'s Length should be equal to the number returned by CountChildren(). Remarks Implementations should ensure that you always get the children you just set (rewritable.SetChildren(children).GetChildren() == children), and that successive sets overwrite the earlier operation (rewritable.SetChildren(children1).SetChildren(children2) == rewritable.SetChildren(children2)). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[expr.CountChildren()]; expr.GetChildren(array); Assert.Equal(expected, array); See Also GetChildren(Span<T>, T) SetChildren(ReadOnlySpan<T>) Set the immediate children of the current instance. Declaration T SetChildren(ReadOnlySpan<T> newChildren) Parameters Type Name Description ReadOnlySpan<T> newChildren The new children. Returns Type Description T A copy of the current instance with updated children. Remarks Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, expr.SetChildren(Children.Two(new Lit(4), new Lit(5)))); See Also SetChildren(ReadOnlySpan<T>, T) See Also IRewriter<T>"
  },
  "Sawmill.IRewriter-1.html": {
    "href": "Sawmill.IRewriter-1.html",
    "title": "Interface IRewriter<T> | Benjamin.Pizza.DocTest",
    "keywords": "Interface IRewriter<T> A rewriter is an object which knows how to access the immediate children of a value of type T. Declaration public interface IRewriter<T> Type Parameters Name Description T The type for which the rewriter can get the immediate children. Remarks Implementations should ensure that you always get the children you just set (rewriter.GetChildren(rewriter.SetChildren(children, expr)) == children), and that successive sets overwrite the earlier operation (rewriter.SetChildren(children2, rewriter.SetChildren(children1, expr)) == rewriter.SetChildren(children2, expr)). Methods CountChildren(T) Count the immediate children of the value. Declaration int CountChildren(T value) Parameters Type Name Description T value The value. Returns Type Description int value's number of immediate children. Remarks Implementations should ensure that you always get the children you just set (rewriter.GetChildren(rewriter.SetChildren(children, expr)) == children), and that successive sets overwrite the earlier operation (rewriter.SetChildren(children2, rewriter.SetChildren(children1, expr)) == rewriter.SetChildren(children2, expr)). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren(T) counts the immediate children of the topmost (Add) node. Assert.Equal(2, rewriter.CountChildren(expr)); See Also CountChildren() GetChildren(Span<T>, T) Copy the immediate children of the value into childrenReceiver. Declaration void GetChildren(Span<T> childrenReceiver, T value) Parameters Type Name Description Span<T> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(T). T value The value. Remarks Implementations should ensure that you always get the children you just set (rewriter.GetChildren(rewriter.SetChildren(children, expr)) == children), and that successive sets overwrite the earlier operation (rewriter.SetChildren(children2, rewriter.SetChildren(children1, expr)) == rewriter.SetChildren(children2, expr)). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>, T) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[rewriter.CountChildren(expr)]; rewriter.GetChildren(array, expr); Assert.Equal(expected, array); See Also GetChildren(Span<T>) SetChildren(ReadOnlySpan<T>, T) Set the immediate children of the value. Declaration T SetChildren(ReadOnlySpan<T> newChildren, T value) Parameters Type Name Description ReadOnlySpan<T> newChildren The new children. T value The old value, whose immediate children should be replaced. Returns Type Description T A copy of value with updated children. Remarks Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>, T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>, T) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, rewriter.SetChildren(Children.Two(new Lit(4), new Lit(5)), expr)); See Also SetChildren(ReadOnlySpan<T>) Extension Methods Rewriter.ChildrenInContext<T>(IRewriter<T>, T) Rewriter.Cursor<T>(IRewriter<T>, T) Rewriter.DescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, T) Rewriter.DescendantsAndSelfInContext<T>(IRewriter<T>, T) Rewriter.DescendantsAndSelf<T>(IRewriter<T>, T) Rewriter.Fold<T, U>(IRewriter<T>, SpanFunc<U, T, U>, T) Rewriter.Fold<T, U>(IRewriter<T>, Func<Memory<U>, T, ValueTask<U>>, T) Rewriter.GetChildren<T>(IRewriter<T>, T) Rewriter.ReplaceDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, T, T) Rewriter.RewriteChildren<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rewriter.RewriteChildren<T>(IRewriter<T>, Func<T, T>, T) Rewriter.RewriteDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, Func<T, ValueTask<T>>, T) Rewriter.RewriteDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, Func<T, T>, T) Rewriter.Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rewriter.Rewrite<T>(IRewriter<T>, Func<T, T>, T) Rewriter.SelfAndDescendantsBreadthFirst<T>(IRewriter<T>, T) Rewriter.SelfAndDescendantsInContextBreadthFirst<T>(IRewriter<T>, T) Rewriter.SelfAndDescendantsInContext<T>(IRewriter<T>, T) Rewriter.SelfAndDescendants<T>(IRewriter<T>, T) Rewriter.ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) Rewriter.ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) See Also IRewritable<T>"
  },
  "Sawmill.Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNodeExtensions.html": {
    "href": "Sawmill.Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNodeExtensions.html",
    "title": "Class CSharpSyntaxNodeExtensions | Benjamin.Pizza.DocTest",
    "keywords": "Class CSharpSyntaxNodeExtensions Extension methods for CSharpSyntaxNodes. Inheritance object CSharpSyntaxNodeExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public static class CSharpSyntaxNodeExtensions Methods ChildrenInContext(CSharpSyntaxNode) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. Declaration public static (CSharpSyntaxNode item, Func<CSharpSyntaxNode, CSharpSyntaxNode> replace)[] ChildrenInContext(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The value to get the contexts for the immediate children. Returns Type Description (CSharpSyntaxNode item, Func<CSharpSyntaxNode, CSharpSyntaxNode> replace)[] An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See Also SelfAndDescendantsInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) CountChildren(CSharpSyntaxNode) Count the immediate children of the value. Declaration public static int CountChildren(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The value. Returns Type Description int value's number of immediate children. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren(T) counts the immediate children of the topmost (Add) node. Assert.Equal(2, rewriter.CountChildren(expr)); See Also CountChildren() Cursor(CSharpSyntaxNode) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value. Declaration public static Cursor<CSharpSyntaxNode> Cursor(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The root node on which the newly created Cursor<T>(IRewriter<T>, T) should be focused. Returns Type Description Cursor<CSharpSyntaxNode> A Cursor<T>(IRewriter<T>, T) focused on the root node of value. DescendantAt(CSharpSyntaxNode, IEnumerable<Direction>) Returns the descendant at a particular location in value. Declaration public static CSharpSyntaxNode DescendantAt(this CSharpSyntaxNode value, IEnumerable<Direction> path) Parameters Type Name Description CSharpSyntaxNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Returns Type Description CSharpSyntaxNode The descendant found by following the directions in path. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelf(CSharpSyntaxNode) Yields all of the nodes in the tree represented by value, starting at the bottom. Declaration public static IEnumerable<CSharpSyntaxNode> DescendantsAndSelf(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The value to traverse. Returns Type Description IEnumerable<CSharpSyntaxNode> An enumerable containing all of the nodes in the tree represented by value, starting at the bottom. Remarks This is a depth-first post-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); See Also SelfAndDescendants<T>(IRewriter<T>, T) DescendantsAndSelfInContext(CSharpSyntaxNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(CSharpSyntaxNode item, Func<CSharpSyntaxNode, CSharpSyntaxNode> replace)> DescendantsAndSelfInContext(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(CSharpSyntaxNode item, Func<CSharpSyntaxNode, CSharpSyntaxNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See Also DescendantsAndSelf<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContext<T>(IRewriter<T>, T) Fold<T>(CSharpSyntaxNode, SpanFunc<T, CSharpSyntaxNode, T>) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static T Fold<T>(this CSharpSyntaxNode value, SpanFunc<T, CSharpSyntaxNode, T> func) Parameters Type Name Description CSharpSyntaxNode value The value to fold. SpanFunc<T, CSharpSyntaxNode, T> func The aggregation function. Returns Type Description T The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Fold<T>(CSharpSyntaxNode, Func<Memory<T>, CSharpSyntaxNode, ValueTask<T>>) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<T> Fold<T>(this CSharpSyntaxNode value, Func<Memory<T>, CSharpSyntaxNode, ValueTask<T>> func) Parameters Type Name Description CSharpSyntaxNode value The value to fold. Func<Memory<T>, CSharpSyntaxNode, ValueTask<T>> func The asynchronous aggregation function. Returns Type Description ValueTask<T> The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. GetChildren(CSharpSyntaxNode) Get the immediate children of the value. Declaration public static CSharpSyntaxNode[] GetChildren(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The value. Returns Type Description CSharpSyntaxNode[] The immediate children of value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); See Also GetChildren(Span<T>) GetChildren(CSharpSyntaxNode, Span<CSharpSyntaxNode>) Copy the immediate children of the value into childrenReceiver. Declaration public static void GetChildren(this CSharpSyntaxNode value, Span<CSharpSyntaxNode> childrenReceiver) Parameters Type Name Description CSharpSyntaxNode value The value. Span<CSharpSyntaxNode> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>, T) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[rewriter.CountChildren(expr)]; rewriter.GetChildren(array, expr); Assert.Equal(expected, array); See Also GetChildren(Span<T>) ReplaceDescendantAt<T>(CSharpSyntaxNode, IEnumerable<Direction>, CSharpSyntaxNode) Replaces the descendant at a particular location in value. Declaration public static CSharpSyntaxNode ReplaceDescendantAt<T>(this CSharpSyntaxNode value, IEnumerable<Direction> path, CSharpSyntaxNode newDescendant) Parameters Type Name Description CSharpSyntaxNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. CSharpSyntaxNode newDescendant The replacement descendant. Returns Type Description CSharpSyntaxNode A copy of value with newDescendant placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. Rewrite(CSharpSyntaxNode, Func<CSharpSyntaxNode, CSharpSyntaxNode>) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static CSharpSyntaxNode Rewrite(this CSharpSyntaxNode value, Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer) Parameters Type Name Description CSharpSyntaxNode value The value to rewrite. Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer The transformation function to apply to every node in the tree. Returns Type Description CSharpSyntaxNode The result of applying transformer to every node in the tree represented by value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); Rewrite(CSharpSyntaxNode, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>>) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<CSharpSyntaxNode> Rewrite(this CSharpSyntaxNode value, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer) Parameters Type Name Description CSharpSyntaxNode value The value to rewrite. Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer The asynchronous transformation function to apply to every node in the tree. Returns Type Description ValueTask<CSharpSyntaxNode> The result of applying transformer to every node in the tree represented by value. Remarks This method is not available on platforms which do not support ValueTask. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); RewriteChildren(CSharpSyntaxNode, Func<CSharpSyntaxNode, CSharpSyntaxNode>) Update the immediate children of the value by applying a transformation function to each one. Declaration public static CSharpSyntaxNode RewriteChildren(this CSharpSyntaxNode value, Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer) Parameters Type Name Description CSharpSyntaxNode value The old value, whose immediate children should be transformed by transformer. Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer A transformation function to apply to each of value's immediate children. Returns Type Description CSharpSyntaxNode A copy of value with updated children. RewriteChildren(CSharpSyntaxNode, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>>) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<CSharpSyntaxNode> RewriteChildren(this CSharpSyntaxNode value, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer) Parameters Type Name Description CSharpSyntaxNode value The old value, whose immediate children should be transformed by transformer. Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer An asynchronous transformation function to apply to each of value's immediate children. Returns Type Description ValueTask<CSharpSyntaxNode> A copy of value with updated children. Remarks This method is not available on platforms which do not support ValueTask. RewriteDescendantAt<T>(CSharpSyntaxNode, IEnumerable<Direction>, Func<CSharpSyntaxNode, CSharpSyntaxNode>) Apply a function at a particular location in value. Declaration public static CSharpSyntaxNode RewriteDescendantAt<T>(this CSharpSyntaxNode value, IEnumerable<Direction> path, Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer) Parameters Type Name Description CSharpSyntaxNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer A function to calculate a replacement for the descendant. Returns Type Description CSharpSyntaxNode A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(CSharpSyntaxNode, IEnumerable<Direction>, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>>) Apply an asynchronous function at a particular location in value. Declaration public static ValueTask<CSharpSyntaxNode> RewriteDescendantAt<T>(this CSharpSyntaxNode value, IEnumerable<Direction> path, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer) Parameters Type Name Description CSharpSyntaxNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer An asynchronous function to calculate a replacement for the descendant. Returns Type Description ValueTask<CSharpSyntaxNode> A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter(CSharpSyntaxNode, Func<CSharpSyntaxNode, CSharpSyntaxNode>) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static CSharpSyntaxNode RewriteIter(this CSharpSyntaxNode value, Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer) Parameters Type Name Description CSharpSyntaxNode value The value to rewrite. Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer A transformation function to apply to every node in value repeatedly. Returns Type Description CSharpSyntaxNode The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. RewriteIter(CSharpSyntaxNode, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>>) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<CSharpSyntaxNode> RewriteIter(this CSharpSyntaxNode value, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer) Parameters Type Name Description CSharpSyntaxNode value The value to rewrite. Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer An asynchronous transformation function to apply to every node in value repeatedly. Returns Type Description ValueTask<CSharpSyntaxNode> The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Remarks This method is not available on platforms which do not support ValueTask. SelfAndDescendants(CSharpSyntaxNode) Yields all of the nodes in the tree represented by value, starting at the top. Declaration public static IEnumerable<CSharpSyntaxNode> SelfAndDescendants(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The value to traverse. Returns Type Description IEnumerable<CSharpSyntaxNode> An enumerable containing all of the nodes in the tree represented by value, starting at the top. Remarks This is a depth-first pre-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); See Also DescendantsAndSelf<T>(IRewriter<T>, T) SelfAndDescendantsBreadthFirst(CSharpSyntaxNode) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<CSharpSyntaxNode> SelfAndDescendantsBreadthFirst(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The value to traverse. Returns Type Description IEnumerable<CSharpSyntaxNode> An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. SelfAndDescendantsInContext(CSharpSyntaxNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(CSharpSyntaxNode item, Func<CSharpSyntaxNode, CSharpSyntaxNode> replace)> SelfAndDescendantsInContext(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(CSharpSyntaxNode item, Func<CSharpSyntaxNode, CSharpSyntaxNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContextBreadthFirst(CSharpSyntaxNode) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(CSharpSyntaxNode item, Func<CSharpSyntaxNode, CSharpSyntaxNode> replace)> SelfAndDescendantsInContextBreadthFirst(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(CSharpSyntaxNode item, Func<CSharpSyntaxNode, CSharpSyntaxNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SetChildren(CSharpSyntaxNode, ReadOnlySpan<CSharpSyntaxNode>) Set the immediate children of the value. Declaration public static CSharpSyntaxNode SetChildren(this CSharpSyntaxNode value, ReadOnlySpan<CSharpSyntaxNode> newChildren) Parameters Type Name Description CSharpSyntaxNode value The old value, whose immediate children should be replaced. ReadOnlySpan<CSharpSyntaxNode> newChildren The new children. Returns Type Description CSharpSyntaxNode A copy of value with updated children. Remarks Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>, T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>, T) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, rewriter.SetChildren(Children.Two(new Lit(4), new Lit(5)), expr)); See Also SetChildren(ReadOnlySpan<T>) ZipFold<U>(CSharpSyntaxNode, CSharpSyntaxNode, Func<CSharpSyntaxNode, CSharpSyntaxNode, IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this CSharpSyntaxNode value1, CSharpSyntaxNode value2, Func<CSharpSyntaxNode, CSharpSyntaxNode, IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description CSharpSyntaxNode value1 CSharpSyntaxNode value2 Func<CSharpSyntaxNode, CSharpSyntaxNode, IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(CSharpSyntaxNode, CSharpSyntaxNode, Func<CSharpSyntaxNode, CSharpSyntaxNode, IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this CSharpSyntaxNode value1, CSharpSyntaxNode value2, Func<CSharpSyntaxNode, CSharpSyntaxNode, IEnumerable<U>, U> func) Parameters Type Name Description CSharpSyntaxNode value1 CSharpSyntaxNode value2 Func<CSharpSyntaxNode, CSharpSyntaxNode, IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(CSharpSyntaxNode[], Func<CSharpSyntaxNode[], IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this CSharpSyntaxNode[] values, Func<CSharpSyntaxNode[], IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description CSharpSyntaxNode[] values The trees to fold. Func<CSharpSyntaxNode[], IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(CSharpSyntaxNode[], Func<CSharpSyntaxNode[], IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this CSharpSyntaxNode[] values, Func<CSharpSyntaxNode[], IEnumerable<U>, U> func) Parameters Type Name Description CSharpSyntaxNode[] values The trees to fold. Func<CSharpSyntaxNode[], IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.Microsoft.CodeAnalysis.CSharp.html": {
    "href": "Sawmill.Microsoft.CodeAnalysis.CSharp.html",
    "title": "Namespace Sawmill.Microsoft.CodeAnalysis.CSharp | Benjamin.Pizza.DocTest",
    "keywords": "Namespace Sawmill.Microsoft.CodeAnalysis.CSharp Classes CSharpSyntaxNodeExtensions Extension methods for CSharpSyntaxNodes."
  },
  "Sawmill.Microsoft.CodeAnalysis.SyntaxNodeRewriter-1.html": {
    "href": "Sawmill.Microsoft.CodeAnalysis.SyntaxNodeRewriter-1.html",
    "title": "Class SyntaxNodeRewriter<T> | Benjamin.Pizza.DocTest",
    "keywords": "Class SyntaxNodeRewriter<T> An implementation of IRewriter<T> for subclasses of SyntaxNode. Inheritance object SyntaxNodeRewriter<T> Implements IRewriter<T> Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public class SyntaxNodeRewriter<T> : IRewriter<T> where T : SyntaxNode Type Parameters Name Description T The type of syntax node. Constructors SyntaxNodeRewriter() create a new instance of SyntaxNodeRewriter<T>. Declaration protected SyntaxNodeRewriter() Properties Instance Gets the single global instance of SyntaxNodeRewriter<T>. Declaration public static SyntaxNodeRewriter<T> Instance { get; } Property Value Type Description SyntaxNodeRewriter<T> The single global instance of SyntaxNodeRewriter<T>. Methods CountChildren(T) See CountChildren(T). Declaration public int CountChildren(T value) Parameters Type Name Description T value The value. Returns Type Description int value's number of immediate children. GetChildren(Span<T>, T) See GetChildren(Span<T>, T). Declaration public void GetChildren(Span<T> childrenReceiver, T value) Parameters Type Name Description Span<T> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(T). T value The value. SetChildren(ReadOnlySpan<T>, T) See SetChildren(ReadOnlySpan<T>, T). Declaration public T SetChildren(ReadOnlySpan<T> newChildren, T value) Parameters Type Name Description ReadOnlySpan<T> newChildren The new children. T value The old value, whose immediate children should be replaced. Returns Type Description T A copy of value with updated children. Implements IRewriter<T>"
  },
  "Sawmill.Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNodeExtensions.html": {
    "href": "Sawmill.Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNodeExtensions.html",
    "title": "Class VisualBasicSyntaxNodeExtensions | Benjamin.Pizza.DocTest",
    "keywords": "Class VisualBasicSyntaxNodeExtensions Extension methods for VisualBasicSyntaxNodes. Inheritance object VisualBasicSyntaxNodeExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public static class VisualBasicSyntaxNodeExtensions Methods ChildrenInContext(VisualBasicSyntaxNode) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. Declaration public static (VisualBasicSyntaxNode item, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> replace)[] ChildrenInContext(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The value to get the contexts for the immediate children. Returns Type Description (VisualBasicSyntaxNode item, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> replace)[] An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See Also SelfAndDescendantsInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) CountChildren(VisualBasicSyntaxNode) Count the immediate children of the value. Declaration public static int CountChildren(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The value. Returns Type Description int value's number of immediate children. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren(T) counts the immediate children of the topmost (Add) node. Assert.Equal(2, rewriter.CountChildren(expr)); See Also CountChildren() Cursor(VisualBasicSyntaxNode) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value. Declaration public static Cursor<VisualBasicSyntaxNode> Cursor(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The root node on which the newly created Cursor<T>(IRewriter<T>, T) should be focused. Returns Type Description Cursor<VisualBasicSyntaxNode> A Cursor<T>(IRewriter<T>, T) focused on the root node of value. DescendantAt(VisualBasicSyntaxNode, IEnumerable<Direction>) Returns the descendant at a particular location in value. Declaration public static VisualBasicSyntaxNode DescendantAt(this VisualBasicSyntaxNode value, IEnumerable<Direction> path) Parameters Type Name Description VisualBasicSyntaxNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Returns Type Description VisualBasicSyntaxNode The descendant found by following the directions in path. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelf(VisualBasicSyntaxNode) Yields all of the nodes in the tree represented by value, starting at the bottom. Declaration public static IEnumerable<VisualBasicSyntaxNode> DescendantsAndSelf(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The value to traverse. Returns Type Description IEnumerable<VisualBasicSyntaxNode> An enumerable containing all of the nodes in the tree represented by value, starting at the bottom. Remarks This is a depth-first post-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); See Also SelfAndDescendants<T>(IRewriter<T>, T) DescendantsAndSelfInContext(VisualBasicSyntaxNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(VisualBasicSyntaxNode item, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> replace)> DescendantsAndSelfInContext(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(VisualBasicSyntaxNode item, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See Also DescendantsAndSelf<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContext<T>(IRewriter<T>, T) Fold<T>(VisualBasicSyntaxNode, SpanFunc<T, VisualBasicSyntaxNode, T>) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static T Fold<T>(this VisualBasicSyntaxNode value, SpanFunc<T, VisualBasicSyntaxNode, T> func) Parameters Type Name Description VisualBasicSyntaxNode value The value to fold. SpanFunc<T, VisualBasicSyntaxNode, T> func The aggregation function. Returns Type Description T The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Fold<T>(VisualBasicSyntaxNode, Func<Memory<T>, VisualBasicSyntaxNode, ValueTask<T>>) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<T> Fold<T>(this VisualBasicSyntaxNode value, Func<Memory<T>, VisualBasicSyntaxNode, ValueTask<T>> func) Parameters Type Name Description VisualBasicSyntaxNode value The value to fold. Func<Memory<T>, VisualBasicSyntaxNode, ValueTask<T>> func The asynchronous aggregation function. Returns Type Description ValueTask<T> The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. GetChildren(VisualBasicSyntaxNode) Get the immediate children of the value. Declaration public static VisualBasicSyntaxNode[] GetChildren(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The value. Returns Type Description VisualBasicSyntaxNode[] The immediate children of value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); See Also GetChildren(Span<T>) GetChildren(VisualBasicSyntaxNode, Span<VisualBasicSyntaxNode>) Copy the immediate children of the value into childrenReceiver. Declaration public static void GetChildren(this VisualBasicSyntaxNode value, Span<VisualBasicSyntaxNode> childrenReceiver) Parameters Type Name Description VisualBasicSyntaxNode value The value. Span<VisualBasicSyntaxNode> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>, T) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[rewriter.CountChildren(expr)]; rewriter.GetChildren(array, expr); Assert.Equal(expected, array); See Also GetChildren(Span<T>) ReplaceDescendantAt<T>(VisualBasicSyntaxNode, IEnumerable<Direction>, VisualBasicSyntaxNode) Replaces the descendant at a particular location in value. Declaration public static VisualBasicSyntaxNode ReplaceDescendantAt<T>(this VisualBasicSyntaxNode value, IEnumerable<Direction> path, VisualBasicSyntaxNode newDescendant) Parameters Type Name Description VisualBasicSyntaxNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. VisualBasicSyntaxNode newDescendant The replacement descendant. Returns Type Description VisualBasicSyntaxNode A copy of value with newDescendant placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. Rewrite(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode>) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static VisualBasicSyntaxNode Rewrite(this VisualBasicSyntaxNode value, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer) Parameters Type Name Description VisualBasicSyntaxNode value The value to rewrite. Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer The transformation function to apply to every node in the tree. Returns Type Description VisualBasicSyntaxNode The result of applying transformer to every node in the tree represented by value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); Rewrite(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>>) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<VisualBasicSyntaxNode> Rewrite(this VisualBasicSyntaxNode value, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer) Parameters Type Name Description VisualBasicSyntaxNode value The value to rewrite. Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer The asynchronous transformation function to apply to every node in the tree. Returns Type Description ValueTask<VisualBasicSyntaxNode> The result of applying transformer to every node in the tree represented by value. Remarks This method is not available on platforms which do not support ValueTask. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); RewriteChildren(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode>) Update the immediate children of the value by applying a transformation function to each one. Declaration public static VisualBasicSyntaxNode RewriteChildren(this VisualBasicSyntaxNode value, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer) Parameters Type Name Description VisualBasicSyntaxNode value The old value, whose immediate children should be transformed by transformer. Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer A transformation function to apply to each of value's immediate children. Returns Type Description VisualBasicSyntaxNode A copy of value with updated children. RewriteChildren(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>>) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<VisualBasicSyntaxNode> RewriteChildren(this VisualBasicSyntaxNode value, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer) Parameters Type Name Description VisualBasicSyntaxNode value The old value, whose immediate children should be transformed by transformer. Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer An asynchronous transformation function to apply to each of value's immediate children. Returns Type Description ValueTask<VisualBasicSyntaxNode> A copy of value with updated children. Remarks This method is not available on platforms which do not support ValueTask. RewriteDescendantAt<T>(VisualBasicSyntaxNode, IEnumerable<Direction>, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode>) Apply a function at a particular location in value. Declaration public static VisualBasicSyntaxNode RewriteDescendantAt<T>(this VisualBasicSyntaxNode value, IEnumerable<Direction> path, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer) Parameters Type Name Description VisualBasicSyntaxNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer A function to calculate a replacement for the descendant. Returns Type Description VisualBasicSyntaxNode A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(VisualBasicSyntaxNode, IEnumerable<Direction>, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>>) Apply an asynchronous function at a particular location in value. Declaration public static ValueTask<VisualBasicSyntaxNode> RewriteDescendantAt<T>(this VisualBasicSyntaxNode value, IEnumerable<Direction> path, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer) Parameters Type Name Description VisualBasicSyntaxNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer An asynchronous function to calculate a replacement for the descendant. Returns Type Description ValueTask<VisualBasicSyntaxNode> A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode>) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static VisualBasicSyntaxNode RewriteIter(this VisualBasicSyntaxNode value, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer) Parameters Type Name Description VisualBasicSyntaxNode value The value to rewrite. Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer A transformation function to apply to every node in value repeatedly. Returns Type Description VisualBasicSyntaxNode The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. RewriteIter(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>>) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<VisualBasicSyntaxNode> RewriteIter(this VisualBasicSyntaxNode value, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer) Parameters Type Name Description VisualBasicSyntaxNode value The value to rewrite. Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer An asynchronous transformation function to apply to every node in value repeatedly. Returns Type Description ValueTask<VisualBasicSyntaxNode> The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Remarks This method is not available on platforms which do not support ValueTask. SelfAndDescendants(VisualBasicSyntaxNode) Yields all of the nodes in the tree represented by value, starting at the top. Declaration public static IEnumerable<VisualBasicSyntaxNode> SelfAndDescendants(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The value to traverse. Returns Type Description IEnumerable<VisualBasicSyntaxNode> An enumerable containing all of the nodes in the tree represented by value, starting at the top. Remarks This is a depth-first pre-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); See Also DescendantsAndSelf<T>(IRewriter<T>, T) SelfAndDescendantsBreadthFirst(VisualBasicSyntaxNode) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<VisualBasicSyntaxNode> SelfAndDescendantsBreadthFirst(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The value to traverse. Returns Type Description IEnumerable<VisualBasicSyntaxNode> An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. SelfAndDescendantsInContext(VisualBasicSyntaxNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(VisualBasicSyntaxNode item, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> replace)> SelfAndDescendantsInContext(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(VisualBasicSyntaxNode item, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContextBreadthFirst(VisualBasicSyntaxNode) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(VisualBasicSyntaxNode item, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> replace)> SelfAndDescendantsInContextBreadthFirst(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(VisualBasicSyntaxNode item, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SetChildren(VisualBasicSyntaxNode, ReadOnlySpan<VisualBasicSyntaxNode>) Set the immediate children of the value. Declaration public static VisualBasicSyntaxNode SetChildren(this VisualBasicSyntaxNode value, ReadOnlySpan<VisualBasicSyntaxNode> newChildren) Parameters Type Name Description VisualBasicSyntaxNode value The old value, whose immediate children should be replaced. ReadOnlySpan<VisualBasicSyntaxNode> newChildren The new children. Returns Type Description VisualBasicSyntaxNode A copy of value with updated children. Remarks Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>, T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>, T) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, rewriter.SetChildren(Children.Two(new Lit(4), new Lit(5)), expr)); See Also SetChildren(ReadOnlySpan<T>) ZipFold<U>(VisualBasicSyntaxNode, VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode, IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this VisualBasicSyntaxNode value1, VisualBasicSyntaxNode value2, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode, IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description VisualBasicSyntaxNode value1 VisualBasicSyntaxNode value2 Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode, IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(VisualBasicSyntaxNode, VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode, IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this VisualBasicSyntaxNode value1, VisualBasicSyntaxNode value2, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode, IEnumerable<U>, U> func) Parameters Type Name Description VisualBasicSyntaxNode value1 VisualBasicSyntaxNode value2 Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode, IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(VisualBasicSyntaxNode[], Func<VisualBasicSyntaxNode[], IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this VisualBasicSyntaxNode[] values, Func<VisualBasicSyntaxNode[], IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description VisualBasicSyntaxNode[] values The trees to fold. Func<VisualBasicSyntaxNode[], IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(VisualBasicSyntaxNode[], Func<VisualBasicSyntaxNode[], IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this VisualBasicSyntaxNode[] values, Func<VisualBasicSyntaxNode[], IEnumerable<U>, U> func) Parameters Type Name Description VisualBasicSyntaxNode[] values The trees to fold. Func<VisualBasicSyntaxNode[], IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.Microsoft.CodeAnalysis.VisualBasic.html": {
    "href": "Sawmill.Microsoft.CodeAnalysis.VisualBasic.html",
    "title": "Namespace Sawmill.Microsoft.CodeAnalysis.VisualBasic | Benjamin.Pizza.DocTest",
    "keywords": "Namespace Sawmill.Microsoft.CodeAnalysis.VisualBasic Classes VisualBasicSyntaxNodeExtensions Extension methods for VisualBasicSyntaxNodes."
  },
  "Sawmill.Microsoft.CodeAnalysis.html": {
    "href": "Sawmill.Microsoft.CodeAnalysis.html",
    "title": "Namespace Sawmill.Microsoft.CodeAnalysis | Benjamin.Pizza.DocTest",
    "keywords": "Namespace Sawmill.Microsoft.CodeAnalysis Classes SyntaxNodeRewriter<T> An implementation of IRewriter<T> for subclasses of SyntaxNode."
  },
  "Sawmill.Newtonsoft.Json.JTokenExtensions.html": {
    "href": "Sawmill.Newtonsoft.Json.JTokenExtensions.html",
    "title": "Class JTokenExtensions | Benjamin.Pizza.DocTest",
    "keywords": "Class JTokenExtensions Extension methods for Newtonsoft.Json.Linq.JTokens. Inheritance object JTokenExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public static class JTokenExtensions Methods ChildrenInContext(JToken) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. Declaration public static (JToken item, Func<JToken, JToken> replace)[] ChildrenInContext(this JToken value) Parameters Type Name Description JToken value The value to get the contexts for the immediate children. Returns Type Description (JToken item, Func<JToken, JToken> replace)[] An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See Also SelfAndDescendantsInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) CountChildren(JToken) Count the immediate children of the value. Declaration public static int CountChildren(this JToken value) Parameters Type Name Description JToken value The value. Returns Type Description int value's number of immediate children. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren(T) counts the immediate children of the topmost (Add) node. Assert.Equal(2, rewriter.CountChildren(expr)); See Also CountChildren() Cursor(JToken) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value. Declaration public static Cursor<JToken> Cursor(this JToken value) Parameters Type Name Description JToken value The root node on which the newly created Cursor<T>(IRewriter<T>, T) should be focused. Returns Type Description Cursor<JToken> A Cursor<T>(IRewriter<T>, T) focused on the root node of value. DescendantAt(JToken, IEnumerable<Direction>) Returns the descendant at a particular location in value. Declaration public static JToken DescendantAt(this JToken value, IEnumerable<Direction> path) Parameters Type Name Description JToken value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Returns Type Description JToken The descendant found by following the directions in path. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelf(JToken) Yields all of the nodes in the tree represented by value, starting at the bottom. Declaration public static IEnumerable<JToken> DescendantsAndSelf(this JToken value) Parameters Type Name Description JToken value The value to traverse. Returns Type Description IEnumerable<JToken> An enumerable containing all of the nodes in the tree represented by value, starting at the bottom. Remarks This is a depth-first post-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); See Also SelfAndDescendants<T>(IRewriter<T>, T) DescendantsAndSelfInContext(JToken) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(JToken item, Func<JToken, JToken> replace)> DescendantsAndSelfInContext(this JToken value) Parameters Type Name Description JToken value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(JToken item, Func<JToken, JToken> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See Also DescendantsAndSelf<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContext<T>(IRewriter<T>, T) Fold<T>(JToken, SpanFunc<T, JToken, T>) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static T Fold<T>(this JToken value, SpanFunc<T, JToken, T> func) Parameters Type Name Description JToken value The value to fold. SpanFunc<T, JToken, T> func The aggregation function. Returns Type Description T The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Fold<T>(JToken, Func<Memory<T>, JToken, ValueTask<T>>) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<T> Fold<T>(this JToken value, Func<Memory<T>, JToken, ValueTask<T>> func) Parameters Type Name Description JToken value The value to fold. Func<Memory<T>, JToken, ValueTask<T>> func The asynchronous aggregation function. Returns Type Description ValueTask<T> The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. GetChildren(JToken) Get the immediate children of the value. Declaration public static JToken[] GetChildren(this JToken value) Parameters Type Name Description JToken value The value. Returns Type Description JToken[] The immediate children of value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); See Also GetChildren(Span<T>) GetChildren(JToken, Span<JToken>) Copy the immediate children of the value into childrenReceiver. Declaration public static void GetChildren(this JToken value, Span<JToken> childrenReceiver) Parameters Type Name Description JToken value The value. Span<JToken> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>, T) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[rewriter.CountChildren(expr)]; rewriter.GetChildren(array, expr); Assert.Equal(expected, array); See Also GetChildren(Span<T>) ReplaceDescendantAt<T>(JToken, IEnumerable<Direction>, JToken) Replaces the descendant at a particular location in value. Declaration public static JToken ReplaceDescendantAt<T>(this JToken value, IEnumerable<Direction> path, JToken newDescendant) Parameters Type Name Description JToken value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. JToken newDescendant The replacement descendant. Returns Type Description JToken A copy of value with newDescendant placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. Rewrite(JToken, Func<JToken, JToken>) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static JToken Rewrite(this JToken value, Func<JToken, JToken> transformer) Parameters Type Name Description JToken value The value to rewrite. Func<JToken, JToken> transformer The transformation function to apply to every node in the tree. Returns Type Description JToken The result of applying transformer to every node in the tree represented by value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); Rewrite(JToken, Func<JToken, ValueTask<JToken>>) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<JToken> Rewrite(this JToken value, Func<JToken, ValueTask<JToken>> transformer) Parameters Type Name Description JToken value The value to rewrite. Func<JToken, ValueTask<JToken>> transformer The asynchronous transformation function to apply to every node in the tree. Returns Type Description ValueTask<JToken> The result of applying transformer to every node in the tree represented by value. Remarks This method is not available on platforms which do not support ValueTask. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); RewriteChildren(JToken, Func<JToken, JToken>) Update the immediate children of the value by applying a transformation function to each one. Declaration public static JToken RewriteChildren(this JToken value, Func<JToken, JToken> transformer) Parameters Type Name Description JToken value The old value, whose immediate children should be transformed by transformer. Func<JToken, JToken> transformer A transformation function to apply to each of value's immediate children. Returns Type Description JToken A copy of value with updated children. RewriteChildren(JToken, Func<JToken, ValueTask<JToken>>) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<JToken> RewriteChildren(this JToken value, Func<JToken, ValueTask<JToken>> transformer) Parameters Type Name Description JToken value The old value, whose immediate children should be transformed by transformer. Func<JToken, ValueTask<JToken>> transformer An asynchronous transformation function to apply to each of value's immediate children. Returns Type Description ValueTask<JToken> A copy of value with updated children. Remarks This method is not available on platforms which do not support ValueTask. RewriteDescendantAt<T>(JToken, IEnumerable<Direction>, Func<JToken, JToken>) Apply a function at a particular location in value. Declaration public static JToken RewriteDescendantAt<T>(this JToken value, IEnumerable<Direction> path, Func<JToken, JToken> transformer) Parameters Type Name Description JToken value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<JToken, JToken> transformer A function to calculate a replacement for the descendant. Returns Type Description JToken A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(JToken, IEnumerable<Direction>, Func<JToken, ValueTask<JToken>>) Apply an asynchronous function at a particular location in value. Declaration public static ValueTask<JToken> RewriteDescendantAt<T>(this JToken value, IEnumerable<Direction> path, Func<JToken, ValueTask<JToken>> transformer) Parameters Type Name Description JToken value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<JToken, ValueTask<JToken>> transformer An asynchronous function to calculate a replacement for the descendant. Returns Type Description ValueTask<JToken> A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter(JToken, Func<JToken, JToken>) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static JToken RewriteIter(this JToken value, Func<JToken, JToken> transformer) Parameters Type Name Description JToken value The value to rewrite. Func<JToken, JToken> transformer A transformation function to apply to every node in value repeatedly. Returns Type Description JToken The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. RewriteIter(JToken, Func<JToken, ValueTask<JToken>>) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<JToken> RewriteIter(this JToken value, Func<JToken, ValueTask<JToken>> transformer) Parameters Type Name Description JToken value The value to rewrite. Func<JToken, ValueTask<JToken>> transformer An asynchronous transformation function to apply to every node in value repeatedly. Returns Type Description ValueTask<JToken> The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Remarks This method is not available on platforms which do not support ValueTask. SelfAndDescendants(JToken) Yields all of the nodes in the tree represented by value, starting at the top. Declaration public static IEnumerable<JToken> SelfAndDescendants(this JToken value) Parameters Type Name Description JToken value The value to traverse. Returns Type Description IEnumerable<JToken> An enumerable containing all of the nodes in the tree represented by value, starting at the top. Remarks This is a depth-first pre-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); See Also DescendantsAndSelf<T>(IRewriter<T>, T) SelfAndDescendantsBreadthFirst(JToken) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<JToken> SelfAndDescendantsBreadthFirst(this JToken value) Parameters Type Name Description JToken value The value to traverse. Returns Type Description IEnumerable<JToken> An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. SelfAndDescendantsInContext(JToken) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(JToken item, Func<JToken, JToken> replace)> SelfAndDescendantsInContext(this JToken value) Parameters Type Name Description JToken value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(JToken item, Func<JToken, JToken> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContextBreadthFirst(JToken) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(JToken item, Func<JToken, JToken> replace)> SelfAndDescendantsInContextBreadthFirst(this JToken value) Parameters Type Name Description JToken value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(JToken item, Func<JToken, JToken> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SetChildren(JToken, ReadOnlySpan<JToken>) Set the immediate children of the value. Declaration public static JToken SetChildren(this JToken value, ReadOnlySpan<JToken> newChildren) Parameters Type Name Description JToken value The old value, whose immediate children should be replaced. ReadOnlySpan<JToken> newChildren The new children. Returns Type Description JToken A copy of value with updated children. Remarks Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>, T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>, T) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, rewriter.SetChildren(Children.Two(new Lit(4), new Lit(5)), expr)); See Also SetChildren(ReadOnlySpan<T>) ZipFold<U>(JToken, JToken, Func<JToken, JToken, IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this JToken value1, JToken value2, Func<JToken, JToken, IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description JToken value1 JToken value2 Func<JToken, JToken, IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(JToken, JToken, Func<JToken, JToken, IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this JToken value1, JToken value2, Func<JToken, JToken, IEnumerable<U>, U> func) Parameters Type Name Description JToken value1 JToken value2 Func<JToken, JToken, IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(JToken[], Func<JToken[], IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this JToken[] values, Func<JToken[], IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description JToken[] values The trees to fold. Func<JToken[], IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(JToken[], Func<JToken[], IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this JToken[] values, Func<JToken[], IEnumerable<U>, U> func) Parameters Type Name Description JToken[] values The trees to fold. Func<JToken[], IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.Newtonsoft.Json.JTokenRewriter.html": {
    "href": "Sawmill.Newtonsoft.Json.JTokenRewriter.html",
    "title": "Class JTokenRewriter | Benjamin.Pizza.DocTest",
    "keywords": "Class JTokenRewriter An implementation of IRewriter<T> for Newtonsoft.Json.Linq.JTokens. Inheritance object JTokenRewriter Implements IRewriter<JToken> Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public class JTokenRewriter : IRewriter<JToken> Constructors JTokenRewriter() Create a new instance of JTokenRewriter. Declaration protected JTokenRewriter() Properties Instance Gets the single global instance of JTokenRewriter. Declaration public static JTokenRewriter Instance { get; } Property Value Type Description JTokenRewriter The single global instance of JTokenRewriter. Methods CountChildren(JToken) See CountChildren(T). Declaration public int CountChildren(JToken value) Parameters Type Name Description JToken value The value. Returns Type Description int value's number of immediate children. GetChildren(Span<JToken>, JToken) See GetChildren(Span<T>, T). Declaration public void GetChildren(Span<JToken> childrenReceiver, JToken value) Parameters Type Name Description Span<JToken> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(JToken). JToken value The value. SetChildren(ReadOnlySpan<JToken>, JToken) See SetChildren(ReadOnlySpan<T>, T). Declaration public JToken SetChildren(ReadOnlySpan<JToken> newChildren, JToken value) Parameters Type Name Description ReadOnlySpan<JToken> newChildren The new children. JToken value The old value, whose immediate children should be replaced. Returns Type Description JToken A copy of value with updated children. Implements IRewriter<T>"
  },
  "Sawmill.Newtonsoft.Json.html": {
    "href": "Sawmill.Newtonsoft.Json.html",
    "title": "Namespace Sawmill.Newtonsoft.Json | Benjamin.Pizza.DocTest",
    "keywords": "Namespace Sawmill.Newtonsoft.Json Classes JTokenExtensions Extension methods for Newtonsoft.Json.Linq.JTokens. JTokenRewriter An implementation of IRewriter<T> for Newtonsoft.Json.Linq.JTokens."
  },
  "Sawmill.Rewritable.html": {
    "href": "Sawmill.Rewritable.html",
    "title": "Class Rewritable | Benjamin.Pizza.DocTest",
    "keywords": "Class Rewritable Extension methods for IRewritable<T> implementations. Inheritance object Rewritable Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public static class Rewritable Methods ChildrenInContext<T>(T) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. Declaration public static (T item, Func<T, T> replace)[] ChildrenInContext<T>(this T value) where T : IRewritable<T> Parameters Type Name Description T value The value to get the contexts for the immediate children. Returns Type Description (T item, Func<T, T> replace)[] An enumerable of contexts. Type Parameters Name Description T The rewritable tree type. Remarks The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See Also SelfAndDescendantsInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) Cursor<T>(T) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value. Declaration public static Cursor<T> Cursor<T>(this T value) where T : IRewritable<T> Parameters Type Name Description T value The root node on which the newly created Cursor<T>(IRewriter<T>, T) should be focused. Returns Type Description Cursor<T> A Cursor<T>(IRewriter<T>, T) focused on the root node of value. Type Parameters Name Description T The rewritable tree type. DescendantAt<T>(T, IEnumerable<Direction>) Returns the descendant at a particular location in value. Declaration public static T DescendantAt<T>(this T value, IEnumerable<Direction> path) where T : IRewritable<T> Parameters Type Name Description T value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Returns Type Description T The descendant found by following the directions in path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelfInContext<T>(T) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(T item, Func<T, T> replace)> DescendantsAndSelfInContext<T>(this T value) where T : IRewritable<T> Parameters Type Name Description T value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(T item, Func<T, T> replace)> An enumerable of contexts. Type Parameters Name Description T The rewritable tree type. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See Also DescendantsAndSelf<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContext<T>(IRewriter<T>, T) DescendantsAndSelf<T>(T) Yields all of the nodes in the tree represented by value, starting at the bottom. Declaration public static IEnumerable<T> DescendantsAndSelf<T>(this T value) where T : IRewritable<T> Parameters Type Name Description T value The value to traverse. Returns Type Description IEnumerable<T> An enumerable containing all of the nodes in the tree represented by value, starting at the bottom. Type Parameters Name Description T The rewritable tree type. Remarks This is a depth-first post-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); See Also SelfAndDescendants<T>(IRewriter<T>, T) Fold<T, U>(T, SpanFunc<U, T, U>) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static U Fold<T, U>(this T value, SpanFunc<U, T, U> func) where T : IRewritable<T> Parameters Type Name Description T value The value to fold. SpanFunc<U, T, U> func The aggregation function. Returns Type Description U The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. U The type of the result of aggregation. Fold<T, U>(T, Func<Memory<U>, T, ValueTask<U>>) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<U> Fold<T, U>(this T value, Func<Memory<U>, T, ValueTask<U>> func) where T : IRewritable<T> Parameters Type Name Description T value The value to fold. Func<Memory<U>, T, ValueTask<U>> func The asynchronous aggregation function. Returns Type Description ValueTask<U> The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. U The type of the result of aggregation. Remarks This method is not available on platforms which do not support ValueTask. GetChildren<T>(T) Get the immediate children of the value. Declaration public static T[] GetChildren<T>(this T value) where T : IRewritable<T> Parameters Type Name Description T value The value. Returns Type Description T[] The immediate children of value. Type Parameters Name Description T The rewritable tree type. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); See Also GetChildren(Span<T>) ReplaceDescendantAt<T>(T, IEnumerable<Direction>, T) Replaces the descendant at a particular location in value. Declaration public static T ReplaceDescendantAt<T>(this T value, IEnumerable<Direction> path, T newDescendant) where T : IRewritable<T> Parameters Type Name Description T value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. T newDescendant The replacement descendant. Returns Type Description T A copy of value with newDescendant placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteChildren<T>(T, Func<T, ValueTask<T>>) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<T> RewriteChildren<T>(this T value, Func<T, ValueTask<T>> transformer) where T : IRewritable<T> Parameters Type Name Description T value The old value, whose immediate children should be transformed by transformer. Func<T, ValueTask<T>> transformer An asynchronous transformation function to apply to each of value's immediate children. Returns Type Description ValueTask<T> A copy of value with updated children. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. RewriteChildren<T>(T, Func<T, T>) Update the immediate children of the value by applying a transformation function to each one. Declaration public static T RewriteChildren<T>(this T value, Func<T, T> transformer) where T : IRewritable<T> Parameters Type Name Description T value The old value, whose immediate children should be transformed by transformer. Func<T, T> transformer A transformation function to apply to each of value's immediate children. Returns Type Description T A copy of value with updated children. Type Parameters Name Description T The rewritable tree type. RewriteDescendantAt<T>(T, IEnumerable<Direction>, Func<T, ValueTask<T>>) Apply an asynchronous function at a particular location in value. Declaration public static ValueTask<T> RewriteDescendantAt<T>(this T value, IEnumerable<Direction> path, Func<T, ValueTask<T>> transformer) where T : IRewritable<T> Parameters Type Name Description T value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<T, ValueTask<T>> transformer An asynchronous function to calculate a replacement for the descendant. Returns Type Description ValueTask<T> A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(T, IEnumerable<Direction>, Func<T, T>) Apply a function at a particular location in value. Declaration public static T RewriteDescendantAt<T>(this T value, IEnumerable<Direction> path, Func<T, T> transformer) where T : IRewritable<T> Parameters Type Name Description T value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<T, T> transformer A function to calculate a replacement for the descendant. Returns Type Description T A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter<T>(T, Func<T, ValueTask<T>>) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<T> RewriteIter<T>(this T value, Func<T, ValueTask<T>> transformer) where T : class, IRewritable<T> Parameters Type Name Description T value The value to rewrite. Func<T, ValueTask<T>> transformer An asynchronous transformation function to apply to every node in value repeatedly. Returns Type Description ValueTask<T> The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. RewriteIter<T>(T, Func<T, T>) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static T RewriteIter<T>(this T value, Func<T, T> transformer) where T : class, IRewritable<T> Parameters Type Name Description T value The value to rewrite. Func<T, T> transformer A transformation function to apply to every node in value repeatedly. Returns Type Description T The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Type Parameters Name Description T The rewritable tree type. Rewrite<T>(T, Func<T, ValueTask<T>>) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<T> Rewrite<T>(this T value, Func<T, ValueTask<T>> transformer) where T : IRewritable<T> Parameters Type Name Description T value The value to rewrite. Func<T, ValueTask<T>> transformer The asynchronous transformation function to apply to every node in the tree. Returns Type Description ValueTask<T> The result of applying transformer to every node in the tree represented by value. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); Rewrite<T>(T, Func<T, T>) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static T Rewrite<T>(this T value, Func<T, T> transformer) where T : IRewritable<T> Parameters Type Name Description T value The value to rewrite. Func<T, T> transformer The transformation function to apply to every node in the tree. Returns Type Description T The result of applying transformer to every node in the tree represented by value. Type Parameters Name Description T The rewritable tree type. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); SelfAndDescendantsBreadthFirst<T>(T) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<T> SelfAndDescendantsBreadthFirst<T>(this T value) where T : IRewritable<T> Parameters Type Name Description T value The value to traverse. Returns Type Description IEnumerable<T> An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. Type Parameters Name Description T The rewritable tree type. SelfAndDescendantsInContextBreadthFirst<T>(T) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(T item, Func<T, T> replace)> SelfAndDescendantsInContextBreadthFirst<T>(this T value) where T : IRewritable<T> Parameters Type Name Description T value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(T item, Func<T, T> replace)> An enumerable of contexts. Type Parameters Name Description T The rewritable tree type. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContext<T>(T) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(T item, Func<T, T> replace)> SelfAndDescendantsInContext<T>(this T value) where T : IRewritable<T> Parameters Type Name Description T value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(T item, Func<T, T> replace)> An enumerable of contexts. Type Parameters Name Description T The rewritable tree type. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SelfAndDescendants<T>(T) Yields all of the nodes in the tree represented by value, starting at the top. Declaration public static IEnumerable<T> SelfAndDescendants<T>(this T value) where T : IRewritable<T> Parameters Type Name Description T value The value to traverse. Returns Type Description IEnumerable<T> An enumerable containing all of the nodes in the tree represented by value, starting at the top. Type Parameters Name Description T The rewritable tree type. Remarks This is a depth-first pre-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); See Also DescendantsAndSelf<T>(IRewriter<T>, T) ZipFold<T, U>(T, T, Func<T, T, IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<T, U>(this T value1, T value2, Func<T, T, IAsyncEnumerable<U>, ValueTask<U>> func) where T : IRewritable<T> Parameters Type Name Description T value1 T value2 Func<T, T, IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description T The rewritable tree type. U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<T, U>(T, T, Func<T, T, IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<T, U>(this T value1, T value2, Func<T, T, IEnumerable<U>, U> func) where T : IRewritable<T> Parameters Type Name Description T value1 T value2 Func<T, T, IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description T The rewritable tree type. U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<T, U>(T[], Func<T[], IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<T, U>(this T[] values, Func<T[], IAsyncEnumerable<U>, ValueTask<U>> func) where T : IRewritable<T> Parameters Type Name Description T[] values The trees to fold. Func<T[], IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description T The rewritable tree type. U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<T, U>(T[], Func<T[], IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<T, U>(this T[] values, Func<T[], IEnumerable<U>, U> func) where T : IRewritable<T> Parameters Type Name Description T[] values The trees to fold. Func<T[], IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description T The rewritable tree type. U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.RewritableRewriter-1.html": {
    "href": "Sawmill.RewritableRewriter-1.html",
    "title": "Class RewritableRewriter<T> | Benjamin.Pizza.DocTest",
    "keywords": "Class RewritableRewriter<T> An implementation of IRewriter<T> for Ts which implement IRewritable<T>. Inheritance object RewritableRewriter<T> Implements IRewriter<T> Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public class RewritableRewriter<T> : IRewriter<T> where T : IRewritable<T> Type Parameters Name Description T The rewritable tree type. Constructors RewritableRewriter() Create an instance of RewritableRewriter<T>. Declaration protected RewritableRewriter() Properties Instance Gets the single global instance of RewritableRewriter<T>. Declaration public static RewritableRewriter<T> Instance { get; } Property Value Type Description RewritableRewriter<T> Methods CountChildren(T) See CountChildren(T). Declaration public int CountChildren(T value) Parameters Type Name Description T value The rewritable tree. Returns Type Description int The value's number of immediate children. GetChildren(Span<T>, T) See GetChildren(Span<T>, T). Declaration public void GetChildren(Span<T> childrenReceiver, T value) Parameters Type Name Description Span<T> childrenReceiver A Span<T> to copy the current instance's immediate children into. The Span<T>'s Length should be equal to the number returned by CountChildren(T). T value The rewritable tree. SetChildren(ReadOnlySpan<T>, T) See SetChildren(ReadOnlySpan<T>, T). Declaration public T SetChildren(ReadOnlySpan<T> newChildren, T value) Parameters Type Name Description ReadOnlySpan<T> newChildren The new children. T value The rewritable tree. Returns Type Description T A copy of value with updated children. Implements IRewriter<T> Extension Methods Rewriter.ChildrenInContext<T>(IRewriter<T>, T) Rewriter.Cursor<T>(IRewriter<T>, T) Rewriter.DescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, T) Rewriter.DescendantsAndSelfInContext<T>(IRewriter<T>, T) Rewriter.DescendantsAndSelf<T>(IRewriter<T>, T) Rewriter.Fold<T, U>(IRewriter<T>, SpanFunc<U, T, U>, T) Rewriter.Fold<T, U>(IRewriter<T>, Func<Memory<U>, T, ValueTask<U>>, T) Rewriter.GetChildren<T>(IRewriter<T>, T) Rewriter.ReplaceDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, T, T) Rewriter.RewriteChildren<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rewriter.RewriteChildren<T>(IRewriter<T>, Func<T, T>, T) Rewriter.RewriteDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, Func<T, ValueTask<T>>, T) Rewriter.RewriteDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, Func<T, T>, T) Rewriter.Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rewriter.Rewrite<T>(IRewriter<T>, Func<T, T>, T) Rewriter.SelfAndDescendantsBreadthFirst<T>(IRewriter<T>, T) Rewriter.SelfAndDescendantsInContextBreadthFirst<T>(IRewriter<T>, T) Rewriter.SelfAndDescendantsInContext<T>(IRewriter<T>, T) Rewriter.SelfAndDescendants<T>(IRewriter<T>, T) Rewriter.ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) Rewriter.ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[])"
  },
  "Sawmill.Rewriter.html": {
    "href": "Sawmill.Rewriter.html",
    "title": "Class Rewriter | Benjamin.Pizza.DocTest",
    "keywords": "Class Rewriter Extension methods for IRewriter<T> implementations. Inheritance object Rewriter Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public static class Rewriter Methods ChildrenInContext<T>(IRewriter<T>, T) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. Declaration public static (T item, Func<T, T> replace)[] ChildrenInContext<T>(this IRewriter<T> rewriter, T value) Parameters Type Name Description IRewriter<T> rewriter The rewriter. T value The value to get the contexts for the immediate children. Returns Type Description (T item, Func<T, T> replace)[] An enumerable of contexts. Type Parameters Name Description T The rewritable tree type. Remarks The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See Also SelfAndDescendantsInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) Cursor<T>(IRewriter<T>, T) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value. Declaration public static Cursor<T> Cursor<T>(this IRewriter<T> rewriter, T value) Parameters Type Name Description IRewriter<T> rewriter The rewriter. T value The root node on which the newly created Cursor<T>(IRewriter<T>, T) should be focused. Returns Type Description Cursor<T> A Cursor<T>(IRewriter<T>, T) focused on the root node of value. Type Parameters Name Description T The rewritable tree type. DescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, T) Returns the descendant at a particular location in value. Declaration public static T DescendantAt<T>(this IRewriter<T> rewriter, IEnumerable<Direction> path, T value) Parameters Type Name Description IRewriter<T> rewriter The rewriter. IEnumerable<Direction> path The route to take to find the descendant. T value The rewritable tree. Returns Type Description T The descendant found by following the directions in path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelfInContext<T>(IRewriter<T>, T) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(T item, Func<T, T> replace)> DescendantsAndSelfInContext<T>(this IRewriter<T> rewriter, T value) Parameters Type Name Description IRewriter<T> rewriter The rewriter. T value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(T item, Func<T, T> replace)> An enumerable of contexts. Type Parameters Name Description T The rewritable tree type. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See Also DescendantsAndSelf<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContext<T>(IRewriter<T>, T) DescendantsAndSelf<T>(IRewriter<T>, T) Yields all of the nodes in the tree represented by value, starting at the bottom. Declaration public static IEnumerable<T> DescendantsAndSelf<T>(this IRewriter<T> rewriter, T value) Parameters Type Name Description IRewriter<T> rewriter The rewriter. T value The value to traverse. Returns Type Description IEnumerable<T> An enumerable containing all of the nodes in the tree represented by value, starting at the bottom. Type Parameters Name Description T The rewritable tree type. Remarks This is a depth-first post-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); See Also SelfAndDescendants<T>(IRewriter<T>, T) Fold<T, U>(IRewriter<T>, SpanFunc<U, T, U>, T) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static U Fold<T, U>(this IRewriter<T> rewriter, SpanFunc<U, T, U> func, T value) Parameters Type Name Description IRewriter<T> rewriter The rewriter. SpanFunc<U, T, U> func The aggregation function. T value The value to fold. Returns Type Description U The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. U The type of the result of aggregation. Fold<T, U>(IRewriter<T>, Func<Memory<U>, T, ValueTask<U>>, T) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<U> Fold<T, U>(this IRewriter<T> rewriter, Func<Memory<U>, T, ValueTask<U>> func, T value) Parameters Type Name Description IRewriter<T> rewriter The rewriter. Func<Memory<U>, T, ValueTask<U>> func The asynchronous aggregation function. T value The value to fold. Returns Type Description ValueTask<U> The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. U The type of the result of aggregation. Remarks This method is not available on platforms which do not support ValueTask. GetChildren<T>(IRewriter<T>, T) Get the immediate children of the value. Declaration public static T[] GetChildren<T>(this IRewriter<T> rewriter, T value) Parameters Type Name Description IRewriter<T> rewriter The rewriter. T value The value. Returns Type Description T[] The immediate children of value. Type Parameters Name Description T The rewritable tree type. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); See Also GetChildren(Span<T>) ReplaceDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, T, T) Replaces the descendant at a particular location in value. Declaration public static T ReplaceDescendantAt<T>(this IRewriter<T> rewriter, IEnumerable<Direction> path, T newDescendant, T value) Parameters Type Name Description IRewriter<T> rewriter The rewriter. IEnumerable<Direction> path The route to take to find the descendant. T newDescendant The replacement descendant. T value The rewritable tree. Returns Type Description T A copy of value with newDescendant placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteChildren<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<T> RewriteChildren<T>(this IRewriter<T> rewriter, Func<T, ValueTask<T>> transformer, T value) Parameters Type Name Description IRewriter<T> rewriter The rewriter. Func<T, ValueTask<T>> transformer An asynchronous transformation function to apply to each of value's immediate children. T value The old value, whose immediate children should be transformed by transformer. Returns Type Description ValueTask<T> A copy of value with updated children. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. RewriteChildren<T>(IRewriter<T>, Func<T, T>, T) Update the immediate children of the value by applying a transformation function to each one. Declaration public static T RewriteChildren<T>(this IRewriter<T> rewriter, Func<T, T> transformer, T value) Parameters Type Name Description IRewriter<T> rewriter The rewriter. Func<T, T> transformer A transformation function to apply to each of value's immediate children. T value The old value, whose immediate children should be transformed by transformer. Returns Type Description T A copy of value with updated children. Type Parameters Name Description T The rewritable tree type. RewriteDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, Func<T, ValueTask<T>>, T) Apply an asynchronous function at a particular location in value. Declaration public static ValueTask<T> RewriteDescendantAt<T>(this IRewriter<T> rewriter, IEnumerable<Direction> path, Func<T, ValueTask<T>> transformer, T value) Parameters Type Name Description IRewriter<T> rewriter The rewriter. IEnumerable<Direction> path The route to take to find the descendant. Func<T, ValueTask<T>> transformer An asynchronous function to calculate a replacement for the descendant. T value The rewritable tree. Returns Type Description ValueTask<T> A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, Func<T, T>, T) Apply a function at a particular location in value. Declaration public static T RewriteDescendantAt<T>(this IRewriter<T> rewriter, IEnumerable<Direction> path, Func<T, T> transformer, T value) Parameters Type Name Description IRewriter<T> rewriter The rewriter. IEnumerable<Direction> path The route to take to find the descendant. Func<T, T> transformer A function to calculate a replacement for the descendant. T value The rewritable tree. Returns Type Description T A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<T> RewriteIter<T>(this IRewriter<T> rewriter, Func<T, ValueTask<T>> transformer, T value) where T : class Parameters Type Name Description IRewriter<T> rewriter The rewriter. Func<T, ValueTask<T>> transformer An asynchronous transformation function to apply to every node in value repeatedly. T value The value to rewrite. Returns Type Description ValueTask<T> The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. RewriteIter<T>(IRewriter<T>, Func<T, T>, T) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static T RewriteIter<T>(this IRewriter<T> rewriter, Func<T, T> transformer, T value) where T : class Parameters Type Name Description IRewriter<T> rewriter The rewriter. Func<T, T> transformer A transformation function to apply to every node in value repeatedly. T value The value to rewrite. Returns Type Description T The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Type Parameters Name Description T The rewritable tree type. Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<T> Rewrite<T>(this IRewriter<T> rewriter, Func<T, ValueTask<T>> transformer, T value) Parameters Type Name Description IRewriter<T> rewriter The rewriter. Func<T, ValueTask<T>> transformer The asynchronous transformation function to apply to every node in the tree. T value The value to rewrite. Returns Type Description ValueTask<T> The result of applying transformer to every node in the tree represented by value. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); Rewrite<T>(IRewriter<T>, Func<T, T>, T) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static T Rewrite<T>(this IRewriter<T> rewriter, Func<T, T> transformer, T value) Parameters Type Name Description IRewriter<T> rewriter The rewriter. Func<T, T> transformer The transformation function to apply to every node in the tree. T value The value to rewrite. Returns Type Description T The result of applying transformer to every node in the tree represented by value. Type Parameters Name Description T The rewritable tree type. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); SelfAndDescendantsBreadthFirst<T>(IRewriter<T>, T) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<T> SelfAndDescendantsBreadthFirst<T>(this IRewriter<T> rewriter, T value) Parameters Type Name Description IRewriter<T> rewriter The rewriter. T value The value to traverse. Returns Type Description IEnumerable<T> An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. Type Parameters Name Description T The rewritable tree type. SelfAndDescendantsInContextBreadthFirst<T>(IRewriter<T>, T) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(T item, Func<T, T> replace)> SelfAndDescendantsInContextBreadthFirst<T>(this IRewriter<T> rewriter, T value) Parameters Type Name Description IRewriter<T> rewriter The rewriter. T value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(T item, Func<T, T> replace)> An enumerable of contexts. Type Parameters Name Description T The rewritable tree type. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContext<T>(IRewriter<T>, T) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(T item, Func<T, T> replace)> SelfAndDescendantsInContext<T>(this IRewriter<T> rewriter, T value) Parameters Type Name Description IRewriter<T> rewriter The rewriter. T value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(T item, Func<T, T> replace)> An enumerable of contexts. Type Parameters Name Description T The rewritable tree type. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SelfAndDescendants<T>(IRewriter<T>, T) Yields all of the nodes in the tree represented by value, starting at the top. Declaration public static IEnumerable<T> SelfAndDescendants<T>(this IRewriter<T> rewriter, T value) Parameters Type Name Description IRewriter<T> rewriter The rewriter. T value The value to traverse. Returns Type Description IEnumerable<T> An enumerable containing all of the nodes in the tree represented by value, starting at the top. Type Parameters Name Description T The rewritable tree type. Remarks This is a depth-first pre-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); See Also DescendantsAndSelf<T>(IRewriter<T>, T) ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<T, U>(this IRewriter<T> rewriter, Func<T[], IAsyncEnumerable<U>, ValueTask<U>> func, params T[] values) Parameters Type Name Description IRewriter<T> rewriter The rewriter. Func<T[], IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. T[] values The trees to fold. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description T The rewritable tree type. U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<T, U>(this IRewriter<T> rewriter, Func<T[], IEnumerable<U>, U> func, params T[] values) Parameters Type Name Description IRewriter<T> rewriter The rewriter. Func<T[], IEnumerable<U>, U> func The aggregation function. T[] values The trees to fold. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description T The rewritable tree type. U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.RewriterBuilder-1.html": {
    "href": "Sawmill.RewriterBuilder-1.html",
    "title": "Class RewriterBuilder<T> | Benjamin.Pizza.DocTest",
    "keywords": "Class RewriterBuilder<T> Tools for building rewriters. Inheritance object RewriterBuilder<T> Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public class RewriterBuilder<T> Type Parameters Name Description T The rewritable tree type. Methods Build() Build a rewriter. Declaration public IRewriter<T> Build() Returns Type Description IRewriter<T> A rewriter. Case<TSub>(Func<RewriterBuilderCase<object, T, TSub>, IRewriter<T>>) Handle a single subclass of T. Declaration public RewriterBuilder<T> Case<TSub>(Func<RewriterBuilderCase<object, T, TSub>, IRewriter<T>> builderAction) where TSub : T Parameters Type Name Description Func<RewriterBuilderCase<object, T, TSub>, IRewriter<T>> builderAction The action defining the builder for this subclass. Returns Type Description RewriterBuilder<T> A RewriterBuilder<T>. Type Parameters Name Description TSub The concrete subclass type."
  },
  "Sawmill.RewriterBuilder.html": {
    "href": "Sawmill.RewriterBuilder.html",
    "title": "Class RewriterBuilder | Benjamin.Pizza.DocTest",
    "keywords": "Class RewriterBuilder Tools for building rewriters. Inheritance object RewriterBuilder Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public static class RewriterBuilder Methods For<T>() Create a new RewriterBuilder<T>. Declaration public static RewriterBuilder<T> For<T>() Returns Type Description RewriterBuilder<T> A RewriterBuilder<T>. Type Parameters Name Description T The rewritable tree type."
  },
  "Sawmill.RewriterBuilderCase-3.html": {
    "href": "Sawmill.RewriterBuilderCase-3.html",
    "title": "Class RewriterBuilderCase<TArgs, TBase, TSub> | Benjamin.Pizza.DocTest",
    "keywords": "Class RewriterBuilderCase<TArgs, TBase, TSub> Tools for building rewriters for a single subclass of a base type. Inheritance object RewriterBuilderCase<TArgs, TBase, TSub> Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public sealed class RewriterBuilderCase<TArgs, TBase, TSub> Type Parameters Name Description TArgs The constructor arguments. TBase The rewritable tree type. TSub The sublcass which this case handles. Methods Child(Func<TSub, TBase>) Select an immediate child. Declaration public RewriterBuilderCase<(TArgs Args, TBase Child), TBase, TSub> Child(Func<TSub, TBase> child) Parameters Type Name Description Func<TSub, TBase> child The child selector. Returns Type Description RewriterBuilderCase<(TArgs Args, TBase Child), TBase, TSub> A copy of this RewriterBuilderCase with an additional constructor argument. Children(Func<TSub, ImmutableList<TBase>>) Select a list of children. Declaration public RewriterBuilderCase<(TArgs Args, ImmutableList<TBase> Children), TBase, TSub> Children(Func<TSub, ImmutableList<TBase>> children) Parameters Type Name Description Func<TSub, ImmutableList<TBase>> children The children selector. Returns Type Description RewriterBuilderCase<(TArgs Args, ImmutableList<TBase> Children), TBase, TSub> A copy of this RewriterBuilderCase with an additional constructor argument. Field<U>(Func<TSub, U>) Select a field from the subclass. Declaration public RewriterBuilderCase<(TArgs Args, U Field), TBase, TSub> Field<U>(Func<TSub, U> field) Parameters Type Name Description Func<TSub, U> field The field selector. Returns Type Description RewriterBuilderCase<(TArgs Args, U Field), TBase, TSub> A copy of this RewriterBuilderCase with an additional constructor argument. Type Parameters Name Description U The field type."
  },
  "Sawmill.RewriterBuilderCase.html": {
    "href": "Sawmill.RewriterBuilderCase.html",
    "title": "Class RewriterBuilderCase | Benjamin.Pizza.DocTest",
    "keywords": "Class RewriterBuilderCase Tools for building rewriters for a single subclass of a base type. Inheritance object RewriterBuilderCase Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public static class RewriterBuilderCase Methods ConstructWith<U1, U2, U3, U4, U5, U6, U7, U8, TBase, TSub>(RewriterBuilderCase<((((((((object, U1), U2), U3), U4), U5), U6), U7), U8), TBase, TSub>, Func<U1, U2, U3, U4, U5, U6, U7, U8, TSub>) Rebuild the subtype with the supplied function, after flattening the tuple. Declaration public static IRewriter<TBase> ConstructWith<U1, U2, U3, U4, U5, U6, U7, U8, TBase, TSub>(this RewriterBuilderCase<((((((((object, U1), U2), U3), U4), U5), U6), U7), U8), TBase, TSub> builder, Func<U1, U2, U3, U4, U5, U6, U7, U8, TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase<((((((((object, U1), U2), U3), U4), U5), U6), U7), U8), TBase, TSub> builder The builder. Func<U1, U2, U3, U4, U5, U6, U7, U8, TSub> constructor The constructor function. Returns Type Description IRewriter<TBase> A rewriter. Type Parameters Name Description U1 Constructor argument 1. U2 Constructor argument 2. U3 Constructor argument 3. U4 Constructor argument 4. U5 Constructor argument 5. U6 Constructor argument 6. U7 Constructor argument 7. U8 Constructor argument 8. TBase The rewritable tree type. TSub The subtype. ConstructWith<TBase, TSub>(RewriterBuilderCase<object, TBase, TSub>, Func<TSub>) Rebuild the subtype with the supplied function. Declaration public static IRewriter<TBase> ConstructWith<TBase, TSub>(this RewriterBuilderCase<object, TBase, TSub> builder, Func<TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase<object, TBase, TSub> builder The builder. Func<TSub> constructor The constructor function. Returns Type Description IRewriter<TBase> A rewriter. Type Parameters Name Description TBase The rewritable tree type. TSub The subtype. ConstructWith<U1, TBase, TSub>(RewriterBuilderCase<(object, U1), TBase, TSub>, Func<U1, TSub>) Rebuild the subtype with the supplied function, after flattening the tuple. Declaration public static IRewriter<TBase> ConstructWith<U1, TBase, TSub>(this RewriterBuilderCase<(object, U1), TBase, TSub> builder, Func<U1, TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase<(object, U1), TBase, TSub> builder The builder. Func<U1, TSub> constructor The constructor function. Returns Type Description IRewriter<TBase> A rewriter. Type Parameters Name Description U1 Constructor argument 1. TBase The rewritable tree type. TSub The subtype. ConstructWith<T, TBase, TSub>(RewriterBuilderCase<T, TBase, TSub>, Func<T, TSub>) Rebuild the subtype with the supplied function. Declaration public static IRewriter<TBase> ConstructWith<T, TBase, TSub>(this RewriterBuilderCase<T, TBase, TSub> builder, Func<T, TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase<T, TBase, TSub> builder The builder. Func<T, TSub> constructor The constructor function. Returns Type Description IRewriter<TBase> A rewriter. Type Parameters Name Description T The arguments of the builder. TBase The rewritable tree type. TSub The subtype. ConstructWith<U1, U2, TBase, TSub>(RewriterBuilderCase<((object, U1), U2), TBase, TSub>, Func<U1, U2, TSub>) Rebuild the subtype with the supplied function, after flattening the tuple. Declaration public static IRewriter<TBase> ConstructWith<U1, U2, TBase, TSub>(this RewriterBuilderCase<((object, U1), U2), TBase, TSub> builder, Func<U1, U2, TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase<((object, U1), U2), TBase, TSub> builder The builder. Func<U1, U2, TSub> constructor The constructor function. Returns Type Description IRewriter<TBase> A rewriter. Type Parameters Name Description U1 Constructor argument 1. U2 Constructor argument 2. TBase The rewritable tree type. TSub The subtype. ConstructWith<U1, U2, U3, TBase, TSub>(RewriterBuilderCase<(((object, U1), U2), U3), TBase, TSub>, Func<U1, U2, U3, TSub>) Rebuild the subtype with the supplied function, after flattening the tuple. Declaration public static IRewriter<TBase> ConstructWith<U1, U2, U3, TBase, TSub>(this RewriterBuilderCase<(((object, U1), U2), U3), TBase, TSub> builder, Func<U1, U2, U3, TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase<(((object, U1), U2), U3), TBase, TSub> builder The builder. Func<U1, U2, U3, TSub> constructor The constructor function. Returns Type Description IRewriter<TBase> A rewriter. Type Parameters Name Description U1 Constructor argument 1. U2 Constructor argument 2. U3 Constructor argument 3. TBase The rewritable tree type. TSub The subtype. ConstructWith<U1, U2, U3, U4, TBase, TSub>(RewriterBuilderCase<((((object, U1), U2), U3), U4), TBase, TSub>, Func<U1, U2, U3, U4, TSub>) Rebuild the subtype with the supplied function, after flattening the tuple. Declaration public static IRewriter<TBase> ConstructWith<U1, U2, U3, U4, TBase, TSub>(this RewriterBuilderCase<((((object, U1), U2), U3), U4), TBase, TSub> builder, Func<U1, U2, U3, U4, TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase<((((object, U1), U2), U3), U4), TBase, TSub> builder The builder. Func<U1, U2, U3, U4, TSub> constructor The constructor function. Returns Type Description IRewriter<TBase> A rewriter. Type Parameters Name Description U1 Constructor argument 1. U2 Constructor argument 2. U3 Constructor argument 3. U4 Constructor argument 4. TBase The rewritable tree type. TSub The subtype. ConstructWith<U1, U2, U3, U4, U5, TBase, TSub>(RewriterBuilderCase<(((((object, U1), U2), U3), U4), U5), TBase, TSub>, Func<U1, U2, U3, U4, U5, TSub>) Rebuild the subtype with the supplied function, after flattening the tuple. Declaration public static IRewriter<TBase> ConstructWith<U1, U2, U3, U4, U5, TBase, TSub>(this RewriterBuilderCase<(((((object, U1), U2), U3), U4), U5), TBase, TSub> builder, Func<U1, U2, U3, U4, U5, TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase<(((((object, U1), U2), U3), U4), U5), TBase, TSub> builder The builder. Func<U1, U2, U3, U4, U5, TSub> constructor The constructor function. Returns Type Description IRewriter<TBase> A rewriter. Type Parameters Name Description U1 Constructor argument 1. U2 Constructor argument 2. U3 Constructor argument 3. U4 Constructor argument 4. U5 Constructor argument 5. TBase The rewritable tree type. TSub The subtype. ConstructWith<U1, U2, U3, U4, U5, U6, TBase, TSub>(RewriterBuilderCase<((((((object, U1), U2), U3), U4), U5), U6), TBase, TSub>, Func<U1, U2, U3, U4, U5, U6, TSub>) Rebuild the subtype with the supplied function, after flattening the tuple. Declaration public static IRewriter<TBase> ConstructWith<U1, U2, U3, U4, U5, U6, TBase, TSub>(this RewriterBuilderCase<((((((object, U1), U2), U3), U4), U5), U6), TBase, TSub> builder, Func<U1, U2, U3, U4, U5, U6, TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase<((((((object, U1), U2), U3), U4), U5), U6), TBase, TSub> builder The builder. Func<U1, U2, U3, U4, U5, U6, TSub> constructor The constructor function. Returns Type Description IRewriter<TBase> A rewriter. Type Parameters Name Description U1 Constructor argument 1. U2 Constructor argument 2. U3 Constructor argument 3. U4 Constructor argument 4. U5 Constructor argument 5. U6 Constructor argument 6. TBase The rewritable tree type. TSub The subtype. ConstructWith<U1, U2, U3, U4, U5, U6, U7, TBase, TSub>(RewriterBuilderCase<(((((((object, U1), U2), U3), U4), U5), U6), U7), TBase, TSub>, Func<U1, U2, U3, U4, U5, U6, U7, TSub>) Rebuild the subtype with the supplied function, after flattening the tuple. Declaration public static IRewriter<TBase> ConstructWith<U1, U2, U3, U4, U5, U6, U7, TBase, TSub>(this RewriterBuilderCase<(((((((object, U1), U2), U3), U4), U5), U6), U7), TBase, TSub> builder, Func<U1, U2, U3, U4, U5, U6, U7, TSub> constructor) where TSub : TBase Parameters Type Name Description RewriterBuilderCase<(((((((object, U1), U2), U3), U4), U5), U6), U7), TBase, TSub> builder The builder. Func<U1, U2, U3, U4, U5, U6, U7, TSub> constructor The constructor function. Returns Type Description IRewriter<TBase> A rewriter. Type Parameters Name Description U1 Constructor argument 1. U2 Constructor argument 2. U3 Constructor argument 3. U4 Constructor argument 4. U5 Constructor argument 5. U6 Constructor argument 6. U7 Constructor argument 7. TBase The rewritable tree type. TSub The subtype."
  },
  "Sawmill.SpanFunc-3.html": {
    "href": "Sawmill.SpanFunc-3.html",
    "title": "Delegate SpanFunc<T, U, R> | Benjamin.Pizza.DocTest",
    "keywords": "Delegate SpanFunc<T, U, R> A Func<T1, T2, TResult> whose first argument is a Span<T>. Declaration public delegate R SpanFunc<T, in U, out R>(Span<T> span, U arg) Type Parameters Name Description T The type of elements in the span. U The type of the additional argument. R The return type. Constructors SpanFunc(object, IntPtr) A Func<T1, T2, TResult> whose first argument is a Span<T>. Declaration public SpanFunc(object @object, IntPtr method) Parameters Type Name Description object object IntPtr method Methods BeginInvoke(Span<T>, U, AsyncCallback, object) A Func<T1, T2, TResult> whose first argument is a Span<T>. Declaration public virtual IAsyncResult BeginInvoke(Span<T> span, U arg, AsyncCallback callback, object @object) Parameters Type Name Description Span<T> span U arg AsyncCallback callback object object Returns Type Description IAsyncResult EndInvoke(IAsyncResult) A Func<T1, T2, TResult> whose first argument is a Span<T>. Declaration public virtual R EndInvoke(IAsyncResult result) Parameters Type Name Description IAsyncResult result Returns Type Description R Invoke(Span<T>, U) A Func<T1, T2, TResult> whose first argument is a Span<T>. Declaration public virtual R Invoke(Span<T> span, U arg) Parameters Type Name Description Span<T> span U arg Returns Type Description R"
  },
  "Sawmill.Xml.XElementExtensions.html": {
    "href": "Sawmill.Xml.XElementExtensions.html",
    "title": "Class XElementExtensions | Benjamin.Pizza.DocTest",
    "keywords": "Class XElementExtensions Extension methods for System.Xml.Linq.XElements. Inheritance object XElementExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public static class XElementExtensions Methods ChildrenInContext(XElement) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. Declaration public static (XElement item, Func<XElement, XElement> replace)[] ChildrenInContext(this XElement value) Parameters Type Name Description XElement value The value to get the contexts for the immediate children. Returns Type Description (XElement item, Func<XElement, XElement> replace)[] An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See Also SelfAndDescendantsInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) CountChildren(XElement) Count the immediate children of the value. Declaration public static int CountChildren(this XElement value) Parameters Type Name Description XElement value The value. Returns Type Description int value's number of immediate children. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren(T) counts the immediate children of the topmost (Add) node. Assert.Equal(2, rewriter.CountChildren(expr)); See Also CountChildren() Cursor(XElement) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value. Declaration public static Cursor<XElement> Cursor(this XElement value) Parameters Type Name Description XElement value The root node on which the newly created Cursor<T>(IRewriter<T>, T) should be focused. Returns Type Description Cursor<XElement> A Cursor<T>(IRewriter<T>, T) focused on the root node of value. DescendantAt(XElement, IEnumerable<Direction>) Returns the descendant at a particular location in value. Declaration public static XElement DescendantAt(this XElement value, IEnumerable<Direction> path) Parameters Type Name Description XElement value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Returns Type Description XElement The descendant found by following the directions in path. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelf(XElement) Yields all of the nodes in the tree represented by value, starting at the bottom. Declaration public static IEnumerable<XElement> DescendantsAndSelf(this XElement value) Parameters Type Name Description XElement value The value to traverse. Returns Type Description IEnumerable<XElement> An enumerable containing all of the nodes in the tree represented by value, starting at the bottom. Remarks This is a depth-first post-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); See Also SelfAndDescendants<T>(IRewriter<T>, T) DescendantsAndSelfInContext(XElement) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(XElement item, Func<XElement, XElement> replace)> DescendantsAndSelfInContext(this XElement value) Parameters Type Name Description XElement value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(XElement item, Func<XElement, XElement> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See Also DescendantsAndSelf<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContext<T>(IRewriter<T>, T) Fold<T>(XElement, SpanFunc<T, XElement, T>) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static T Fold<T>(this XElement value, SpanFunc<T, XElement, T> func) Parameters Type Name Description XElement value The value to fold. SpanFunc<T, XElement, T> func The aggregation function. Returns Type Description T The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Fold<T>(XElement, Func<Memory<T>, XElement, ValueTask<T>>) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<T> Fold<T>(this XElement value, Func<Memory<T>, XElement, ValueTask<T>> func) Parameters Type Name Description XElement value The value to fold. Func<Memory<T>, XElement, ValueTask<T>> func The asynchronous aggregation function. Returns Type Description ValueTask<T> The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. GetChildren(XElement) Get the immediate children of the value. Declaration public static XElement[] GetChildren(this XElement value) Parameters Type Name Description XElement value The value. Returns Type Description XElement[] The immediate children of value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); See Also GetChildren(Span<T>) GetChildren(XElement, Span<XElement>) Copy the immediate children of the value into childrenReceiver. Declaration public static void GetChildren(this XElement value, Span<XElement> childrenReceiver) Parameters Type Name Description XElement value The value. Span<XElement> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>, T) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[rewriter.CountChildren(expr)]; rewriter.GetChildren(array, expr); Assert.Equal(expected, array); See Also GetChildren(Span<T>) ReplaceDescendantAt<T>(XElement, IEnumerable<Direction>, XElement) Replaces the descendant at a particular location in value. Declaration public static XElement ReplaceDescendantAt<T>(this XElement value, IEnumerable<Direction> path, XElement newDescendant) Parameters Type Name Description XElement value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. XElement newDescendant The replacement descendant. Returns Type Description XElement A copy of value with newDescendant placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. Rewrite(XElement, Func<XElement, ValueTask<XElement>>) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<XElement> Rewrite(this XElement value, Func<XElement, ValueTask<XElement>> transformer) Parameters Type Name Description XElement value The value to rewrite. Func<XElement, ValueTask<XElement>> transformer The asynchronous transformation function to apply to every node in the tree. Returns Type Description ValueTask<XElement> The result of applying transformer to every node in the tree represented by value. Remarks This method is not available on platforms which do not support ValueTask. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); Rewrite(XElement, Func<XElement, XElement>) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static XElement Rewrite(this XElement value, Func<XElement, XElement> transformer) Parameters Type Name Description XElement value The value to rewrite. Func<XElement, XElement> transformer The transformation function to apply to every node in the tree. Returns Type Description XElement The result of applying transformer to every node in the tree represented by value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); RewriteChildren(XElement, Func<XElement, ValueTask<XElement>>) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<XElement> RewriteChildren(this XElement value, Func<XElement, ValueTask<XElement>> transformer) Parameters Type Name Description XElement value The old value, whose immediate children should be transformed by transformer. Func<XElement, ValueTask<XElement>> transformer An asynchronous transformation function to apply to each of value's immediate children. Returns Type Description ValueTask<XElement> A copy of value with updated children. Remarks This method is not available on platforms which do not support ValueTask. RewriteChildren(XElement, Func<XElement, XElement>) Update the immediate children of the value by applying a transformation function to each one. Declaration public static XElement RewriteChildren(this XElement value, Func<XElement, XElement> transformer) Parameters Type Name Description XElement value The old value, whose immediate children should be transformed by transformer. Func<XElement, XElement> transformer A transformation function to apply to each of value's immediate children. Returns Type Description XElement A copy of value with updated children. RewriteDescendantAt<T>(XElement, IEnumerable<Direction>, Func<XElement, ValueTask<XElement>>) Apply an asynchronous function at a particular location in value. Declaration public static ValueTask<XElement> RewriteDescendantAt<T>(this XElement value, IEnumerable<Direction> path, Func<XElement, ValueTask<XElement>> transformer) Parameters Type Name Description XElement value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<XElement, ValueTask<XElement>> transformer An asynchronous function to calculate a replacement for the descendant. Returns Type Description ValueTask<XElement> A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(XElement, IEnumerable<Direction>, Func<XElement, XElement>) Apply a function at a particular location in value. Declaration public static XElement RewriteDescendantAt<T>(this XElement value, IEnumerable<Direction> path, Func<XElement, XElement> transformer) Parameters Type Name Description XElement value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<XElement, XElement> transformer A function to calculate a replacement for the descendant. Returns Type Description XElement A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter(XElement, Func<XElement, ValueTask<XElement>>) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<XElement> RewriteIter(this XElement value, Func<XElement, ValueTask<XElement>> transformer) Parameters Type Name Description XElement value The value to rewrite. Func<XElement, ValueTask<XElement>> transformer An asynchronous transformation function to apply to every node in value repeatedly. Returns Type Description ValueTask<XElement> The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Remarks This method is not available on platforms which do not support ValueTask. RewriteIter(XElement, Func<XElement, XElement>) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static XElement RewriteIter(this XElement value, Func<XElement, XElement> transformer) Parameters Type Name Description XElement value The value to rewrite. Func<XElement, XElement> transformer A transformation function to apply to every node in value repeatedly. Returns Type Description XElement The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. SelfAndDescendants(XElement) Yields all of the nodes in the tree represented by value, starting at the top. Declaration public static IEnumerable<XElement> SelfAndDescendants(this XElement value) Parameters Type Name Description XElement value The value to traverse. Returns Type Description IEnumerable<XElement> An enumerable containing all of the nodes in the tree represented by value, starting at the top. Remarks This is a depth-first pre-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); See Also DescendantsAndSelf<T>(IRewriter<T>, T) SelfAndDescendantsBreadthFirst(XElement) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<XElement> SelfAndDescendantsBreadthFirst(this XElement value) Parameters Type Name Description XElement value The value to traverse. Returns Type Description IEnumerable<XElement> An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. SelfAndDescendantsInContext(XElement) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(XElement item, Func<XElement, XElement> replace)> SelfAndDescendantsInContext(this XElement value) Parameters Type Name Description XElement value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(XElement item, Func<XElement, XElement> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContextBreadthFirst(XElement) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(XElement item, Func<XElement, XElement> replace)> SelfAndDescendantsInContextBreadthFirst(this XElement value) Parameters Type Name Description XElement value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(XElement item, Func<XElement, XElement> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SetChildren(XElement, ReadOnlySpan<XElement>) Set the immediate children of the value. Declaration public static XElement SetChildren(this XElement value, ReadOnlySpan<XElement> newChildren) Parameters Type Name Description XElement value The old value, whose immediate children should be replaced. ReadOnlySpan<XElement> newChildren The new children. Returns Type Description XElement A copy of value with updated children. Remarks Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>, T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>, T) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, rewriter.SetChildren(Children.Two(new Lit(4), new Lit(5)), expr)); See Also SetChildren(ReadOnlySpan<T>) ZipFold<U>(XElement, XElement, Func<XElement, XElement, IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this XElement value1, XElement value2, Func<XElement, XElement, IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description XElement value1 XElement value2 Func<XElement, XElement, IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(XElement, XElement, Func<XElement, XElement, IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this XElement value1, XElement value2, Func<XElement, XElement, IEnumerable<U>, U> func) Parameters Type Name Description XElement value1 XElement value2 Func<XElement, XElement, IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(XElement[], Func<XElement[], IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this XElement[] values, Func<XElement[], IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description XElement[] values The trees to fold. Func<XElement[], IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(XElement[], Func<XElement[], IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this XElement[] values, Func<XElement[], IEnumerable<U>, U> func) Parameters Type Name Description XElement[] values The trees to fold. Func<XElement[], IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.Xml.XElementRewriter.html": {
    "href": "Sawmill.Xml.XElementRewriter.html",
    "title": "Class XElementRewriter | Benjamin.Pizza.DocTest",
    "keywords": "Class XElementRewriter An implementation of IRewriter<T> for System.Xml.Linq.XElements. Inheritance object XElementRewriter Implements IRewriter<XElement> Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public class XElementRewriter : IRewriter<XElement> Constructors XElementRewriter() Create a new instance of XElementRewriter. Declaration protected XElementRewriter() Properties Instance Gets the single global instance of XElementRewriter. Declaration public static XElementRewriter Instance { get; } Property Value Type Description XElementRewriter The single global instance of XElementRewriter. Methods CountChildren(XElement) See CountChildren(T). Declaration public int CountChildren(XElement value) Parameters Type Name Description XElement value The value. Returns Type Description int value's number of immediate children. GetChildren(Span<XElement>, XElement) See GetChildren(Span<T>, T). Declaration public void GetChildren(Span<XElement> childrenReceiver, XElement value) Parameters Type Name Description Span<XElement> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(XElement). XElement value The value. SetChildren(ReadOnlySpan<XElement>, XElement) See SetChildren(ReadOnlySpan<T>, T). Declaration public XElement SetChildren(ReadOnlySpan<XElement> newChildren, XElement value) Parameters Type Name Description ReadOnlySpan<XElement> newChildren The new children. XElement value The old value, whose immediate children should be replaced. Returns Type Description XElement A copy of value with updated children. Implements IRewriter<T> Extension Methods Rewriter.ChildrenInContext<T>(IRewriter<T>, T) Rewriter.Cursor<T>(IRewriter<T>, T) Rewriter.DescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, T) Rewriter.DescendantsAndSelfInContext<T>(IRewriter<T>, T) Rewriter.DescendantsAndSelf<T>(IRewriter<T>, T) Rewriter.Fold<T, U>(IRewriter<T>, SpanFunc<U, T, U>, T) Rewriter.Fold<T, U>(IRewriter<T>, Func<Memory<U>, T, ValueTask<U>>, T) Rewriter.GetChildren<T>(IRewriter<T>, T) Rewriter.ReplaceDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, T, T) Rewriter.RewriteChildren<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rewriter.RewriteChildren<T>(IRewriter<T>, Func<T, T>, T) Rewriter.RewriteDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, Func<T, ValueTask<T>>, T) Rewriter.RewriteDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, Func<T, T>, T) Rewriter.RewriteIter<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rewriter.RewriteIter<T>(IRewriter<T>, Func<T, T>, T) Rewriter.Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rewriter.Rewrite<T>(IRewriter<T>, Func<T, T>, T) Rewriter.SelfAndDescendantsBreadthFirst<T>(IRewriter<T>, T) Rewriter.SelfAndDescendantsInContextBreadthFirst<T>(IRewriter<T>, T) Rewriter.SelfAndDescendantsInContext<T>(IRewriter<T>, T) Rewriter.SelfAndDescendants<T>(IRewriter<T>, T) Rewriter.ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) Rewriter.ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[])"
  },
  "Sawmill.Xml.XmlNodeExtensions.html": {
    "href": "Sawmill.Xml.XmlNodeExtensions.html",
    "title": "Class XmlNodeExtensions | Benjamin.Pizza.DocTest",
    "keywords": "Class XmlNodeExtensions Extension methods for System.Xml.XmlNodes. Inheritance object XmlNodeExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public static class XmlNodeExtensions Methods ChildrenInContext(XmlNode) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. Declaration public static (XmlNode item, Func<XmlNode, XmlNode> replace)[] ChildrenInContext(this XmlNode value) Parameters Type Name Description XmlNode value The value to get the contexts for the immediate children. Returns Type Description (XmlNode item, Func<XmlNode, XmlNode> replace)[] An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See Also SelfAndDescendantsInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) CountChildren(XmlNode) Count the immediate children of the value. Declaration public static int CountChildren(this XmlNode value) Parameters Type Name Description XmlNode value The value. Returns Type Description int value's number of immediate children. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren(T) counts the immediate children of the topmost (Add) node. Assert.Equal(2, rewriter.CountChildren(expr)); See Also CountChildren() Cursor(XmlNode) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value. Declaration public static Cursor<XmlNode> Cursor(this XmlNode value) Parameters Type Name Description XmlNode value The root node on which the newly created Cursor<T>(IRewriter<T>, T) should be focused. Returns Type Description Cursor<XmlNode> A Cursor<T>(IRewriter<T>, T) focused on the root node of value. DescendantAt(XmlNode, IEnumerable<Direction>) Returns the descendant at a particular location in value. Declaration public static XmlNode DescendantAt(this XmlNode value, IEnumerable<Direction> path) Parameters Type Name Description XmlNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Returns Type Description XmlNode The descendant found by following the directions in path. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelf(XmlNode) Yields all of the nodes in the tree represented by value, starting at the bottom. Declaration public static IEnumerable<XmlNode> DescendantsAndSelf(this XmlNode value) Parameters Type Name Description XmlNode value The value to traverse. Returns Type Description IEnumerable<XmlNode> An enumerable containing all of the nodes in the tree represented by value, starting at the bottom. Remarks This is a depth-first post-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); See Also SelfAndDescendants<T>(IRewriter<T>, T) DescendantsAndSelfInContext(XmlNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(XmlNode item, Func<XmlNode, XmlNode> replace)> DescendantsAndSelfInContext(this XmlNode value) Parameters Type Name Description XmlNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(XmlNode item, Func<XmlNode, XmlNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See Also DescendantsAndSelf<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContext<T>(IRewriter<T>, T) Fold<T>(XmlNode, SpanFunc<T, XmlNode, T>) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static T Fold<T>(this XmlNode value, SpanFunc<T, XmlNode, T> func) Parameters Type Name Description XmlNode value The value to fold. SpanFunc<T, XmlNode, T> func The aggregation function. Returns Type Description T The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Fold<T>(XmlNode, Func<Memory<T>, XmlNode, ValueTask<T>>) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<T> Fold<T>(this XmlNode value, Func<Memory<T>, XmlNode, ValueTask<T>> func) Parameters Type Name Description XmlNode value The value to fold. Func<Memory<T>, XmlNode, ValueTask<T>> func The asynchronous aggregation function. Returns Type Description ValueTask<T> The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. GetChildren(XmlNode) Get the immediate children of the value. Declaration public static XmlNode[] GetChildren(this XmlNode value) Parameters Type Name Description XmlNode value The value. Returns Type Description XmlNode[] The immediate children of value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); See Also GetChildren(Span<T>) GetChildren(XmlNode, Span<XmlNode>) Copy the immediate children of the value into childrenReceiver. Declaration public static void GetChildren(this XmlNode value, Span<XmlNode> childrenReceiver) Parameters Type Name Description XmlNode value The value. Span<XmlNode> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>, T) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[rewriter.CountChildren(expr)]; rewriter.GetChildren(array, expr); Assert.Equal(expected, array); See Also GetChildren(Span<T>) ReplaceDescendantAt<T>(XmlNode, IEnumerable<Direction>, XmlNode) Replaces the descendant at a particular location in value. Declaration public static XmlNode ReplaceDescendantAt<T>(this XmlNode value, IEnumerable<Direction> path, XmlNode newDescendant) Parameters Type Name Description XmlNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. XmlNode newDescendant The replacement descendant. Returns Type Description XmlNode A copy of value with newDescendant placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. Rewrite(XmlNode, Func<XmlNode, ValueTask<XmlNode>>) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<XmlNode> Rewrite(this XmlNode value, Func<XmlNode, ValueTask<XmlNode>> transformer) Parameters Type Name Description XmlNode value The value to rewrite. Func<XmlNode, ValueTask<XmlNode>> transformer The asynchronous transformation function to apply to every node in the tree. Returns Type Description ValueTask<XmlNode> The result of applying transformer to every node in the tree represented by value. Remarks This method is not available on platforms which do not support ValueTask. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); Rewrite(XmlNode, Func<XmlNode, XmlNode>) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static XmlNode Rewrite(this XmlNode value, Func<XmlNode, XmlNode> transformer) Parameters Type Name Description XmlNode value The value to rewrite. Func<XmlNode, XmlNode> transformer The transformation function to apply to every node in the tree. Returns Type Description XmlNode The result of applying transformer to every node in the tree represented by value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); RewriteChildren(XmlNode, Func<XmlNode, ValueTask<XmlNode>>) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<XmlNode> RewriteChildren(this XmlNode value, Func<XmlNode, ValueTask<XmlNode>> transformer) Parameters Type Name Description XmlNode value The old value, whose immediate children should be transformed by transformer. Func<XmlNode, ValueTask<XmlNode>> transformer An asynchronous transformation function to apply to each of value's immediate children. Returns Type Description ValueTask<XmlNode> A copy of value with updated children. Remarks This method is not available on platforms which do not support ValueTask. RewriteChildren(XmlNode, Func<XmlNode, XmlNode>) Update the immediate children of the value by applying a transformation function to each one. Declaration public static XmlNode RewriteChildren(this XmlNode value, Func<XmlNode, XmlNode> transformer) Parameters Type Name Description XmlNode value The old value, whose immediate children should be transformed by transformer. Func<XmlNode, XmlNode> transformer A transformation function to apply to each of value's immediate children. Returns Type Description XmlNode A copy of value with updated children. RewriteDescendantAt<T>(XmlNode, IEnumerable<Direction>, Func<XmlNode, ValueTask<XmlNode>>) Apply an asynchronous function at a particular location in value. Declaration public static ValueTask<XmlNode> RewriteDescendantAt<T>(this XmlNode value, IEnumerable<Direction> path, Func<XmlNode, ValueTask<XmlNode>> transformer) Parameters Type Name Description XmlNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<XmlNode, ValueTask<XmlNode>> transformer An asynchronous function to calculate a replacement for the descendant. Returns Type Description ValueTask<XmlNode> A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(XmlNode, IEnumerable<Direction>, Func<XmlNode, XmlNode>) Apply a function at a particular location in value. Declaration public static XmlNode RewriteDescendantAt<T>(this XmlNode value, IEnumerable<Direction> path, Func<XmlNode, XmlNode> transformer) Parameters Type Name Description XmlNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<XmlNode, XmlNode> transformer A function to calculate a replacement for the descendant. Returns Type Description XmlNode A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter(XmlNode, Func<XmlNode, ValueTask<XmlNode>>) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<XmlNode> RewriteIter(this XmlNode value, Func<XmlNode, ValueTask<XmlNode>> transformer) Parameters Type Name Description XmlNode value The value to rewrite. Func<XmlNode, ValueTask<XmlNode>> transformer An asynchronous transformation function to apply to every node in value repeatedly. Returns Type Description ValueTask<XmlNode> The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Remarks This method is not available on platforms which do not support ValueTask. RewriteIter(XmlNode, Func<XmlNode, XmlNode>) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static XmlNode RewriteIter(this XmlNode value, Func<XmlNode, XmlNode> transformer) Parameters Type Name Description XmlNode value The value to rewrite. Func<XmlNode, XmlNode> transformer A transformation function to apply to every node in value repeatedly. Returns Type Description XmlNode The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. SelfAndDescendants(XmlNode) Yields all of the nodes in the tree represented by value, starting at the top. Declaration public static IEnumerable<XmlNode> SelfAndDescendants(this XmlNode value) Parameters Type Name Description XmlNode value The value to traverse. Returns Type Description IEnumerable<XmlNode> An enumerable containing all of the nodes in the tree represented by value, starting at the top. Remarks This is a depth-first pre-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); See Also DescendantsAndSelf<T>(IRewriter<T>, T) SelfAndDescendantsBreadthFirst(XmlNode) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<XmlNode> SelfAndDescendantsBreadthFirst(this XmlNode value) Parameters Type Name Description XmlNode value The value to traverse. Returns Type Description IEnumerable<XmlNode> An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. SelfAndDescendantsInContext(XmlNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(XmlNode item, Func<XmlNode, XmlNode> replace)> SelfAndDescendantsInContext(this XmlNode value) Parameters Type Name Description XmlNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(XmlNode item, Func<XmlNode, XmlNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContextBreadthFirst(XmlNode) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(XmlNode item, Func<XmlNode, XmlNode> replace)> SelfAndDescendantsInContextBreadthFirst(this XmlNode value) Parameters Type Name Description XmlNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(XmlNode item, Func<XmlNode, XmlNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SetChildren(XmlNode, ReadOnlySpan<XmlNode>) Set the immediate children of the value. Declaration public static XmlNode SetChildren(this XmlNode value, ReadOnlySpan<XmlNode> newChildren) Parameters Type Name Description XmlNode value The old value, whose immediate children should be replaced. ReadOnlySpan<XmlNode> newChildren The new children. Returns Type Description XmlNode A copy of value with updated children. Remarks Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>, T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>, T) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, rewriter.SetChildren(Children.Two(new Lit(4), new Lit(5)), expr)); See Also SetChildren(ReadOnlySpan<T>) ZipFold<U>(XmlNode, XmlNode, Func<XmlNode, XmlNode, IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this XmlNode value1, XmlNode value2, Func<XmlNode, XmlNode, IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description XmlNode value1 XmlNode value2 Func<XmlNode, XmlNode, IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(XmlNode, XmlNode, Func<XmlNode, XmlNode, IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this XmlNode value1, XmlNode value2, Func<XmlNode, XmlNode, IEnumerable<U>, U> func) Parameters Type Name Description XmlNode value1 XmlNode value2 Func<XmlNode, XmlNode, IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(XmlNode[], Func<XmlNode[], IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this XmlNode[] values, Func<XmlNode[], IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description XmlNode[] values The trees to fold. Func<XmlNode[], IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(XmlNode[], Func<XmlNode[], IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this XmlNode[] values, Func<XmlNode[], IEnumerable<U>, U> func) Parameters Type Name Description XmlNode[] values The trees to fold. Func<XmlNode[], IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.Xml.XmlNodeRewriter.html": {
    "href": "Sawmill.Xml.XmlNodeRewriter.html",
    "title": "Class XmlNodeRewriter | Benjamin.Pizza.DocTest",
    "keywords": "Class XmlNodeRewriter An implementation of IRewriter<T> for System.Xml.XmlNodes. Inheritance object XmlNodeRewriter Implements IRewriter<XmlNode> Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public class XmlNodeRewriter : IRewriter<XmlNode> Constructors XmlNodeRewriter() Create a new instance of XmlNodeRewriter. Declaration protected XmlNodeRewriter() Properties Instance Gets the single global instance of XElementRewriter. Declaration public static XmlNodeRewriter Instance { get; } Property Value Type Description XmlNodeRewriter The single global instance of XElementRewriter. Methods CountChildren(XmlNode) See CountChildren(T). Declaration public int CountChildren(XmlNode value) Parameters Type Name Description XmlNode value The value. Returns Type Description int value's number of immediate children. GetChildren(Span<XmlNode>, XmlNode) See GetChildren(Span<T>, T). Declaration public void GetChildren(Span<XmlNode> childrenReceiver, XmlNode value) Parameters Type Name Description Span<XmlNode> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(XmlNode). XmlNode value The value. SetChildren(ReadOnlySpan<XmlNode>, XmlNode) See SetChildren(ReadOnlySpan<T>, T). Declaration public XmlNode SetChildren(ReadOnlySpan<XmlNode> newChildren, XmlNode value) Parameters Type Name Description ReadOnlySpan<XmlNode> newChildren The new children. XmlNode value The old value, whose immediate children should be replaced. Returns Type Description XmlNode A copy of value with updated children. Implements IRewriter<T> Extension Methods Rewriter.ChildrenInContext<T>(IRewriter<T>, T) Rewriter.Cursor<T>(IRewriter<T>, T) Rewriter.DescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, T) Rewriter.DescendantsAndSelfInContext<T>(IRewriter<T>, T) Rewriter.DescendantsAndSelf<T>(IRewriter<T>, T) Rewriter.Fold<T, U>(IRewriter<T>, SpanFunc<U, T, U>, T) Rewriter.Fold<T, U>(IRewriter<T>, Func<Memory<U>, T, ValueTask<U>>, T) Rewriter.GetChildren<T>(IRewriter<T>, T) Rewriter.ReplaceDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, T, T) Rewriter.RewriteChildren<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rewriter.RewriteChildren<T>(IRewriter<T>, Func<T, T>, T) Rewriter.RewriteDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, Func<T, ValueTask<T>>, T) Rewriter.RewriteDescendantAt<T>(IRewriter<T>, IEnumerable<Direction>, Func<T, T>, T) Rewriter.RewriteIter<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rewriter.RewriteIter<T>(IRewriter<T>, Func<T, T>, T) Rewriter.Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) Rewriter.Rewrite<T>(IRewriter<T>, Func<T, T>, T) Rewriter.SelfAndDescendantsBreadthFirst<T>(IRewriter<T>, T) Rewriter.SelfAndDescendantsInContextBreadthFirst<T>(IRewriter<T>, T) Rewriter.SelfAndDescendantsInContext<T>(IRewriter<T>, T) Rewriter.SelfAndDescendants<T>(IRewriter<T>, T) Rewriter.ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) Rewriter.ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[])"
  },
  "Sawmill.Xml.html": {
    "href": "Sawmill.Xml.html",
    "title": "Namespace Sawmill.Xml | Benjamin.Pizza.DocTest",
    "keywords": "Namespace Sawmill.Xml Classes XElementExtensions Extension methods for System.Xml.Linq.XElements. XElementRewriter An implementation of IRewriter<T> for System.Xml.Linq.XElements. XmlNodeExtensions Extension methods for System.Xml.XmlNodes. XmlNodeRewriter An implementation of IRewriter<T> for System.Xml.XmlNodes."
  },
  "Sawmill.html": {
    "href": "Sawmill.html",
    "title": "Namespace Sawmill | Benjamin.Pizza.DocTest",
    "keywords": "Namespace Sawmill Classes AutoRewriter<T> An experimental implementation of IRewriter<T> using reflection. AutoRewriter<T> looks for the subtype's constructor, and gets/sets the T-children in the order that they appear in the constructor. Cursor<T> A Cursor<T> is a mutable view of a location in a T-structure, allowing efficient access to (and editing of) a node and its parent, siblings, and immediate children. You can think of a Cursor<T> as being focused on a particular node. After zooming in on a node, you can efficiently go up to the node's parent, down to the node's first child, or left or right to the node's immediate siblings. Cursor<T> is generally not as efficient or useful as the SelfAndDescendantsInContext<T>(IRewriter<T>, T) family for replacing single nodes, but it efficiently supports longer sequences of edits to a location and its neighbours. Rewritable Extension methods for IRewritable<T> implementations. RewritableRewriter<T> An implementation of IRewriter<T> for Ts which implement IRewritable<T>. Rewriter Extension methods for IRewriter<T> implementations. RewriterBuilder Tools for building rewriters. RewriterBuilderCase Tools for building rewriters for a single subclass of a base type. RewriterBuilderCase<TArgs, TBase, TSub> Tools for building rewriters for a single subclass of a base type. RewriterBuilder<T> Tools for building rewriters. Interfaces IRewritable<T> A object is rewritable if it knows how to access its immediate children. IRewriter<T> A rewriter is an object which knows how to access the immediate children of a value of type T. Enums Direction Represents a direction that a Cursor<T> can move in. Delegates SpanFunc<T, U, R> A Func<T1, T2, TResult> whose first argument is a Span<T>."
  },
  "index.html": {
    "href": "index.html",
    "title": "Page Redirection",
    "keywords": ""
  }
}