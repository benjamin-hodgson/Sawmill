{
  "Sawmill.HtmlAgilityPack.HtmlNodeExtensions.html": {
    "href": "Sawmill.HtmlAgilityPack.HtmlNodeExtensions.html",
    "title": "Class HtmlNodeExtensions | Benjamin.Pizza.DocTest",
    "keywords": "Class HtmlNodeExtensions Extension methods for HtmlAgilityPack.HtmlNodes. Inheritance object HtmlNodeExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public static class HtmlNodeExtensions Methods ChildrenInContext(HtmlNode) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. Declaration public static (HtmlNode item, Func<HtmlNode, HtmlNode> replace)[] ChildrenInContext(this HtmlNode value) Parameters Type Name Description HtmlNode value The value to get the contexts for the immediate children. Returns Type Description (HtmlNode item, Func<HtmlNode, HtmlNode> replace)[] An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See Also SelfAndDescendantsInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) CountChildren(HtmlNode) Count the immediate children of the value. Declaration public static int CountChildren(this HtmlNode value) Parameters Type Name Description HtmlNode value The value. Returns Type Description int value's number of immediate children. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren(T) counts the immediate children of the topmost (Add) node. Assert.Equal(2, rewriter.CountChildren(expr)); See Also CountChildren() Cursor(HtmlNode) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value. Declaration public static Cursor<HtmlNode> Cursor(this HtmlNode value) Parameters Type Name Description HtmlNode value The root node on which the newly created Cursor<T>(IRewriter<T>, T) should be focused. Returns Type Description Cursor<HtmlNode> A Cursor<T>(IRewriter<T>, T) focused on the root node of value. DescendantAt(HtmlNode, IEnumerable<Direction>) Returns the descendant at a particular location in value. Declaration public static HtmlNode DescendantAt(this HtmlNode value, IEnumerable<Direction> path) Parameters Type Name Description HtmlNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Returns Type Description HtmlNode The descendant found by following the directions in path. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelf(HtmlNode) Yields all of the nodes in the tree represented by value, starting at the bottom. Declaration public static IEnumerable<HtmlNode> DescendantsAndSelf(this HtmlNode value) Parameters Type Name Description HtmlNode value The value to traverse. Returns Type Description IEnumerable<HtmlNode> An enumerable containing all of the nodes in the tree represented by value, starting at the bottom. Remarks This is a depth-first post-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); See Also SelfAndDescendants<T>(IRewriter<T>, T) DescendantsAndSelfInContext(HtmlNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(HtmlNode item, Func<HtmlNode, HtmlNode> replace)> DescendantsAndSelfInContext(this HtmlNode value) Parameters Type Name Description HtmlNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(HtmlNode item, Func<HtmlNode, HtmlNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See Also DescendantsAndSelf<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContext<T>(IRewriter<T>, T) Fold<T>(HtmlNode, SpanFunc<T, HtmlNode, T>) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static T Fold<T>(this HtmlNode value, SpanFunc<T, HtmlNode, T> func) Parameters Type Name Description HtmlNode value The value to fold. SpanFunc<T, HtmlNode, T> func The aggregation function. Returns Type Description T The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Fold<T>(HtmlNode, Func<Memory<T>, HtmlNode, ValueTask<T>>) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<T> Fold<T>(this HtmlNode value, Func<Memory<T>, HtmlNode, ValueTask<T>> func) Parameters Type Name Description HtmlNode value The value to fold. Func<Memory<T>, HtmlNode, ValueTask<T>> func The asynchronous aggregation function. Returns Type Description ValueTask<T> The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. GetChildren(HtmlNode) Get the immediate children of the value. Declaration public static HtmlNode[] GetChildren(this HtmlNode value) Parameters Type Name Description HtmlNode value The value. Returns Type Description HtmlNode[] The immediate children of value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); See Also GetChildren(Span<T>) GetChildren(HtmlNode, Span<HtmlNode>) Copy the immediate children of the value into childrenReceiver. Declaration public static void GetChildren(this HtmlNode value, Span<HtmlNode> childrenReceiver) Parameters Type Name Description HtmlNode value The value. Span<HtmlNode> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>, T) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[rewriter.CountChildren(expr)]; rewriter.GetChildren(array, expr); Assert.Equal(expected, array); See Also GetChildren(Span<T>) ReplaceDescendantAt<T>(HtmlNode, IEnumerable<Direction>, HtmlNode) Replaces the descendant at a particular location in value. Declaration public static HtmlNode ReplaceDescendantAt<T>(this HtmlNode value, IEnumerable<Direction> path, HtmlNode newDescendant) Parameters Type Name Description HtmlNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. HtmlNode newDescendant The replacement descendant. Returns Type Description HtmlNode A copy of value with newDescendant placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. Rewrite(HtmlNode, Func<HtmlNode, HtmlNode>) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static HtmlNode Rewrite(this HtmlNode value, Func<HtmlNode, HtmlNode> transformer) Parameters Type Name Description HtmlNode value The value to rewrite. Func<HtmlNode, HtmlNode> transformer The transformation function to apply to every node in the tree. Returns Type Description HtmlNode The result of applying transformer to every node in the tree represented by value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); Rewrite(HtmlNode, Func<HtmlNode, ValueTask<HtmlNode>>) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<HtmlNode> Rewrite(this HtmlNode value, Func<HtmlNode, ValueTask<HtmlNode>> transformer) Parameters Type Name Description HtmlNode value The value to rewrite. Func<HtmlNode, ValueTask<HtmlNode>> transformer The asynchronous transformation function to apply to every node in the tree. Returns Type Description ValueTask<HtmlNode> The result of applying transformer to every node in the tree represented by value. Remarks This method is not available on platforms which do not support ValueTask. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); RewriteChildren(HtmlNode, Func<HtmlNode, HtmlNode>) Update the immediate children of the value by applying a transformation function to each one. Declaration public static HtmlNode RewriteChildren(this HtmlNode value, Func<HtmlNode, HtmlNode> transformer) Parameters Type Name Description HtmlNode value The old value, whose immediate children should be transformed by transformer. Func<HtmlNode, HtmlNode> transformer A transformation function to apply to each of value's immediate children. Returns Type Description HtmlNode A copy of value with updated children. RewriteChildren(HtmlNode, Func<HtmlNode, ValueTask<HtmlNode>>) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<HtmlNode> RewriteChildren(this HtmlNode value, Func<HtmlNode, ValueTask<HtmlNode>> transformer) Parameters Type Name Description HtmlNode value The old value, whose immediate children should be transformed by transformer. Func<HtmlNode, ValueTask<HtmlNode>> transformer An asynchronous transformation function to apply to each of value's immediate children. Returns Type Description ValueTask<HtmlNode> A copy of value with updated children. Remarks This method is not available on platforms which do not support ValueTask. RewriteDescendantAt<T>(HtmlNode, IEnumerable<Direction>, Func<HtmlNode, HtmlNode>) Apply a function at a particular location in value. Declaration public static HtmlNode RewriteDescendantAt<T>(this HtmlNode value, IEnumerable<Direction> path, Func<HtmlNode, HtmlNode> transformer) Parameters Type Name Description HtmlNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<HtmlNode, HtmlNode> transformer A function to calculate a replacement for the descendant. Returns Type Description HtmlNode A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(HtmlNode, IEnumerable<Direction>, Func<HtmlNode, ValueTask<HtmlNode>>) Apply an asynchronous function at a particular location in value. Declaration public static ValueTask<HtmlNode> RewriteDescendantAt<T>(this HtmlNode value, IEnumerable<Direction> path, Func<HtmlNode, ValueTask<HtmlNode>> transformer) Parameters Type Name Description HtmlNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<HtmlNode, ValueTask<HtmlNode>> transformer An asynchronous function to calculate a replacement for the descendant. Returns Type Description ValueTask<HtmlNode> A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter(HtmlNode, Func<HtmlNode, HtmlNode>) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static HtmlNode RewriteIter(this HtmlNode value, Func<HtmlNode, HtmlNode> transformer) Parameters Type Name Description HtmlNode value The value to rewrite. Func<HtmlNode, HtmlNode> transformer A transformation function to apply to every node in value repeatedly. Returns Type Description HtmlNode The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. RewriteIter(HtmlNode, Func<HtmlNode, ValueTask<HtmlNode>>) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<HtmlNode> RewriteIter(this HtmlNode value, Func<HtmlNode, ValueTask<HtmlNode>> transformer) Parameters Type Name Description HtmlNode value The value to rewrite. Func<HtmlNode, ValueTask<HtmlNode>> transformer An asynchronous transformation function to apply to every node in value repeatedly. Returns Type Description ValueTask<HtmlNode> The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Remarks This method is not available on platforms which do not support ValueTask. SelfAndDescendants(HtmlNode) Yields all of the nodes in the tree represented by value, starting at the top. Declaration public static IEnumerable<HtmlNode> SelfAndDescendants(this HtmlNode value) Parameters Type Name Description HtmlNode value The value to traverse. Returns Type Description IEnumerable<HtmlNode> An enumerable containing all of the nodes in the tree represented by value, starting at the top. Remarks This is a depth-first pre-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); See Also DescendantsAndSelf<T>(IRewriter<T>, T) SelfAndDescendantsBreadthFirst(HtmlNode) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<HtmlNode> SelfAndDescendantsBreadthFirst(this HtmlNode value) Parameters Type Name Description HtmlNode value The value to traverse. Returns Type Description IEnumerable<HtmlNode> An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. SelfAndDescendantsInContext(HtmlNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(HtmlNode item, Func<HtmlNode, HtmlNode> replace)> SelfAndDescendantsInContext(this HtmlNode value) Parameters Type Name Description HtmlNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(HtmlNode item, Func<HtmlNode, HtmlNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContextBreadthFirst(HtmlNode) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(HtmlNode item, Func<HtmlNode, HtmlNode> replace)> SelfAndDescendantsInContextBreadthFirst(this HtmlNode value) Parameters Type Name Description HtmlNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(HtmlNode item, Func<HtmlNode, HtmlNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SetChildren(HtmlNode, ReadOnlySpan<HtmlNode>) Set the immediate children of the value. Declaration public static HtmlNode SetChildren(this HtmlNode value, ReadOnlySpan<HtmlNode> newChildren) Parameters Type Name Description HtmlNode value The old value, whose immediate children should be replaced. ReadOnlySpan<HtmlNode> newChildren The new children. Returns Type Description HtmlNode A copy of value with updated children. Remarks Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>, T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>, T) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, rewriter.SetChildren(Children.Two(new Lit(4), new Lit(5)), expr)); See Also SetChildren(ReadOnlySpan<T>) ZipFold<U>(HtmlNode, HtmlNode, Func<HtmlNode, HtmlNode, IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this HtmlNode value1, HtmlNode value2, Func<HtmlNode, HtmlNode, IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description HtmlNode value1 HtmlNode value2 Func<HtmlNode, HtmlNode, IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(HtmlNode, HtmlNode, Func<HtmlNode, HtmlNode, IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this HtmlNode value1, HtmlNode value2, Func<HtmlNode, HtmlNode, IEnumerable<U>, U> func) Parameters Type Name Description HtmlNode value1 HtmlNode value2 Func<HtmlNode, HtmlNode, IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(HtmlNode[], Func<HtmlNode[], IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this HtmlNode[] values, Func<HtmlNode[], IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description HtmlNode[] values The trees to fold. Func<HtmlNode[], IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(HtmlNode[], Func<HtmlNode[], IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this HtmlNode[] values, Func<HtmlNode[], IEnumerable<U>, U> func) Parameters Type Name Description HtmlNode[] values The trees to fold. Func<HtmlNode[], IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.HtmlAgilityPack.HtmlNodeRewriter.html": {
    "href": "Sawmill.HtmlAgilityPack.HtmlNodeRewriter.html",
    "title": "Class HtmlNodeRewriter | Benjamin.Pizza.DocTest",
    "keywords": "Class HtmlNodeRewriter An implementation of IRewriter<T> for HtmlAgilityPack.HtmlNodes. Inheritance object HtmlNodeRewriter Implements IRewriter<HtmlNode> Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public class HtmlNodeRewriter : IRewriter<HtmlNode> Constructors HtmlNodeRewriter() Create a new instance of HtmlNodeRewriter. Declaration protected HtmlNodeRewriter() Properties Instance Gets the single global instance of HtmlNodeRewriter. Declaration public static IRewriter<HtmlNode> Instance { get; } Property Value Type Description IRewriter<HtmlNode> The single global instance of HtmlNodeRewriter. Methods CountChildren(HtmlNode) See CountChildren(T). Declaration public int CountChildren(HtmlNode value) Parameters Type Name Description HtmlNode value The value. Returns Type Description int value's number of immediate children. GetChildren(Span<HtmlNode>, HtmlNode) See GetChildren(Span<T>, T). Declaration public void GetChildren(Span<HtmlNode> childrenReceiver, HtmlNode value) Parameters Type Name Description Span<HtmlNode> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(HtmlNode). HtmlNode value The value. SetChildren(ReadOnlySpan<HtmlNode>, HtmlNode) See SetChildren(ReadOnlySpan<T>, T). Declaration public HtmlNode SetChildren(ReadOnlySpan<HtmlNode> newChildren, HtmlNode value) Parameters Type Name Description ReadOnlySpan<HtmlNode> newChildren The new children. HtmlNode value The old value, whose immediate children should be replaced. Returns Type Description HtmlNode A copy of value with updated children. Implements IRewriter<T>"
  },
  "Sawmill.HtmlAgilityPack.html": {
    "href": "Sawmill.HtmlAgilityPack.html",
    "title": "Namespace Sawmill.HtmlAgilityPack | Benjamin.Pizza.DocTest",
    "keywords": "Namespace Sawmill.HtmlAgilityPack Classes HtmlNodeExtensions Extension methods for HtmlAgilityPack.HtmlNodes. HtmlNodeRewriter An implementation of IRewriter<T> for HtmlAgilityPack.HtmlNodes."
  },
  "Sawmill.Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNodeExtensions.html": {
    "href": "Sawmill.Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNodeExtensions.html",
    "title": "Class CSharpSyntaxNodeExtensions | Benjamin.Pizza.DocTest",
    "keywords": "Class CSharpSyntaxNodeExtensions Extension methods for CSharpSyntaxNodes. Inheritance object CSharpSyntaxNodeExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public static class CSharpSyntaxNodeExtensions Methods ChildrenInContext(CSharpSyntaxNode) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. Declaration public static (CSharpSyntaxNode item, Func<CSharpSyntaxNode, CSharpSyntaxNode> replace)[] ChildrenInContext(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The value to get the contexts for the immediate children. Returns Type Description (CSharpSyntaxNode item, Func<CSharpSyntaxNode, CSharpSyntaxNode> replace)[] An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See Also SelfAndDescendantsInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) CountChildren(CSharpSyntaxNode) Count the immediate children of the value. Declaration public static int CountChildren(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The value. Returns Type Description int value's number of immediate children. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren(T) counts the immediate children of the topmost (Add) node. Assert.Equal(2, rewriter.CountChildren(expr)); See Also CountChildren() Cursor(CSharpSyntaxNode) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value. Declaration public static Cursor<CSharpSyntaxNode> Cursor(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The root node on which the newly created Cursor<T>(IRewriter<T>, T) should be focused. Returns Type Description Cursor<CSharpSyntaxNode> A Cursor<T>(IRewriter<T>, T) focused on the root node of value. DescendantAt(CSharpSyntaxNode, IEnumerable<Direction>) Returns the descendant at a particular location in value. Declaration public static CSharpSyntaxNode DescendantAt(this CSharpSyntaxNode value, IEnumerable<Direction> path) Parameters Type Name Description CSharpSyntaxNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Returns Type Description CSharpSyntaxNode The descendant found by following the directions in path. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelf(CSharpSyntaxNode) Yields all of the nodes in the tree represented by value, starting at the bottom. Declaration public static IEnumerable<CSharpSyntaxNode> DescendantsAndSelf(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The value to traverse. Returns Type Description IEnumerable<CSharpSyntaxNode> An enumerable containing all of the nodes in the tree represented by value, starting at the bottom. Remarks This is a depth-first post-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); See Also SelfAndDescendants<T>(IRewriter<T>, T) DescendantsAndSelfInContext(CSharpSyntaxNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(CSharpSyntaxNode item, Func<CSharpSyntaxNode, CSharpSyntaxNode> replace)> DescendantsAndSelfInContext(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(CSharpSyntaxNode item, Func<CSharpSyntaxNode, CSharpSyntaxNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See Also DescendantsAndSelf<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContext<T>(IRewriter<T>, T) Fold<T>(CSharpSyntaxNode, SpanFunc<T, CSharpSyntaxNode, T>) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static T Fold<T>(this CSharpSyntaxNode value, SpanFunc<T, CSharpSyntaxNode, T> func) Parameters Type Name Description CSharpSyntaxNode value The value to fold. SpanFunc<T, CSharpSyntaxNode, T> func The aggregation function. Returns Type Description T The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Fold<T>(CSharpSyntaxNode, Func<Memory<T>, CSharpSyntaxNode, ValueTask<T>>) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<T> Fold<T>(this CSharpSyntaxNode value, Func<Memory<T>, CSharpSyntaxNode, ValueTask<T>> func) Parameters Type Name Description CSharpSyntaxNode value The value to fold. Func<Memory<T>, CSharpSyntaxNode, ValueTask<T>> func The asynchronous aggregation function. Returns Type Description ValueTask<T> The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. GetChildren(CSharpSyntaxNode) Get the immediate children of the value. Declaration public static CSharpSyntaxNode[] GetChildren(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The value. Returns Type Description CSharpSyntaxNode[] The immediate children of value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); See Also GetChildren(Span<T>) GetChildren(CSharpSyntaxNode, Span<CSharpSyntaxNode>) Copy the immediate children of the value into childrenReceiver. Declaration public static void GetChildren(this CSharpSyntaxNode value, Span<CSharpSyntaxNode> childrenReceiver) Parameters Type Name Description CSharpSyntaxNode value The value. Span<CSharpSyntaxNode> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>, T) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[rewriter.CountChildren(expr)]; rewriter.GetChildren(array, expr); Assert.Equal(expected, array); See Also GetChildren(Span<T>) ReplaceDescendantAt<T>(CSharpSyntaxNode, IEnumerable<Direction>, CSharpSyntaxNode) Replaces the descendant at a particular location in value. Declaration public static CSharpSyntaxNode ReplaceDescendantAt<T>(this CSharpSyntaxNode value, IEnumerable<Direction> path, CSharpSyntaxNode newDescendant) Parameters Type Name Description CSharpSyntaxNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. CSharpSyntaxNode newDescendant The replacement descendant. Returns Type Description CSharpSyntaxNode A copy of value with newDescendant placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. Rewrite(CSharpSyntaxNode, Func<CSharpSyntaxNode, CSharpSyntaxNode>) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static CSharpSyntaxNode Rewrite(this CSharpSyntaxNode value, Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer) Parameters Type Name Description CSharpSyntaxNode value The value to rewrite. Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer The transformation function to apply to every node in the tree. Returns Type Description CSharpSyntaxNode The result of applying transformer to every node in the tree represented by value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); Rewrite(CSharpSyntaxNode, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>>) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<CSharpSyntaxNode> Rewrite(this CSharpSyntaxNode value, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer) Parameters Type Name Description CSharpSyntaxNode value The value to rewrite. Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer The asynchronous transformation function to apply to every node in the tree. Returns Type Description ValueTask<CSharpSyntaxNode> The result of applying transformer to every node in the tree represented by value. Remarks This method is not available on platforms which do not support ValueTask. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); RewriteChildren(CSharpSyntaxNode, Func<CSharpSyntaxNode, CSharpSyntaxNode>) Update the immediate children of the value by applying a transformation function to each one. Declaration public static CSharpSyntaxNode RewriteChildren(this CSharpSyntaxNode value, Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer) Parameters Type Name Description CSharpSyntaxNode value The old value, whose immediate children should be transformed by transformer. Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer A transformation function to apply to each of value's immediate children. Returns Type Description CSharpSyntaxNode A copy of value with updated children. RewriteChildren(CSharpSyntaxNode, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>>) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<CSharpSyntaxNode> RewriteChildren(this CSharpSyntaxNode value, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer) Parameters Type Name Description CSharpSyntaxNode value The old value, whose immediate children should be transformed by transformer. Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer An asynchronous transformation function to apply to each of value's immediate children. Returns Type Description ValueTask<CSharpSyntaxNode> A copy of value with updated children. Remarks This method is not available on platforms which do not support ValueTask. RewriteDescendantAt<T>(CSharpSyntaxNode, IEnumerable<Direction>, Func<CSharpSyntaxNode, CSharpSyntaxNode>) Apply a function at a particular location in value. Declaration public static CSharpSyntaxNode RewriteDescendantAt<T>(this CSharpSyntaxNode value, IEnumerable<Direction> path, Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer) Parameters Type Name Description CSharpSyntaxNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer A function to calculate a replacement for the descendant. Returns Type Description CSharpSyntaxNode A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(CSharpSyntaxNode, IEnumerable<Direction>, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>>) Apply an asynchronous function at a particular location in value. Declaration public static ValueTask<CSharpSyntaxNode> RewriteDescendantAt<T>(this CSharpSyntaxNode value, IEnumerable<Direction> path, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer) Parameters Type Name Description CSharpSyntaxNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer An asynchronous function to calculate a replacement for the descendant. Returns Type Description ValueTask<CSharpSyntaxNode> A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter(CSharpSyntaxNode, Func<CSharpSyntaxNode, CSharpSyntaxNode>) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static CSharpSyntaxNode RewriteIter(this CSharpSyntaxNode value, Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer) Parameters Type Name Description CSharpSyntaxNode value The value to rewrite. Func<CSharpSyntaxNode, CSharpSyntaxNode> transformer A transformation function to apply to every node in value repeatedly. Returns Type Description CSharpSyntaxNode The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. RewriteIter(CSharpSyntaxNode, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>>) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<CSharpSyntaxNode> RewriteIter(this CSharpSyntaxNode value, Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer) Parameters Type Name Description CSharpSyntaxNode value The value to rewrite. Func<CSharpSyntaxNode, ValueTask<CSharpSyntaxNode>> transformer An asynchronous transformation function to apply to every node in value repeatedly. Returns Type Description ValueTask<CSharpSyntaxNode> The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Remarks This method is not available on platforms which do not support ValueTask. SelfAndDescendants(CSharpSyntaxNode) Yields all of the nodes in the tree represented by value, starting at the top. Declaration public static IEnumerable<CSharpSyntaxNode> SelfAndDescendants(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The value to traverse. Returns Type Description IEnumerable<CSharpSyntaxNode> An enumerable containing all of the nodes in the tree represented by value, starting at the top. Remarks This is a depth-first pre-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); See Also DescendantsAndSelf<T>(IRewriter<T>, T) SelfAndDescendantsBreadthFirst(CSharpSyntaxNode) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<CSharpSyntaxNode> SelfAndDescendantsBreadthFirst(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The value to traverse. Returns Type Description IEnumerable<CSharpSyntaxNode> An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. SelfAndDescendantsInContext(CSharpSyntaxNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(CSharpSyntaxNode item, Func<CSharpSyntaxNode, CSharpSyntaxNode> replace)> SelfAndDescendantsInContext(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(CSharpSyntaxNode item, Func<CSharpSyntaxNode, CSharpSyntaxNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContextBreadthFirst(CSharpSyntaxNode) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(CSharpSyntaxNode item, Func<CSharpSyntaxNode, CSharpSyntaxNode> replace)> SelfAndDescendantsInContextBreadthFirst(this CSharpSyntaxNode value) Parameters Type Name Description CSharpSyntaxNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(CSharpSyntaxNode item, Func<CSharpSyntaxNode, CSharpSyntaxNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SetChildren(CSharpSyntaxNode, ReadOnlySpan<CSharpSyntaxNode>) Set the immediate children of the value. Declaration public static CSharpSyntaxNode SetChildren(this CSharpSyntaxNode value, ReadOnlySpan<CSharpSyntaxNode> newChildren) Parameters Type Name Description CSharpSyntaxNode value The old value, whose immediate children should be replaced. ReadOnlySpan<CSharpSyntaxNode> newChildren The new children. Returns Type Description CSharpSyntaxNode A copy of value with updated children. Remarks Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>, T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>, T) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, rewriter.SetChildren(Children.Two(new Lit(4), new Lit(5)), expr)); See Also SetChildren(ReadOnlySpan<T>) ZipFold<U>(CSharpSyntaxNode, CSharpSyntaxNode, Func<CSharpSyntaxNode, CSharpSyntaxNode, IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this CSharpSyntaxNode value1, CSharpSyntaxNode value2, Func<CSharpSyntaxNode, CSharpSyntaxNode, IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description CSharpSyntaxNode value1 CSharpSyntaxNode value2 Func<CSharpSyntaxNode, CSharpSyntaxNode, IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(CSharpSyntaxNode, CSharpSyntaxNode, Func<CSharpSyntaxNode, CSharpSyntaxNode, IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this CSharpSyntaxNode value1, CSharpSyntaxNode value2, Func<CSharpSyntaxNode, CSharpSyntaxNode, IEnumerable<U>, U> func) Parameters Type Name Description CSharpSyntaxNode value1 CSharpSyntaxNode value2 Func<CSharpSyntaxNode, CSharpSyntaxNode, IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(CSharpSyntaxNode[], Func<CSharpSyntaxNode[], IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this CSharpSyntaxNode[] values, Func<CSharpSyntaxNode[], IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description CSharpSyntaxNode[] values The trees to fold. Func<CSharpSyntaxNode[], IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(CSharpSyntaxNode[], Func<CSharpSyntaxNode[], IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this CSharpSyntaxNode[] values, Func<CSharpSyntaxNode[], IEnumerable<U>, U> func) Parameters Type Name Description CSharpSyntaxNode[] values The trees to fold. Func<CSharpSyntaxNode[], IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.Microsoft.CodeAnalysis.CSharp.html": {
    "href": "Sawmill.Microsoft.CodeAnalysis.CSharp.html",
    "title": "Namespace Sawmill.Microsoft.CodeAnalysis.CSharp | Benjamin.Pizza.DocTest",
    "keywords": "Namespace Sawmill.Microsoft.CodeAnalysis.CSharp Classes CSharpSyntaxNodeExtensions Extension methods for CSharpSyntaxNodes."
  },
  "Sawmill.Microsoft.CodeAnalysis.SyntaxNodeRewriter-1.html": {
    "href": "Sawmill.Microsoft.CodeAnalysis.SyntaxNodeRewriter-1.html",
    "title": "Class SyntaxNodeRewriter<T> | Benjamin.Pizza.DocTest",
    "keywords": "Class SyntaxNodeRewriter<T> An implementation of IRewriter<T> for subclasses of SyntaxNode. Inheritance object SyntaxNodeRewriter<T> Implements IRewriter<T> Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public class SyntaxNodeRewriter<T> : IRewriter<T> where T : SyntaxNode Type Parameters Name Description T The type of syntax node. Constructors SyntaxNodeRewriter() create a new instance of SyntaxNodeRewriter<T>. Declaration protected SyntaxNodeRewriter() Properties Instance Gets the single global instance of SyntaxNodeRewriter<T>. Declaration public static SyntaxNodeRewriter<T> Instance { get; } Property Value Type Description SyntaxNodeRewriter<T> The single global instance of SyntaxNodeRewriter<T>. Methods CountChildren(T) See CountChildren(T). Declaration public int CountChildren(T value) Parameters Type Name Description T value The value. Returns Type Description int value's number of immediate children. GetChildren(Span<T>, T) See GetChildren(Span<T>, T). Declaration public void GetChildren(Span<T> childrenReceiver, T value) Parameters Type Name Description Span<T> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(T). T value The value. SetChildren(ReadOnlySpan<T>, T) See SetChildren(ReadOnlySpan<T>, T). Declaration public T SetChildren(ReadOnlySpan<T> newChildren, T value) Parameters Type Name Description ReadOnlySpan<T> newChildren The new children. T value The old value, whose immediate children should be replaced. Returns Type Description T A copy of value with updated children. Implements IRewriter<T>"
  },
  "Sawmill.Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNodeExtensions.html": {
    "href": "Sawmill.Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNodeExtensions.html",
    "title": "Class VisualBasicSyntaxNodeExtensions | Benjamin.Pizza.DocTest",
    "keywords": "Class VisualBasicSyntaxNodeExtensions Extension methods for VisualBasicSyntaxNodes. Inheritance object VisualBasicSyntaxNodeExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public static class VisualBasicSyntaxNodeExtensions Methods ChildrenInContext(VisualBasicSyntaxNode) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. Declaration public static (VisualBasicSyntaxNode item, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> replace)[] ChildrenInContext(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The value to get the contexts for the immediate children. Returns Type Description (VisualBasicSyntaxNode item, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> replace)[] An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See Also SelfAndDescendantsInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) CountChildren(VisualBasicSyntaxNode) Count the immediate children of the value. Declaration public static int CountChildren(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The value. Returns Type Description int value's number of immediate children. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren(T) counts the immediate children of the topmost (Add) node. Assert.Equal(2, rewriter.CountChildren(expr)); See Also CountChildren() Cursor(VisualBasicSyntaxNode) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value. Declaration public static Cursor<VisualBasicSyntaxNode> Cursor(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The root node on which the newly created Cursor<T>(IRewriter<T>, T) should be focused. Returns Type Description Cursor<VisualBasicSyntaxNode> A Cursor<T>(IRewriter<T>, T) focused on the root node of value. DescendantAt(VisualBasicSyntaxNode, IEnumerable<Direction>) Returns the descendant at a particular location in value. Declaration public static VisualBasicSyntaxNode DescendantAt(this VisualBasicSyntaxNode value, IEnumerable<Direction> path) Parameters Type Name Description VisualBasicSyntaxNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Returns Type Description VisualBasicSyntaxNode The descendant found by following the directions in path. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelf(VisualBasicSyntaxNode) Yields all of the nodes in the tree represented by value, starting at the bottom. Declaration public static IEnumerable<VisualBasicSyntaxNode> DescendantsAndSelf(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The value to traverse. Returns Type Description IEnumerable<VisualBasicSyntaxNode> An enumerable containing all of the nodes in the tree represented by value, starting at the bottom. Remarks This is a depth-first post-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); See Also SelfAndDescendants<T>(IRewriter<T>, T) DescendantsAndSelfInContext(VisualBasicSyntaxNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(VisualBasicSyntaxNode item, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> replace)> DescendantsAndSelfInContext(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(VisualBasicSyntaxNode item, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See Also DescendantsAndSelf<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContext<T>(IRewriter<T>, T) Fold<T>(VisualBasicSyntaxNode, SpanFunc<T, VisualBasicSyntaxNode, T>) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static T Fold<T>(this VisualBasicSyntaxNode value, SpanFunc<T, VisualBasicSyntaxNode, T> func) Parameters Type Name Description VisualBasicSyntaxNode value The value to fold. SpanFunc<T, VisualBasicSyntaxNode, T> func The aggregation function. Returns Type Description T The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Fold<T>(VisualBasicSyntaxNode, Func<Memory<T>, VisualBasicSyntaxNode, ValueTask<T>>) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<T> Fold<T>(this VisualBasicSyntaxNode value, Func<Memory<T>, VisualBasicSyntaxNode, ValueTask<T>> func) Parameters Type Name Description VisualBasicSyntaxNode value The value to fold. Func<Memory<T>, VisualBasicSyntaxNode, ValueTask<T>> func The asynchronous aggregation function. Returns Type Description ValueTask<T> The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. GetChildren(VisualBasicSyntaxNode) Get the immediate children of the value. Declaration public static VisualBasicSyntaxNode[] GetChildren(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The value. Returns Type Description VisualBasicSyntaxNode[] The immediate children of value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); See Also GetChildren(Span<T>) GetChildren(VisualBasicSyntaxNode, Span<VisualBasicSyntaxNode>) Copy the immediate children of the value into childrenReceiver. Declaration public static void GetChildren(this VisualBasicSyntaxNode value, Span<VisualBasicSyntaxNode> childrenReceiver) Parameters Type Name Description VisualBasicSyntaxNode value The value. Span<VisualBasicSyntaxNode> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>, T) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[rewriter.CountChildren(expr)]; rewriter.GetChildren(array, expr); Assert.Equal(expected, array); See Also GetChildren(Span<T>) ReplaceDescendantAt<T>(VisualBasicSyntaxNode, IEnumerable<Direction>, VisualBasicSyntaxNode) Replaces the descendant at a particular location in value. Declaration public static VisualBasicSyntaxNode ReplaceDescendantAt<T>(this VisualBasicSyntaxNode value, IEnumerable<Direction> path, VisualBasicSyntaxNode newDescendant) Parameters Type Name Description VisualBasicSyntaxNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. VisualBasicSyntaxNode newDescendant The replacement descendant. Returns Type Description VisualBasicSyntaxNode A copy of value with newDescendant placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. Rewrite(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode>) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static VisualBasicSyntaxNode Rewrite(this VisualBasicSyntaxNode value, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer) Parameters Type Name Description VisualBasicSyntaxNode value The value to rewrite. Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer The transformation function to apply to every node in the tree. Returns Type Description VisualBasicSyntaxNode The result of applying transformer to every node in the tree represented by value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); Rewrite(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>>) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<VisualBasicSyntaxNode> Rewrite(this VisualBasicSyntaxNode value, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer) Parameters Type Name Description VisualBasicSyntaxNode value The value to rewrite. Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer The asynchronous transformation function to apply to every node in the tree. Returns Type Description ValueTask<VisualBasicSyntaxNode> The result of applying transformer to every node in the tree represented by value. Remarks This method is not available on platforms which do not support ValueTask. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); RewriteChildren(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode>) Update the immediate children of the value by applying a transformation function to each one. Declaration public static VisualBasicSyntaxNode RewriteChildren(this VisualBasicSyntaxNode value, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer) Parameters Type Name Description VisualBasicSyntaxNode value The old value, whose immediate children should be transformed by transformer. Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer A transformation function to apply to each of value's immediate children. Returns Type Description VisualBasicSyntaxNode A copy of value with updated children. RewriteChildren(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>>) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<VisualBasicSyntaxNode> RewriteChildren(this VisualBasicSyntaxNode value, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer) Parameters Type Name Description VisualBasicSyntaxNode value The old value, whose immediate children should be transformed by transformer. Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer An asynchronous transformation function to apply to each of value's immediate children. Returns Type Description ValueTask<VisualBasicSyntaxNode> A copy of value with updated children. Remarks This method is not available on platforms which do not support ValueTask. RewriteDescendantAt<T>(VisualBasicSyntaxNode, IEnumerable<Direction>, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode>) Apply a function at a particular location in value. Declaration public static VisualBasicSyntaxNode RewriteDescendantAt<T>(this VisualBasicSyntaxNode value, IEnumerable<Direction> path, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer) Parameters Type Name Description VisualBasicSyntaxNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer A function to calculate a replacement for the descendant. Returns Type Description VisualBasicSyntaxNode A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(VisualBasicSyntaxNode, IEnumerable<Direction>, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>>) Apply an asynchronous function at a particular location in value. Declaration public static ValueTask<VisualBasicSyntaxNode> RewriteDescendantAt<T>(this VisualBasicSyntaxNode value, IEnumerable<Direction> path, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer) Parameters Type Name Description VisualBasicSyntaxNode value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer An asynchronous function to calculate a replacement for the descendant. Returns Type Description ValueTask<VisualBasicSyntaxNode> A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode>) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static VisualBasicSyntaxNode RewriteIter(this VisualBasicSyntaxNode value, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer) Parameters Type Name Description VisualBasicSyntaxNode value The value to rewrite. Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> transformer A transformation function to apply to every node in value repeatedly. Returns Type Description VisualBasicSyntaxNode The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. RewriteIter(VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>>) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<VisualBasicSyntaxNode> RewriteIter(this VisualBasicSyntaxNode value, Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer) Parameters Type Name Description VisualBasicSyntaxNode value The value to rewrite. Func<VisualBasicSyntaxNode, ValueTask<VisualBasicSyntaxNode>> transformer An asynchronous transformation function to apply to every node in value repeatedly. Returns Type Description ValueTask<VisualBasicSyntaxNode> The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Remarks This method is not available on platforms which do not support ValueTask. SelfAndDescendants(VisualBasicSyntaxNode) Yields all of the nodes in the tree represented by value, starting at the top. Declaration public static IEnumerable<VisualBasicSyntaxNode> SelfAndDescendants(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The value to traverse. Returns Type Description IEnumerable<VisualBasicSyntaxNode> An enumerable containing all of the nodes in the tree represented by value, starting at the top. Remarks This is a depth-first pre-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); See Also DescendantsAndSelf<T>(IRewriter<T>, T) SelfAndDescendantsBreadthFirst(VisualBasicSyntaxNode) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<VisualBasicSyntaxNode> SelfAndDescendantsBreadthFirst(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The value to traverse. Returns Type Description IEnumerable<VisualBasicSyntaxNode> An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. SelfAndDescendantsInContext(VisualBasicSyntaxNode) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(VisualBasicSyntaxNode item, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> replace)> SelfAndDescendantsInContext(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(VisualBasicSyntaxNode item, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContextBreadthFirst(VisualBasicSyntaxNode) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(VisualBasicSyntaxNode item, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> replace)> SelfAndDescendantsInContextBreadthFirst(this VisualBasicSyntaxNode value) Parameters Type Name Description VisualBasicSyntaxNode value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(VisualBasicSyntaxNode item, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SetChildren(VisualBasicSyntaxNode, ReadOnlySpan<VisualBasicSyntaxNode>) Set the immediate children of the value. Declaration public static VisualBasicSyntaxNode SetChildren(this VisualBasicSyntaxNode value, ReadOnlySpan<VisualBasicSyntaxNode> newChildren) Parameters Type Name Description VisualBasicSyntaxNode value The old value, whose immediate children should be replaced. ReadOnlySpan<VisualBasicSyntaxNode> newChildren The new children. Returns Type Description VisualBasicSyntaxNode A copy of value with updated children. Remarks Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>, T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>, T) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, rewriter.SetChildren(Children.Two(new Lit(4), new Lit(5)), expr)); See Also SetChildren(ReadOnlySpan<T>) ZipFold<U>(VisualBasicSyntaxNode, VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode, IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this VisualBasicSyntaxNode value1, VisualBasicSyntaxNode value2, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode, IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description VisualBasicSyntaxNode value1 VisualBasicSyntaxNode value2 Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode, IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(VisualBasicSyntaxNode, VisualBasicSyntaxNode, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode, IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this VisualBasicSyntaxNode value1, VisualBasicSyntaxNode value2, Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode, IEnumerable<U>, U> func) Parameters Type Name Description VisualBasicSyntaxNode value1 VisualBasicSyntaxNode value2 Func<VisualBasicSyntaxNode, VisualBasicSyntaxNode, IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(VisualBasicSyntaxNode[], Func<VisualBasicSyntaxNode[], IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this VisualBasicSyntaxNode[] values, Func<VisualBasicSyntaxNode[], IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description VisualBasicSyntaxNode[] values The trees to fold. Func<VisualBasicSyntaxNode[], IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(VisualBasicSyntaxNode[], Func<VisualBasicSyntaxNode[], IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this VisualBasicSyntaxNode[] values, Func<VisualBasicSyntaxNode[], IEnumerable<U>, U> func) Parameters Type Name Description VisualBasicSyntaxNode[] values The trees to fold. Func<VisualBasicSyntaxNode[], IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.Microsoft.CodeAnalysis.VisualBasic.html": {
    "href": "Sawmill.Microsoft.CodeAnalysis.VisualBasic.html",
    "title": "Namespace Sawmill.Microsoft.CodeAnalysis.VisualBasic | Benjamin.Pizza.DocTest",
    "keywords": "Namespace Sawmill.Microsoft.CodeAnalysis.VisualBasic Classes VisualBasicSyntaxNodeExtensions Extension methods for VisualBasicSyntaxNodes."
  },
  "Sawmill.Microsoft.CodeAnalysis.html": {
    "href": "Sawmill.Microsoft.CodeAnalysis.html",
    "title": "Namespace Sawmill.Microsoft.CodeAnalysis | Benjamin.Pizza.DocTest",
    "keywords": "Namespace Sawmill.Microsoft.CodeAnalysis Classes SyntaxNodeRewriter<T> An implementation of IRewriter<T> for subclasses of SyntaxNode."
  },
  "Sawmill.Newtonsoft.Json.JTokenExtensions.html": {
    "href": "Sawmill.Newtonsoft.Json.JTokenExtensions.html",
    "title": "Class JTokenExtensions | Benjamin.Pizza.DocTest",
    "keywords": "Class JTokenExtensions Extension methods for Newtonsoft.Json.Linq.JTokens. Inheritance object JTokenExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public static class JTokenExtensions Methods ChildrenInContext(JToken) Returns an array containing each immediate child of value paired with a function to replace the child. This is typically useful when you need to replace a node's children one at a time, such as during mutation testing. Declaration public static (JToken item, Func<JToken, JToken> replace)[] ChildrenInContext(this JToken value) Parameters Type Name Description JToken value The value to get the contexts for the immediate children. Returns Type Description (JToken item, Func<JToken, JToken> replace)[] An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the child; calling the function with a new child \"plugs the hole\" in the context. See Also SelfAndDescendantsInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) CountChildren(JToken) Count the immediate children of the value. Declaration public static int CountChildren(this JToken value) Parameters Type Name Description JToken value The value. Returns Type Description int value's number of immediate children. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); CountChildren(T) counts the immediate children of the topmost (Add) node. Assert.Equal(2, rewriter.CountChildren(expr)); See Also CountChildren() Cursor(JToken) Create a Cursor<T>(IRewriter<T>, T) focused on the root node of value. Declaration public static Cursor<JToken> Cursor(this JToken value) Parameters Type Name Description JToken value The root node on which the newly created Cursor<T>(IRewriter<T>, T) should be focused. Returns Type Description Cursor<JToken> A Cursor<T>(IRewriter<T>, T) focused on the root node of value. DescendantAt(JToken, IEnumerable<Direction>) Returns the descendant at a particular location in value. Declaration public static JToken DescendantAt(this JToken value, IEnumerable<Direction> path) Parameters Type Name Description JToken value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Returns Type Description JToken The descendant found by following the directions in path. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. DescendantsAndSelf(JToken) Yields all of the nodes in the tree represented by value, starting at the bottom. Declaration public static IEnumerable<JToken> DescendantsAndSelf(this JToken value) Parameters Type Name Description JToken value The value to traverse. Returns Type Description IEnumerable<JToken> An enumerable containing all of the nodes in the tree represented by value, starting at the bottom. Remarks This is a depth-first post-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { new Lit(1), new Lit(2), new Add(new Lit(1), new Lit(2)), new Lit(3), expr }; Assert.Equal(expected, rewriter.DescendantsAndSelf(expr)); See Also SelfAndDescendants<T>(IRewriter<T>, T) DescendantsAndSelfInContext(JToken) Yields each node in the tree represented by value paired with a function to replace the node, starting at the bottom. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(JToken item, Func<JToken, JToken> replace)> DescendantsAndSelfInContext(this JToken value) Parameters Type Name Description JToken value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(JToken item, Func<JToken, JToken> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first post-order traversal. See Also DescendantsAndSelf<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContext<T>(IRewriter<T>, T) Fold<T>(JToken, SpanFunc<T, JToken, T>) Flattens all the nodes in the tree represented by value into a single result, using an aggregation function to combine each node with the results of folding its children. Declaration public static T Fold<T>(this JToken value, SpanFunc<T, JToken, T> func) Parameters Type Name Description JToken value The value to fold. SpanFunc<T, JToken, T> func The aggregation function. Returns Type Description T The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Fold<T>(JToken, Func<Memory<T>, JToken, ValueTask<T>>) Flattens all the nodes in the tree represented by value into a single result, using an asynchronous aggregation function to combine each node with the results of folding its children. Declaration public static ValueTask<T> Fold<T>(this JToken value, Func<Memory<T>, JToken, ValueTask<T>> func) Parameters Type Name Description JToken value The value to fold. Func<Memory<T>, JToken, ValueTask<T>> func The asynchronous aggregation function. Returns Type Description ValueTask<T> The result of aggregating the tree represented by value. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. GetChildren(JToken) Get the immediate children of the value. Declaration public static JToken[] GetChildren(this JToken value) Parameters Type Name Description JToken value The value. Returns Type Description JToken[] The immediate children of value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren<T>(IRewriter<T>, T) returns the immediate children of the topmost node. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; Assert.Equal(expected, rewriter.GetChildren(expr)); See Also GetChildren(Span<T>) GetChildren(JToken, Span<JToken>) Copy the immediate children of the value into childrenReceiver. Declaration public static void GetChildren(this JToken value, Span<JToken> childrenReceiver) Parameters Type Name Description JToken value The value. Span<JToken> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); GetChildren(Span<T>, T) copies the immediate children of the topmost node into the span. Expr[] expected = new[] { new Add( new Lit(1), new Lit(2) ), new Lit(3) }; var array = new Expr[rewriter.CountChildren(expr)]; rewriter.GetChildren(array, expr); Assert.Equal(expected, array); See Also GetChildren(Span<T>) ReplaceDescendantAt<T>(JToken, IEnumerable<Direction>, JToken) Replaces the descendant at a particular location in value. Declaration public static JToken ReplaceDescendantAt<T>(this JToken value, IEnumerable<Direction> path, JToken newDescendant) Parameters Type Name Description JToken value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. JToken newDescendant The replacement descendant. Returns Type Description JToken A copy of value with newDescendant placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. Rewrite(JToken, Func<JToken, JToken>) Rebuild a tree by applying a transformation function to every node from bottom to top. Declaration public static JToken Rewrite(this JToken value, Func<JToken, JToken> transformer) Parameters Type Name Description JToken value The value to rewrite. Func<JToken, JToken> transformer The transformation function to apply to every node in the tree. Returns Type Description JToken The result of applying transformer to every node in the tree represented by value. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, T>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, T>, T) has traversed the whole tree. Expr expected = transformer(new Add( transformer(new Add( transformer(new Lit(1)), transformer(new Lit(2)) )), transformer(new Lit(3)) )); Assert.Equal(expected, rewriter.Rewrite(transformer, expr)); Rewrite(JToken, Func<JToken, ValueTask<JToken>>) Rebuild a tree by applying an asynchronous transformation function to every node from bottom to top. Declaration public static ValueTask<JToken> Rewrite(this JToken value, Func<JToken, ValueTask<JToken>> transformer) Parameters Type Name Description JToken value The value to rewrite. Func<JToken, ValueTask<JToken>> transformer The asynchronous transformation function to apply to every node in the tree. Returns Type Description ValueTask<JToken> The result of applying transformer to every node in the tree represented by value. Remarks This method is not available on platforms which do not support ValueTask. Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) replaces the leaves of the tree with the result of calling transformer, then replaces their parents with the result of calling transformer, and so on. By the end, Rewrite<T>(IRewriter<T>, Func<T, ValueTask<T>>, T) has traversed the whole tree. Expr expected = await transformer(new Add( await transformer(new Add( await transformer(new Lit(1)), await transformer(new Lit(2)) )), await transformer(new Lit(3)) )); Assert.Equal(expected, await rewriter.Rewrite(transformer, expr)); RewriteChildren(JToken, Func<JToken, JToken>) Update the immediate children of the value by applying a transformation function to each one. Declaration public static JToken RewriteChildren(this JToken value, Func<JToken, JToken> transformer) Parameters Type Name Description JToken value The old value, whose immediate children should be transformed by transformer. Func<JToken, JToken> transformer A transformation function to apply to each of value's immediate children. Returns Type Description JToken A copy of value with updated children. RewriteChildren(JToken, Func<JToken, ValueTask<JToken>>) Update the immediate children of the value by applying an asynchronous transformation function to each one. Declaration public static ValueTask<JToken> RewriteChildren(this JToken value, Func<JToken, ValueTask<JToken>> transformer) Parameters Type Name Description JToken value The old value, whose immediate children should be transformed by transformer. Func<JToken, ValueTask<JToken>> transformer An asynchronous transformation function to apply to each of value's immediate children. Returns Type Description ValueTask<JToken> A copy of value with updated children. Remarks This method is not available on platforms which do not support ValueTask. RewriteDescendantAt<T>(JToken, IEnumerable<Direction>, Func<JToken, JToken>) Apply a function at a particular location in value. Declaration public static JToken RewriteDescendantAt<T>(this JToken value, IEnumerable<Direction> path, Func<JToken, JToken> transformer) Parameters Type Name Description JToken value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<JToken, JToken> transformer A function to calculate a replacement for the descendant. Returns Type Description JToken A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteDescendantAt<T>(JToken, IEnumerable<Direction>, Func<JToken, ValueTask<JToken>>) Apply an asynchronous function at a particular location in value. Declaration public static ValueTask<JToken> RewriteDescendantAt<T>(this JToken value, IEnumerable<Direction> path, Func<JToken, ValueTask<JToken>> transformer) Parameters Type Name Description JToken value The rewritable tree. IEnumerable<Direction> path The route to take to find the descendant. Func<JToken, ValueTask<JToken>> transformer An asynchronous function to calculate a replacement for the descendant. Returns Type Description ValueTask<JToken> A copy of value with the result of transformer placed at the location indicated by path. Type Parameters Name Description T The rewritable tree type. Remarks This method is not available on platforms which do not support ValueTask. Exceptions Type Condition InvalidOperationException Thrown if path leads off the edge of the tree. RewriteIter(JToken, Func<JToken, JToken>) Rebuild a tree by repeatedly applying a transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static JToken RewriteIter(this JToken value, Func<JToken, JToken> transformer) Parameters Type Name Description JToken value The value to rewrite. Func<JToken, JToken> transformer A transformation function to apply to every node in value repeatedly. Returns Type Description JToken The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. RewriteIter(JToken, Func<JToken, ValueTask<JToken>>) Rebuild a tree by repeatedly applying an asynchronous transformation function to every node in the tree, until a fixed point is reached. transformer should always eventually return its argument unchanged, or this method will loop. That is, x.RewriteIter(transformer).SelfAndDescendants().All(x => await transformer(x) == x). This is typically useful when you want to put your tree into a normal form by applying a collection of rewrite rules until none of them can fire any more. Declaration public static ValueTask<JToken> RewriteIter(this JToken value, Func<JToken, ValueTask<JToken>> transformer) Parameters Type Name Description JToken value The value to rewrite. Func<JToken, ValueTask<JToken>> transformer An asynchronous transformation function to apply to every node in value repeatedly. Returns Type Description ValueTask<JToken> The result of applying transformer to every node in the tree represented by value repeatedly until a fixed point is reached. Remarks This method is not available on platforms which do not support ValueTask. SelfAndDescendants(JToken) Yields all of the nodes in the tree represented by value, starting at the top. Declaration public static IEnumerable<JToken> SelfAndDescendants(this JToken value) Parameters Type Name Description JToken value The value to traverse. Returns Type Description IEnumerable<JToken> An enumerable containing all of the nodes in the tree represented by value, starting at the top. Remarks This is a depth-first pre-order traversal. Examples Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); Expr[] expected = new[] { expr, new Add(new Lit(1), new Lit(2)), new Lit(1), new Lit(2), new Lit(3), }; Assert.Equal(expected, rewriter.SelfAndDescendants(expr)); See Also DescendantsAndSelf<T>(IRewriter<T>, T) SelfAndDescendantsBreadthFirst(JToken) Yields all of the nodes in the tree represented by value in a breadth-first traversal order. This is a breadth-first pre-order traversal. Declaration public static IEnumerable<JToken> SelfAndDescendantsBreadthFirst(this JToken value) Parameters Type Name Description JToken value The value to traverse. Returns Type Description IEnumerable<JToken> An enumerable containing all of the nodes in the tree represented by value in a breadth-first traversal order. SelfAndDescendantsInContext(JToken) Yields each node in the tree represented by value paired with a function to replace the node, starting at the top. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(JToken item, Func<JToken, JToken> replace)> SelfAndDescendantsInContext(this JToken value) Parameters Type Name Description JToken value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(JToken item, Func<JToken, JToken> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a depth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SelfAndDescendantsInContextBreadthFirst(JToken) Yields each node in the tree represented by value paired with a function to replace the node, in a breadth-first traversal order. This is typically useful when you need to replace nodes one at a time, such as during mutation testing. Declaration public static IEnumerable<(JToken item, Func<JToken, JToken> replace)> SelfAndDescendantsInContextBreadthFirst(this JToken value) Parameters Type Name Description JToken value The value to get the contexts for the descendants. Returns Type Description IEnumerable<(JToken item, Func<JToken, JToken> replace)> An enumerable of contexts. Remarks The replacement function can be seen as the \"context\" of the node; calling the function with a new node \"plugs the hole\" in the context. This is a breadth-first pre-order traversal. See Also SelfAndDescendants<T>(IRewriter<T>, T) ChildrenInContext<T>(IRewriter<T>, T) DescendantsAndSelfInContext<T>(IRewriter<T>, T) SetChildren(JToken, ReadOnlySpan<JToken>) Set the immediate children of the value. Declaration public static JToken SetChildren(this JToken value, ReadOnlySpan<JToken> newChildren) Parameters Type Name Description JToken value The old value, whose immediate children should be replaced. ReadOnlySpan<JToken> newChildren The new children. Returns Type Description JToken A copy of value with updated children. Remarks Callers should ensure that newChildren contains the same number of children as was returned by GetChildren(Span<T>, T). Examples Given a representation of the expression (1+2)+3. Expr expr = new Add( new Add( new Lit(1), new Lit(2) ), new Lit(3) ); SetChildren(ReadOnlySpan<T>, T) replaces the immediate children of the topmost node. Expr expected = new Add( new Lit(4), new Lit(5) ); Assert.Equal(expected, rewriter.SetChildren(Children.Two(new Lit(4), new Lit(5)), expr)); See Also SetChildren(ReadOnlySpan<T>) ZipFold<U>(JToken, JToken, Func<JToken, JToken, IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this JToken value1, JToken value2, Func<JToken, JToken, IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description JToken value1 JToken value2 Func<JToken, JToken, IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(JToken, JToken, Func<JToken, JToken, IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this JToken value1, JToken value2, Func<JToken, JToken, IEnumerable<U>, U> func) Parameters Type Name Description JToken value1 JToken value2 Func<JToken, JToken, IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(JToken[], Func<JToken[], IAsyncEnumerable<U>, ValueTask<U>>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static ValueTask<U> ZipFold<U>(this JToken[] values, Func<JToken[], IAsyncEnumerable<U>, ValueTask<U>> func) Parameters Type Name Description JToken[] values The trees to fold. Func<JToken[], IAsyncEnumerable<U>, ValueTask<U>> func The aggregation function. Returns Type Description ValueTask<U> The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Remarks This method is not available on platforms which do not support ValueTask and IAsyncEnumerable<T>. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IAsyncEnumerable<U>, ValueTask<U>>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } ); ZipFold<U>(JToken[], Func<JToken[], IEnumerable<U>, U>) Flatten all of the nodes in the trees represented by values into a single value at the same time, using an aggregation function to combine nodes with the results of aggregating their children. The trees are iterated in lock-step, much like an n-ary Zip<TFirst, TSecond, TResult>(IEnumerable<TFirst>, IEnumerable<TSecond>, Func<TFirst, TSecond, TResult>). When trees are not the same size, the larger ones are truncated both horizontally and vertically. That is, if a pair of nodes have a different number of children, the rightmost children of the larger of the two nodes are discarded. Declaration public static U ZipFold<U>(this JToken[] values, Func<JToken[], IEnumerable<U>, U> func) Parameters Type Name Description JToken[] values The trees to fold. Func<JToken[], IEnumerable<U>, U> func The aggregation function. Returns Type Description U The result of aggregating the two trees. Type Parameters Name Description U The return type of the aggregation. Examples Here's an example of using ZipFold<T, U>(IRewriter<T>, Func<T[], IEnumerable<U>, U>, params T[]) to test if two trees are syntactically equal. static bool Equals(this Expr left, Expr right) => left.ZipFold<Expr, bool>( right, (xs, results) => { switch (xs[0]) { case Add a1 when xs[1] is Add a2: return results.All(x => x); case Lit l1 when xs[1] is Lit l2: return l1.Value == l2.Value; default: return false; } } );"
  },
  "Sawmill.Newtonsoft.Json.JTokenRewriter.html": {
    "href": "Sawmill.Newtonsoft.Json.JTokenRewriter.html",
    "title": "Class JTokenRewriter | Benjamin.Pizza.DocTest",
    "keywords": "Class JTokenRewriter An implementation of IRewriter<T> for Newtonsoft.Json.Linq.JTokens. Inheritance object JTokenRewriter Implements IRewriter<JToken> Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Declaration public class JTokenRewriter : IRewriter<JToken> Constructors JTokenRewriter() Create a new instance of JTokenRewriter. Declaration protected JTokenRewriter() Properties Instance Gets the single global instance of JTokenRewriter. Declaration public static JTokenRewriter Instance { get; } Property Value Type Description JTokenRewriter The single global instance of JTokenRewriter. Methods CountChildren(JToken) See CountChildren(T). Declaration public int CountChildren(JToken value) Parameters Type Name Description JToken value The value. Returns Type Description int value's number of immediate children. GetChildren(Span<JToken>, JToken) See GetChildren(Span<T>, T). Declaration public void GetChildren(Span<JToken> childrenReceiver, JToken value) Parameters Type Name Description Span<JToken> childrenReceiver A Span<T> to copy value's immediate children into. The Span<T>'s Length will be equal to the number returned by CountChildren(JToken). JToken value The value. SetChildren(ReadOnlySpan<JToken>, JToken) See SetChildren(ReadOnlySpan<T>, T). Declaration public JToken SetChildren(ReadOnlySpan<JToken> newChildren, JToken value) Parameters Type Name Description ReadOnlySpan<JToken> newChildren The new children. JToken value The old value, whose immediate children should be replaced. Returns Type Description JToken A copy of value with updated children. Implements IRewriter<T>"
  },
  "Sawmill.Newtonsoft.Json.html": {
    "href": "Sawmill.Newtonsoft.Json.html",
    "title": "Namespace Sawmill.Newtonsoft.Json | Benjamin.Pizza.DocTest",
    "keywords": "Namespace Sawmill.Newtonsoft.Json Classes JTokenExtensions Extension methods for Newtonsoft.Json.Linq.JTokens. JTokenRewriter An implementation of IRewriter<T> for Newtonsoft.Json.Linq.JTokens."
  },
  "index.html": {
    "href": "index.html",
    "title": "Page Redirection",
    "keywords": ""
  }
}